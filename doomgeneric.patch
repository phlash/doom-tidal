diff --git a/doomgeneric/am_map.c b/doomgeneric/am_map.c
index d3d504e..9c2ae1b 100644
--- a/doomgeneric/am_map.c
+++ b/doomgeneric/am_map.c
@@ -99,11 +99,11 @@
 #define M_ZOOMOUT       ((int) (FRACUNIT/1.02))
 
 // translates between frame-buffer and map distances
-#define FTOM(x) FixedMul(((x)<<16),scale_ftom)
-#define MTOF(x) (FixedMul((x),scale_mtof)>>16)
+#define FTOM(x) FixedMul(((x)<<16),am_.scale_ftom)
+#define MTOF(x) (FixedMul((x),am_.scale_mtof)>>16)
 // translates between frame-buffer and map coordinates
-#define CXMTOF(x)  (f_x + MTOF((x)-m_x))
-#define CYMTOF(y)  (f_y + (f_h - MTOF((y)-m_y)))
+#define CXMTOF(x)  (am_.f_x + MTOF((x)-am_.m_x))
+#define CYMTOF(y)  (am_.f_y + (am_.f_h - MTOF((y)-am_.m_y)))
 
 // the following is crap
 #define LINE_NEVERSEE ML_DONTDRAW
@@ -141,7 +141,7 @@ typedef struct
 //   starting from the middle.
 //
 #define R ((8*PLAYERRADIUS)/7)
-mline_t player_arrow[] = {
+static const mline_t player_arrow[] = {
     { { -R+R/8, 0 }, { R, 0 } }, // -----
     { { R, 0 }, { R-R/2, R/4 } },  // ----->
     { { R, 0 }, { R-R/2, -R/4 } },
@@ -153,7 +153,7 @@ mline_t player_arrow[] = {
 #undef R
 
 #define R ((8*PLAYERRADIUS)/7)
-mline_t cheat_player_arrow[] = {
+static const mline_t cheat_player_arrow[] = {
     { { -R+R/8, 0 }, { R, 0 } }, // -----
     { { R, 0 }, { R-R/2, R/6 } },  // ----->
     { { R, 0 }, { R-R/2, -R/6 } },
@@ -174,98 +174,87 @@ mline_t cheat_player_arrow[] = {
 #undef R
 
 #define R (FRACUNIT)
-mline_t triangle_guy[] = {
-    { { (fixed_t)(-.867*R), (fixed_t)(-.5*R) }, { (fixed_t)(.867*R ), (fixed_t)(-.5*R) } },
-    { { (fixed_t)(.867*R ), (fixed_t)(-.5*R) }, { (fixed_t)(0      ), (fixed_t)(R    ) } },
-    { { (fixed_t)(0      ), (fixed_t)(R    ) }, { (fixed_t)(-.867*R), (fixed_t)(-.5*R) } }
-};
-#undef R
-
-#define R (FRACUNIT)
-mline_t thintriangle_guy[] = {
+static const mline_t thintriangle_guy[] = {
     { { (fixed_t)(-.5*R), (fixed_t)(-.7*R) }, { (fixed_t)(R    ), (fixed_t)(0    ) } },
     { { (fixed_t)(R    ), (fixed_t)(0    ) }, { (fixed_t)(-.5*R), (fixed_t)(.7*R ) } },
     { { (fixed_t)(-.5*R), (fixed_t)(.7*R ) }, { (fixed_t)(-.5*R), (fixed_t)(-.7*R) } }
 };
 #undef R
 
+boolean    	automapactive;
 
+static const int 	finit_width = SCREENWIDTH;
+static const int 	finit_height = SCREENHEIGHT - 32;
 
-
-static int 	cheating = 0;
-static int 	grid = 0;
-
-static int 	leveljuststarted = 1; 	// kluge until AM_LevelInit() is called
-
-boolean    	automapactive = false;
-static int 	finit_width = SCREENWIDTH;
-static int 	finit_height = SCREENHEIGHT - 32;
+// previously static locals, now globals in a namespace structure, for uPython compat.
+struct {
+    int 	cheating;
+    int 	grid;
 
 // location of window on screen
-static int 	f_x;
-static int	f_y;
+    int 	f_x;
+    int	f_y;
 
 // size of window on screen
-static int 	f_w;
-static int	f_h;
+    int 	f_w;
+    int	f_h;
 
-static int 	lightlev; 		// used for funky strobing effect
-static byte*	fb; 			// pseudo-frame buffer
-static int 	amclock;
+    int 	lightlev; 		// used for funky strobing effect
+    byte*	fb; 			// pseudo-frame buffer
+    int 	amclock;
 
-static mpoint_t m_paninc; // how far the window pans each tic (map coords)
-static fixed_t 	mtof_zoommul; // how far the window zooms in each tic (map coords)
-static fixed_t 	ftom_zoommul; // how far the window zooms in each tic (fb coords)
+    mpoint_t m_paninc; // how far the window pans each tic (map coords)
+    fixed_t 	mtof_zoommul; // how far the window zooms in each tic (map coords)
+    fixed_t 	ftom_zoommul; // how far the window zooms in each tic (fb coords)
 
-static fixed_t 	m_x, m_y;   // LL x,y where the window is on the map (map coords)
-static fixed_t 	m_x2, m_y2; // UR x,y where the window is on the map (map coords)
+    fixed_t 	m_x, m_y;   // LL x,y where the window is on the map (map coords)
+    fixed_t 	m_x2, m_y2; // UR x,y where the window is on the map (map coords)
 
 //
 // width/height of window on map (map coords)
 //
-static fixed_t 	m_w;
-static fixed_t	m_h;
+    fixed_t m_w;
+    fixed_t	m_h;
 
 // based on level size
-static fixed_t 	min_x;
-static fixed_t	min_y; 
-static fixed_t 	max_x;
-static fixed_t  max_y;
+    fixed_t min_x;
+    fixed_t	min_y; 
+    fixed_t max_x;
+    fixed_t max_y;
 
-static fixed_t 	max_w; // max_x-min_x,
-static fixed_t  max_h; // max_y-min_y
+    fixed_t 	max_w; // max_x-min_x,
+    fixed_t  max_h; // max_y-min_y
 
 // based on player size
-static fixed_t 	min_w;
-static fixed_t  min_h;
+    fixed_t 	min_w;
+    fixed_t  min_h;
 
 
-static fixed_t 	min_scale_mtof; // used to tell when to stop zooming out
-static fixed_t 	max_scale_mtof; // used to tell when to stop zooming in
+    fixed_t 	min_scale_mtof; // used to tell when to stop zooming out
+    fixed_t 	max_scale_mtof; // used to tell when to stop zooming in
 
 // old stuff for recovery later
-static fixed_t old_m_w, old_m_h;
-static fixed_t old_m_x, old_m_y;
+    fixed_t old_m_w, old_m_h;
+    fixed_t old_m_x, old_m_y;
 
 // old location used by the Follower routine
-static mpoint_t f_oldloc;
+    mpoint_t f_oldloc;
 
 // used by MTOF to scale from map-to-frame-buffer coords
-static fixed_t scale_mtof = (fixed_t)INITSCALEMTOF;
+    fixed_t scale_mtof;
 // used by FTOM to scale from frame-buffer-to-map coords (=1/scale_mtof)
-static fixed_t scale_ftom;
-
-static player_t *plr; // the player represented by an arrow
+    fixed_t scale_ftom;
 
-static patch_t *marknums[10]; // numbers used for marking by the automap
-static mpoint_t markpoints[AM_NUMMARKPOINTS]; // where the points are
-static int markpointnum = 0; // next point to be assigned
+    player_t *plr; // the player represented by an arrow
 
-static int followplayer = 1; // specifies whether to follow the player around
+    patch_t *marknums[10]; // numbers used for marking by the automap
+    mpoint_t markpoints[AM_NUMMARKPOINTS]; // where the points are
+    int markpointnum; // next point to be assigned
 
-cheatseq_t cheat_amap = CHEAT("iddt", 0);
+    int followplayer; // specifies whether to follow the player around
+} am_;
 
-static boolean stopped = true;
+const cheatseq_t cheat_amap = CHEAT("iddt", 0);
 
 // Calculates the slope and slope according to the x-axis of a line
 // segment in map coordinates (with the upright y-axis n' all) so
@@ -292,14 +281,14 @@ AM_getIslope
 //
 void AM_activateNewScale(void)
 {
-    m_x += m_w/2;
-    m_y += m_h/2;
-    m_w = FTOM(f_w);
-    m_h = FTOM(f_h);
-    m_x -= m_w/2;
-    m_y -= m_h/2;
-    m_x2 = m_x + m_w;
-    m_y2 = m_y + m_h;
+    am_.m_x += am_.m_w/2;
+    am_.m_y += am_.m_h/2;
+    am_.m_w = FTOM(am_.f_w);
+    am_.m_h = FTOM(am_.f_h);
+    am_.m_x -= am_.m_w/2;
+    am_.m_y -= am_.m_h/2;
+    am_.m_x2 = am_.m_x + am_.m_w;
+    am_.m_y2 = am_.m_y + am_.m_h;
 }
 
 //
@@ -307,10 +296,10 @@ void AM_activateNewScale(void)
 //
 void AM_saveScaleAndLoc(void)
 {
-    old_m_x = m_x;
-    old_m_y = m_y;
-    old_m_w = m_w;
-    old_m_h = m_h;
+    am_.old_m_x = am_.m_x;
+    am_.old_m_y = am_.m_y;
+    am_.old_m_w = am_.m_w;
+    am_.old_m_h = am_.m_h;
 }
 
 //
@@ -319,22 +308,22 @@ void AM_saveScaleAndLoc(void)
 void AM_restoreScaleAndLoc(void)
 {
 
-    m_w = old_m_w;
-    m_h = old_m_h;
-    if (!followplayer)
+    am_.m_w = am_.old_m_w;
+    am_.m_h = am_.old_m_h;
+    if (!am_.followplayer)
     {
-	m_x = old_m_x;
-	m_y = old_m_y;
+	am_.m_x = am_.old_m_x;
+	am_.m_y = am_.old_m_y;
     } else {
-	m_x = plr->mo->x - m_w/2;
-	m_y = plr->mo->y - m_h/2;
+	am_.m_x = am_.plr->mo->x - am_.m_w/2;
+	am_.m_y = am_.plr->mo->y - am_.m_h/2;
     }
-    m_x2 = m_x + m_w;
-    m_y2 = m_y + m_h;
+    am_.m_x2 = am_.m_x + am_.m_w;
+    am_.m_y2 = am_.m_y + am_.m_h;
 
     // Change the scaling multipliers
-    scale_mtof = FixedDiv(f_w<<FRACBITS, m_w);
-    scale_ftom = FixedDiv(FRACUNIT, scale_mtof);
+    am_.scale_mtof = FixedDiv(am_.f_w<<FRACBITS, am_.m_w);
+    am_.scale_ftom = FixedDiv(FRACUNIT, am_.scale_mtof);
 }
 
 //
@@ -342,9 +331,9 @@ void AM_restoreScaleAndLoc(void)
 //
 void AM_addMark(void)
 {
-    markpoints[markpointnum].x = m_x + m_w/2;
-    markpoints[markpointnum].y = m_y + m_h/2;
-    markpointnum = (markpointnum + 1) % AM_NUMMARKPOINTS;
+    am_.markpoints[am_.markpointnum].x = am_.m_x + am_.m_w/2;
+    am_.markpoints[am_.markpointnum].y = am_.m_y + am_.m_h/2;
+    am_.markpointnum = (am_.markpointnum + 1) % AM_NUMMARKPOINTS;
 
 }
 
@@ -358,33 +347,33 @@ void AM_findMinMaxBoundaries(void)
     fixed_t a;
     fixed_t b;
 
-    min_x = min_y =  INT_MAX;
-    max_x = max_y = -INT_MAX;
+    am_.min_x = am_.min_y =  INT_MAX;
+    am_.max_x = am_.max_y = -INT_MAX;
   
     for (i=0;i<numvertexes;i++)
     {
-	if (vertexes[i].x < min_x)
-	    min_x = vertexes[i].x;
-	else if (vertexes[i].x > max_x)
-	    max_x = vertexes[i].x;
+	if (vertexes[i].x < am_.min_x)
+	    am_.min_x = vertexes[i].x;
+	else if (vertexes[i].x > am_.max_x)
+	    am_.max_x = vertexes[i].x;
     
-	if (vertexes[i].y < min_y)
-	    min_y = vertexes[i].y;
-	else if (vertexes[i].y > max_y)
-	    max_y = vertexes[i].y;
+	if (vertexes[i].y < am_.min_y)
+	    am_.min_y = vertexes[i].y;
+	else if (vertexes[i].y > am_.max_y)
+	    am_.max_y = vertexes[i].y;
     }
   
-    max_w = max_x - min_x;
-    max_h = max_y - min_y;
+    am_.max_w = am_.max_x - am_.min_x;
+    am_.max_h = am_.max_y - am_.min_y;
 
-    min_w = 2*PLAYERRADIUS; // const? never changed?
-    min_h = 2*PLAYERRADIUS;
+    am_.min_w = 2*PLAYERRADIUS; // const? never changed?
+    am_.min_h = 2*PLAYERRADIUS;
 
-    a = FixedDiv(f_w<<FRACBITS, max_w);
-    b = FixedDiv(f_h<<FRACBITS, max_h);
+    a = FixedDiv(am_.f_w<<FRACBITS, am_.max_w);
+    b = FixedDiv(am_.f_h<<FRACBITS, am_.max_h);
   
-    min_scale_mtof = a < b ? a : b;
-    max_scale_mtof = FixedDiv(f_h<<FRACBITS, 2*PLAYERRADIUS);
+    am_.min_scale_mtof = a < b ? a : b;
+    am_.max_scale_mtof = FixedDiv(am_.f_h<<FRACBITS, 2*PLAYERRADIUS);
 
 }
 
@@ -394,27 +383,27 @@ void AM_findMinMaxBoundaries(void)
 //
 void AM_changeWindowLoc(void)
 {
-    if (m_paninc.x || m_paninc.y)
+    if (am_.m_paninc.x || am_.m_paninc.y)
     {
-	followplayer = 0;
-	f_oldloc.x = INT_MAX;
+	am_.followplayer = 0;
+	am_.f_oldloc.x = INT_MAX;
     }
 
-    m_x += m_paninc.x;
-    m_y += m_paninc.y;
+    am_.m_x += am_.m_paninc.x;
+    am_.m_y += am_.m_paninc.y;
 
-    if (m_x + m_w/2 > max_x)
-	m_x = max_x - m_w/2;
-    else if (m_x + m_w/2 < min_x)
-	m_x = min_x - m_w/2;
+    if (am_.m_x + am_.m_w/2 > am_.max_x)
+	am_.m_x = am_.max_x - am_.m_w/2;
+    else if (am_.m_x + am_.m_w/2 < am_.min_x)
+	am_.m_x = am_.min_x - am_.m_w/2;
   
-    if (m_y + m_h/2 > max_y)
-	m_y = max_y - m_h/2;
-    else if (m_y + m_h/2 < min_y)
-	m_y = min_y - m_h/2;
+    if (am_.m_y + am_.m_h/2 > am_.max_y)
+	am_.m_y = am_.max_y - am_.m_h/2;
+    else if (am_.m_y + am_.m_h/2 < am_.min_y)
+	am_.m_y = am_.min_y - am_.m_h/2;
 
-    m_x2 = m_x + m_w;
-    m_y2 = m_y + m_h;
+    am_.m_x2 = am_.m_x + am_.m_w;
+    am_.m_y2 = am_.m_y + am_.m_h;
 }
 
 
@@ -424,53 +413,53 @@ void AM_changeWindowLoc(void)
 void AM_initVariables(void)
 {
     int pnum;
-    static event_t st_notify = { ev_keyup, AM_MSGENTERED, 0, 0 };
+    static const event_t st_notify = { ev_keyup, AM_MSGENTERED, 0, 0 };
 
     automapactive = true;
-    fb = I_VideoBuffer;
+    am_.fb = I_VideoBuffer;
 
-    f_oldloc.x = INT_MAX;
-    amclock = 0;
-    lightlev = 0;
+    am_.f_oldloc.x = INT_MAX;
+    am_.amclock = 0;
+    am_.lightlev = 0;
 
-    m_paninc.x = m_paninc.y = 0;
-    ftom_zoommul = FRACUNIT;
-    mtof_zoommul = FRACUNIT;
+    am_.m_paninc.x = am_.m_paninc.y = 0;
+    am_.ftom_zoommul = FRACUNIT;
+    am_.mtof_zoommul = FRACUNIT;
 
-    m_w = FTOM(f_w);
-    m_h = FTOM(f_h);
+    am_.m_w = FTOM(am_.f_w);
+    am_.m_h = FTOM(am_.f_h);
 
     // find player to center on initially
     if (playeringame[consoleplayer])
     {
-        plr = &players[consoleplayer];
+        am_.plr = &players[consoleplayer];
     }
     else
     {
-        plr = &players[0];
+        am_.plr = &players[0];
 
 	for (pnum=0;pnum<MAXPLAYERS;pnum++)
         {
 	    if (playeringame[pnum])
             {
-                plr = &players[pnum];
+                am_.plr = &players[pnum];
 		break;
             }
         }
     }
 
-    m_x = plr->mo->x - m_w/2;
-    m_y = plr->mo->y - m_h/2;
+    am_.m_x = am_.plr->mo->x - am_.m_w/2;
+    am_.m_y = am_.plr->mo->y - am_.m_h/2;
     AM_changeWindowLoc();
 
     // for saving & restoring
-    old_m_x = m_x;
-    old_m_y = m_y;
-    old_m_w = m_w;
-    old_m_h = m_h;
+    am_.old_m_x = am_.m_x;
+    am_.old_m_y = am_.m_y;
+    am_.old_m_w = am_.m_w;
+    am_.old_m_h = am_.m_h;
 
     // inform the status bar of the change
-    ST_Responder(&st_notify);
+    ST_Responder((event_t *)&st_notify);
 
 }
 
@@ -485,7 +474,7 @@ void AM_loadPics(void)
     for (i=0;i<10;i++)
     {
 	DEH_snprintf(namebuf, 9, "AMMNUM%d", i);
-	marknums[i] = W_CacheLumpName(namebuf, PU_STATIC);
+	am_.marknums[i] = W_CacheLumpName(namebuf, PU_STATIC);
     }
 
 }
@@ -507,8 +496,8 @@ void AM_clearMarks(void)
     int i;
 
     for (i=0;i<AM_NUMMARKPOINTS;i++)
-	markpoints[i].x = -1; // means empty
-    markpointnum = 0;
+	am_.markpoints[i].x = -1; // means empty
+    am_.markpointnum = 0;
 }
 
 //
@@ -517,19 +506,17 @@ void AM_clearMarks(void)
 //
 void AM_LevelInit(void)
 {
-    leveljuststarted = 0;
-
-    f_x = f_y = 0;
-    f_w = finit_width;
-    f_h = finit_height;
+    am_.f_x = am_.f_y = 0;
+    am_.f_w = finit_width;
+    am_.f_h = finit_height;
 
     AM_clearMarks();
 
     AM_findMinMaxBoundaries();
-    scale_mtof = FixedDiv(min_scale_mtof, (int) (0.7*FRACUNIT));
-    if (scale_mtof > max_scale_mtof)
-	scale_mtof = min_scale_mtof;
-    scale_ftom = FixedDiv(FRACUNIT, scale_mtof);
+    am_.scale_mtof = FixedDiv(am_.min_scale_mtof, (int) (0.7*FRACUNIT));
+    if (am_.scale_mtof > am_.max_scale_mtof)
+	am_.scale_mtof = am_.min_scale_mtof;
+    am_.scale_ftom = FixedDiv(FRACUNIT, am_.scale_mtof);
 }
 
 
@@ -540,28 +527,35 @@ void AM_LevelInit(void)
 //
 void AM_Stop (void)
 {
-    static event_t st_notify = { 0, ev_keyup, AM_MSGEXITED, 0 };
+    static const event_t st_notify = { 0, ev_keyup, AM_MSGEXITED, 0 };
 
     AM_unloadPics();
     automapactive = false;
-    ST_Responder(&st_notify);
-    stopped = true;
+    ST_Responder((event_t *)&st_notify);
 }
 
 //
 //
 //
+struct {
+    int hasrun;
+    int lastlevel;
+    int lastepisode;
+} ams_;
 void AM_Start (void)
 {
-    static int lastlevel = -1, lastepisode = -1;
+	if (!ams_.hasrun) {
+		ams_.hasrun = 1;
+		ams_.lastlevel = -1;
+		ams_.lastepisode = -1;
+	}
 
-    if (!stopped) AM_Stop();
-    stopped = false;
-    if (lastlevel != gamemap || lastepisode != gameepisode)
+    if (automapactive) AM_Stop();
+    if (ams_.lastlevel != gamemap || ams_.lastepisode != gameepisode)
     {
 	AM_LevelInit();
-	lastlevel = gamemap;
-	lastepisode = gameepisode;
+	ams_.lastlevel = gamemap;
+	ams_.lastepisode = gameepisode;
     }
     AM_initVariables();
     AM_loadPics();
@@ -572,8 +566,8 @@ void AM_Start (void)
 //
 void AM_minOutWindowScale(void)
 {
-    scale_mtof = min_scale_mtof;
-    scale_ftom = FixedDiv(FRACUNIT, scale_mtof);
+    am_.scale_mtof = am_.min_scale_mtof;
+    am_.scale_ftom = FixedDiv(FRACUNIT, am_.scale_mtof);
     AM_activateNewScale();
 }
 
@@ -582,8 +576,8 @@ void AM_minOutWindowScale(void)
 //
 void AM_maxOutWindowScale(void)
 {
-    scale_mtof = max_scale_mtof;
-    scale_ftom = FixedDiv(FRACUNIT, scale_mtof);
+    am_.scale_mtof = am_.max_scale_mtof;
+    am_.scale_ftom = FixedDiv(FRACUNIT, am_.scale_mtof);
     AM_activateNewScale();
 }
 
@@ -591,14 +585,16 @@ void AM_maxOutWindowScale(void)
 //
 // Handle events (user inputs) in automap mode
 //
+struct {
+    int bigstate;
+    char buffer[20];
+} amr_;
 boolean
 AM_Responder
 ( event_t*	ev )
 {
 
     int rc;
-    static int bigstate=0;
-    static char buffer[20];
     int key;
 
     rc = false;
@@ -619,44 +615,44 @@ AM_Responder
 
         if (key == key_map_east)          // pan right
         {
-            if (!followplayer) m_paninc.x = FTOM(F_PANINC);
+            if (!am_.followplayer) am_.m_paninc.x = FTOM(F_PANINC);
             else rc = false;
         }
         else if (key == key_map_west)     // pan left
         {
-            if (!followplayer) m_paninc.x = -FTOM(F_PANINC);
+            if (!am_.followplayer) am_.m_paninc.x = -FTOM(F_PANINC);
             else rc = false;
         }
         else if (key == key_map_north)    // pan up
         {
-            if (!followplayer) m_paninc.y = FTOM(F_PANINC);
+            if (!am_.followplayer) am_.m_paninc.y = FTOM(F_PANINC);
             else rc = false;
         }
         else if (key == key_map_south)    // pan down
         {
-            if (!followplayer) m_paninc.y = -FTOM(F_PANINC);
+            if (!am_.followplayer) am_.m_paninc.y = -FTOM(F_PANINC);
             else rc = false;
         }
         else if (key == key_map_zoomout)  // zoom out
         {
-            mtof_zoommul = M_ZOOMOUT;
-            ftom_zoommul = M_ZOOMIN;
+            am_.mtof_zoommul = M_ZOOMOUT;
+            am_.ftom_zoommul = M_ZOOMIN;
         }
         else if (key == key_map_zoomin)   // zoom in
         {
-            mtof_zoommul = M_ZOOMIN;
-            ftom_zoommul = M_ZOOMOUT;
+            am_.mtof_zoommul = M_ZOOMIN;
+            am_.ftom_zoommul = M_ZOOMOUT;
         }
         else if (key == key_map_toggle)
         {
-            bigstate = 0;
+            amr_.bigstate = 0;
             viewactive = true;
             AM_Stop ();
         }
         else if (key == key_map_maxzoom)
         {
-            bigstate = !bigstate;
-            if (bigstate)
+            amr_.bigstate = !amr_.bigstate;
+            if (amr_.bigstate)
             {
                 AM_saveScaleAndLoc();
                 AM_minOutWindowScale();
@@ -665,42 +661,42 @@ AM_Responder
         }
         else if (key == key_map_follow)
         {
-            followplayer = !followplayer;
-            f_oldloc.x = INT_MAX;
-            if (followplayer)
-                plr->message = DEH_String(AMSTR_FOLLOWON);
+            am_.followplayer = !am_.followplayer;
+            am_.f_oldloc.x = INT_MAX;
+            if (am_.followplayer)
+                am_.plr->message = DEH_String(AMSTR_FOLLOWON);
             else
-                plr->message = DEH_String(AMSTR_FOLLOWOFF);
+                am_.plr->message = DEH_String(AMSTR_FOLLOWOFF);
         }
         else if (key == key_map_grid)
         {
-            grid = !grid;
-            if (grid)
-                plr->message = DEH_String(AMSTR_GRIDON);
+            am_.grid = !am_.grid;
+            if (am_.grid)
+                am_.plr->message = DEH_String(AMSTR_GRIDON);
             else
-                plr->message = DEH_String(AMSTR_GRIDOFF);
+                am_.plr->message = DEH_String(AMSTR_GRIDOFF);
         }
         else if (key == key_map_mark)
         {
-            M_snprintf(buffer, sizeof(buffer), "%s %d",
-                       DEH_String(AMSTR_MARKEDSPOT), markpointnum);
-            plr->message = buffer;
+            M_snprintf(amr_.buffer, sizeof(amr_.buffer), "%s %d",
+                       DEH_String(AMSTR_MARKEDSPOT), am_.markpointnum);
+            am_.plr->message = amr_.buffer;
             AM_addMark();
         }
         else if (key == key_map_clearmark)
         {
             AM_clearMarks();
-            plr->message = DEH_String(AMSTR_MARKSCLEARED);
+            am_.plr->message = DEH_String(AMSTR_MARKSCLEARED);
         }
         else
         {
             rc = false;
         }
 
-	if (!deathmatch && cht_CheckCheat(&cheat_amap, ev->data2))
+	if (!deathmatch && cht_CheckCheat((cheatseq_t *)&cheat_amap, ev->data2))
 	{
 	    rc = false;
-	    cheating = (cheating+1) % 3;
+	    am_.cheating = (am_.cheating+1) % 3;
 	}
     }
     else if (ev->type == ev_keyup)
@@ -710,24 +706,24 @@ AM_Responder
 
         if (key == key_map_east)
         {
-            if (!followplayer) m_paninc.x = 0;
+            if (!am_.followplayer) am_.m_paninc.x = 0;
         }
         else if (key == key_map_west)
         {
-            if (!followplayer) m_paninc.x = 0;
+            if (!am_.followplayer) am_.m_paninc.x = 0;
         }
         else if (key == key_map_north)
         {
-            if (!followplayer) m_paninc.y = 0;
+            if (!am_.followplayer) am_.m_paninc.y = 0;
         }
         else if (key == key_map_south)
         {
-            if (!followplayer) m_paninc.y = 0;
+            if (!am_.followplayer) am_.m_paninc.y = 0;
         }
         else if (key == key_map_zoomout || key == key_map_zoomin)
         {
-            mtof_zoommul = FRACUNIT;
-            ftom_zoommul = FRACUNIT;
+            am_.mtof_zoommul = FRACUNIT;
+            am_.ftom_zoommul = FRACUNIT;
         }
     }
 
@@ -743,12 +739,12 @@ void AM_changeWindowScale(void)
 {
 
     // Change the scaling multipliers
-    scale_mtof = FixedMul(scale_mtof, mtof_zoommul);
-    scale_ftom = FixedDiv(FRACUNIT, scale_mtof);
+    am_.scale_mtof = FixedMul(am_.scale_mtof, am_.mtof_zoommul);
+    am_.scale_ftom = FixedDiv(FRACUNIT, am_.scale_mtof);
 
-    if (scale_mtof < min_scale_mtof)
+    if (am_.scale_mtof < am_.min_scale_mtof)
 	AM_minOutWindowScale();
-    else if (scale_mtof > max_scale_mtof)
+    else if (am_.scale_mtof > am_.max_scale_mtof)
 	AM_maxOutWindowScale();
     else
 	AM_activateNewScale();
@@ -761,14 +757,14 @@ void AM_changeWindowScale(void)
 void AM_doFollowPlayer(void)
 {
 
-    if (f_oldloc.x != plr->mo->x || f_oldloc.y != plr->mo->y)
+    if (am_.f_oldloc.x != am_.plr->mo->x || am_.f_oldloc.y != am_.plr->mo->y)
     {
-	m_x = FTOM(MTOF(plr->mo->x)) - m_w/2;
-	m_y = FTOM(MTOF(plr->mo->y)) - m_h/2;
-	m_x2 = m_x + m_w;
-	m_y2 = m_y + m_h;
-	f_oldloc.x = plr->mo->x;
-	f_oldloc.y = plr->mo->y;
+	am_.m_x = FTOM(MTOF(am_.plr->mo->x)) - am_.m_w/2;
+	am_.m_y = FTOM(MTOF(am_.plr->mo->y)) - am_.m_h/2;
+	am_.m_x2 = am_.m_x + am_.m_w;
+	am_.m_y2 = am_.m_y + am_.m_h;
+	am_.f_oldloc.x = am_.plr->mo->x;
+	am_.f_oldloc.y = am_.plr->mo->y;
 
 	//  m_x = FTOM(MTOF(plr->mo->x - m_w/2));
 	//  m_y = FTOM(MTOF(plr->mo->y - m_h/2));
@@ -782,19 +778,20 @@ void AM_doFollowPlayer(void)
 //
 //
 //
+struct {
+    int nexttic;
+    int litelevelscnt;
+} amu_;
 void AM_updateLightLev(void)
 {
-    static int nexttic = 0;
-    //static int litelevels[] = { 0, 3, 5, 6, 6, 7, 7, 7 };
-    static int litelevels[] = { 0, 4, 7, 10, 12, 14, 15, 15 };
-    static int litelevelscnt = 0;
+    static const int litelevels[] = { 0, 4, 7, 10, 12, 14, 15, 15 };
    
     // Change light level
-    if (amclock>nexttic)
+    if (am_.amclock>amu_.nexttic)
     {
-	lightlev = litelevels[litelevelscnt++];
-	if (litelevelscnt == arrlen(litelevels)) litelevelscnt = 0;
-	nexttic = amclock + 6 - (amclock % 6);
+	am_.lightlev = litelevels[amu_.litelevelscnt++];
+	if (amu_.litelevelscnt == arrlen(litelevels)) amu_.litelevelscnt = 0;
+	amu_.nexttic = am_.amclock + 6 - (am_.amclock % 6);
     }
 
 }
@@ -809,17 +806,17 @@ void AM_Ticker (void)
     if (!automapactive)
 	return;
 
-    amclock++;
+    am_.amclock++;
 
-    if (followplayer)
+    if (am_.followplayer)
 	AM_doFollowPlayer();
 
     // Change the zoom if necessary
-    if (ftom_zoommul != FRACUNIT)
+    if (am_.ftom_zoommul != FRACUNIT)
 	AM_changeWindowScale();
 
     // Change x,y location
-    if (m_paninc.x || m_paninc.y)
+    if (am_.m_paninc.x || am_.m_paninc.y)
 	AM_changeWindowLoc();
 
     // Update light level
@@ -833,7 +830,7 @@ void AM_Ticker (void)
 //
 void AM_clearFB(int color)
 {
-    memset(fb, color, f_w*f_h);
+    memset(am_.fb, color, am_.f_w*am_.f_h);
 }
 
 
@@ -869,33 +866,33 @@ AM_clipMline
 #define DOOUTCODE(oc, mx, my) \
     (oc) = 0; \
     if ((my) < 0) (oc) |= TOP; \
-    else if ((my) >= f_h) (oc) |= BOTTOM; \
+    else if ((my) >= am_.f_h) (oc) |= BOTTOM; \
     if ((mx) < 0) (oc) |= LEFT; \
-    else if ((mx) >= f_w) (oc) |= RIGHT;
+    else if ((mx) >= am_.f_w) (oc) |= RIGHT;
 
     
     // do trivial rejects and outcodes
-    if (ml->a.y > m_y2)
+    if (ml->a.y > am_.m_y2)
 	outcode1 = TOP;
-    else if (ml->a.y < m_y)
+    else if (ml->a.y < am_.m_y)
 	outcode1 = BOTTOM;
 
-    if (ml->b.y > m_y2)
+    if (ml->b.y > am_.m_y2)
 	outcode2 = TOP;
-    else if (ml->b.y < m_y)
+    else if (ml->b.y < am_.m_y)
 	outcode2 = BOTTOM;
     
     if (outcode1 & outcode2)
 	return false; // trivially outside
 
-    if (ml->a.x < m_x)
+    if (ml->a.x < am_.m_x)
 	outcode1 |= LEFT;
-    else if (ml->a.x > m_x2)
+    else if (ml->a.x > am_.m_x2)
 	outcode1 |= RIGHT;
     
-    if (ml->b.x < m_x)
+    if (ml->b.x < am_.m_x)
 	outcode2 |= LEFT;
-    else if (ml->b.x > m_x2)
+    else if (ml->b.x > am_.m_x2)
 	outcode2 |= RIGHT;
     
     if (outcode1 & outcode2)
@@ -934,15 +931,15 @@ AM_clipMline
 	{
 	    dy = fl->a.y - fl->b.y;
 	    dx = fl->b.x - fl->a.x;
-	    tmp.x = fl->a.x + (dx*(fl->a.y-f_h))/dy;
-	    tmp.y = f_h-1;
+	    tmp.x = fl->a.x + (dx*(fl->a.y-am_.f_h))/dy;
+	    tmp.y = am_.f_h-1;
 	}
 	else if (outside & RIGHT)
 	{
 	    dy = fl->b.y - fl->a.y;
 	    dx = fl->b.x - fl->a.x;
-	    tmp.y = fl->a.y + (dy*(f_w-1 - fl->a.x))/dx;
-	    tmp.x = f_w-1;
+	    tmp.y = fl->a.y + (dy*(am_.f_w-1 - fl->a.x))/dx;
+	    tmp.x = am_.f_w-1;
 	}
 	else if (outside & LEFT)
 	{
@@ -995,19 +992,16 @@ AM_drawFline
     register int ay;
     register int d;
     
-    static int fuck = 0;
-
     // For debugging only
-    if (      fl->a.x < 0 || fl->a.x >= f_w
-	   || fl->a.y < 0 || fl->a.y >= f_h
-	   || fl->b.x < 0 || fl->b.x >= f_w
-	   || fl->b.y < 0 || fl->b.y >= f_h)
+    if (      fl->a.x < 0 || fl->a.x >= am_.f_w
+	   || fl->a.y < 0 || fl->a.y >= am_.f_h
+	   || fl->b.x < 0 || fl->b.x >= am_.f_w
+	   || fl->b.y < 0 || fl->b.y >= am_.f_h)
     {
-        DEH_fprintf(stderr, "fuck %d \r", fuck++);
 	return;
     }
 
-#define PUTDOT(xx,yy,cc) fb[(yy)*f_w+(xx)]=(cc)
+#define PUTDOT(xx,yy,cc) am_.fb[(yy)*am_.f_w+(xx)]=(cc)
 
     dx = fl->b.x - fl->a.x;
     ax = 2 * (dx<0 ? -dx : dx);
@@ -1063,7 +1057,7 @@ AM_drawMline
 ( mline_t*	ml,
   int		color )
 {
-    static fline_t fl;
+    fline_t fl;
 
     if (AM_clipMline(ml, &fl))
 	AM_drawFline(&fl, color); // draws it on frame buffer using fb coords
@@ -1081,15 +1075,15 @@ void AM_drawGrid(int color)
     mline_t ml;
 
     // Figure out start of vertical gridlines
-    start = m_x;
+    start = am_.m_x;
     if ((start-bmaporgx)%(MAPBLOCKUNITS<<FRACBITS))
 	start += (MAPBLOCKUNITS<<FRACBITS)
 	    - ((start-bmaporgx)%(MAPBLOCKUNITS<<FRACBITS));
-    end = m_x + m_w;
+    end = am_.m_x + am_.m_w;
 
     // draw vertical gridlines
-    ml.a.y = m_y;
-    ml.b.y = m_y+m_h;
+    ml.a.y = am_.m_y;
+    ml.b.y = am_.m_y+am_.m_h;
     for (x=start; x<end; x+=(MAPBLOCKUNITS<<FRACBITS))
     {
 	ml.a.x = x;
@@ -1098,15 +1092,15 @@ void AM_drawGrid(int color)
     }
 
     // Figure out start of horizontal gridlines
-    start = m_y;
+    start = am_.m_y;
     if ((start-bmaporgy)%(MAPBLOCKUNITS<<FRACBITS))
 	start += (MAPBLOCKUNITS<<FRACBITS)
 	    - ((start-bmaporgy)%(MAPBLOCKUNITS<<FRACBITS));
-    end = m_y + m_h;
+    end = am_.m_y + am_.m_h;
 
     // draw horizontal gridlines
-    ml.a.x = m_x;
-    ml.b.x = m_x + m_w;
+    ml.a.x = am_.m_x;
+    ml.b.x = am_.m_x + am_.m_w;
     for (y=start; y<end; y+=(MAPBLOCKUNITS<<FRACBITS))
     {
 	ml.a.y = y;
@@ -1123,7 +1117,7 @@ void AM_drawGrid(int color)
 void AM_drawWalls(void)
 {
     int i;
-    static mline_t l;
+    mline_t l;
 
     for (i=0;i<numlines;i++)
     {
@@ -1131,13 +1125,13 @@ void AM_drawWalls(void)
 	l.a.y = lines[i].v1->y;
 	l.b.x = lines[i].v2->x;
 	l.b.y = lines[i].v2->y;
-	if (cheating || (lines[i].flags & ML_MAPPED))
+	if (am_.cheating || (lines[i].flags & ML_MAPPED))
 	{
-	    if ((lines[i].flags & LINE_NEVERSEE) && !cheating)
+	    if ((lines[i].flags & LINE_NEVERSEE) && !am_.cheating)
 		continue;
 	    if (!lines[i].backsector)
 	    {
-		AM_drawMline(&l, WALLCOLORS+lightlev);
+		AM_drawMline(&l, WALLCOLORS+am_.lightlev);
 	    }
 	    else
 	    {
@@ -1147,23 +1141,23 @@ void AM_drawWalls(void)
 		}
 		else if (lines[i].flags & ML_SECRET) // secret door
 		{
-		    if (cheating) AM_drawMline(&l, SECRETWALLCOLORS + lightlev);
-		    else AM_drawMline(&l, WALLCOLORS+lightlev);
+		    if (am_.cheating) AM_drawMline(&l, SECRETWALLCOLORS + am_.lightlev);
+		    else AM_drawMline(&l, WALLCOLORS+am_.lightlev);
 		}
 		else if (lines[i].backsector->floorheight
 			   != lines[i].frontsector->floorheight) {
-		    AM_drawMline(&l, FDWALLCOLORS + lightlev); // floor level change
+		    AM_drawMline(&l, FDWALLCOLORS + am_.lightlev); // floor level change
 		}
 		else if (lines[i].backsector->ceilingheight
 			   != lines[i].frontsector->ceilingheight) {
-		    AM_drawMline(&l, CDWALLCOLORS+lightlev); // ceiling level change
+		    AM_drawMline(&l, CDWALLCOLORS+am_.lightlev); // ceiling level change
 		}
-		else if (cheating) {
-		    AM_drawMline(&l, TSWALLCOLORS+lightlev);
+		else if (am_.cheating) {
+		    AM_drawMline(&l, TSWALLCOLORS+am_.lightlev);
 		}
 	    }
 	}
-	else if (plr->powers[pw_allmap])
+	else if (am_.plr->powers[pw_allmap])
 	{
 	    if (!(lines[i].flags & LINE_NEVERSEE)) AM_drawMline(&l, GRAYS+3);
 	}
@@ -1245,22 +1239,22 @@ AM_drawLineCharacter
 
 void AM_drawPlayers(void)
 {
+    static const int 	their_colors[] = { GREENS, GRAYS, BROWNS, REDS };
     int		i;
     player_t*	p;
-    static int 	their_colors[] = { GREENS, GRAYS, BROWNS, REDS };
     int		their_color = -1;
     int		color;
 
     if (!netgame)
     {
-	if (cheating)
+	if (am_.cheating)
 	    AM_drawLineCharacter
-		(cheat_player_arrow, arrlen(cheat_player_arrow), 0,
-		 plr->mo->angle, WHITE, plr->mo->x, plr->mo->y);
+		((mline_t *)cheat_player_arrow, arrlen(cheat_player_arrow), 0,
+		 am_.plr->mo->angle, WHITE, am_.plr->mo->x, am_.plr->mo->y);
 	else
 	    AM_drawLineCharacter
-		(player_arrow, arrlen(player_arrow), 0, plr->mo->angle,
-		 WHITE, plr->mo->x, plr->mo->y);
+		((mline_t *)player_arrow, arrlen(player_arrow), 0, am_.plr->mo->angle,
+		 WHITE, am_.plr->mo->x, am_.plr->mo->y);
 	return;
     }
 
@@ -1269,7 +1263,7 @@ void AM_drawPlayers(void)
 	their_color++;
 	p = &players[i];
 
-	if ( (deathmatch && !singledemo) && p != plr)
+	if ( (deathmatch && !singledemo) && p != am_.plr)
 	    continue;
 
 	if (!playeringame[i])
@@ -1281,7 +1275,7 @@ void AM_drawPlayers(void)
 	    color = their_colors[their_color];
 	
 	AM_drawLineCharacter
-	    (player_arrow, arrlen(player_arrow), 0, p->mo->angle,
+	    ((mline_t *)player_arrow, arrlen(player_arrow), 0, p->mo->angle,
 	     color, p->mo->x, p->mo->y);
     }
 
@@ -1301,8 +1295,8 @@ AM_drawThings
 	while (t)
 	{
 	    AM_drawLineCharacter
-		(thintriangle_guy, arrlen(thintriangle_guy),
-		 16<<FRACBITS, t->angle, colors+lightlev, t->x, t->y);
+		((mline_t *)thintriangle_guy, arrlen(thintriangle_guy),
+		 16<<FRACBITS, t->angle, colors+am_.lightlev, t->x, t->y);
 	    t = t->snext;
 	}
     }
@@ -1314,16 +1308,16 @@ void AM_drawMarks(void)
 
     for (i=0;i<AM_NUMMARKPOINTS;i++)
     {
-	if (markpoints[i].x != -1)
+	if (am_.markpoints[i].x != -1)
 	{
 	    //      w = SHORT(marknums[i]->width);
 	    //      h = SHORT(marknums[i]->height);
 	    w = 5; // because something's wrong with the wad, i guess
 	    h = 6; // because something's wrong with the wad, i guess
-	    fx = CXMTOF(markpoints[i].x);
-	    fy = CYMTOF(markpoints[i].y);
-	    if (fx >= f_x && fx <= f_w - w && fy >= f_y && fy <= f_h - h)
-		V_DrawPatch(fx, fy, marknums[i]);
+	    fx = CXMTOF(am_.markpoints[i].x);
+	    fy = CYMTOF(am_.markpoints[i].y);
+	    if (fx >= am_.f_x && fx <= am_.f_w - w && fy >= am_.f_y && fy <= am_.f_h - h)
+		V_DrawPatch(fx, fy, am_.marknums[i]);
 	}
     }
 
@@ -1331,7 +1325,7 @@ void AM_drawMarks(void)
 
 void AM_drawCrosshair(int color)
 {
-    fb[(f_w*(f_h+1))/2] = color; // single point for now
+    am_.fb[(am_.f_w*(am_.f_h+1))/2] = color; // single point for now
 
 }
 
@@ -1340,16 +1334,16 @@ void AM_Drawer (void)
     if (!automapactive) return;
 
     AM_clearFB(BACKGROUND);
-    if (grid)
+    if (am_.grid)
 	AM_drawGrid(GRIDCOLORS);
     AM_drawWalls();
     AM_drawPlayers();
-    if (cheating==2)
+    if (am_.cheating==2)
 	AM_drawThings(THINGCOLORS, THINGRANGE);
     AM_drawCrosshair(XHAIRCOLORS);
 
     AM_drawMarks();
 
-    V_MarkRect(f_x, f_y, f_w, f_h);
+    V_MarkRect(am_.f_x, am_.f_y, am_.f_w, am_.f_h);
 
 }
diff --git a/doomgeneric/am_map.h b/doomgeneric/am_map.h
index 572d238..4063a01 100644
--- a/doomgeneric/am_map.h
+++ b/doomgeneric/am_map.h
@@ -43,7 +43,4 @@ void AM_Drawer (void);
 void AM_Stop (void);
 
 
-extern cheatseq_t cheat_amap;
-
-
 #endif
diff --git a/doomgeneric/d_event.c b/doomgeneric/d_event.c
index 3eef572..070d1b9 100644
--- a/doomgeneric/d_event.c
+++ b/doomgeneric/d_event.c
@@ -24,9 +24,11 @@
 
 #define MAXEVENTS 64
 
-static event_t events[MAXEVENTS];
-static int eventhead;
-static int eventtail;
+struct {
+    event_t events[MAXEVENTS];
+    int eventhead;
+    int eventtail;
+} de_;
 
 //
 // D_PostEvent
@@ -34,8 +36,8 @@ static int eventtail;
 //
 void D_PostEvent (event_t* ev)
 {
-    events[eventhead] = *ev;
-    eventhead = (eventhead + 1) % MAXEVENTS;
+    de_.events[de_.eventhead] = *ev;
+    de_.eventhead = (de_.eventhead + 1) % MAXEVENTS;
 }
 
 // Read an event from the queue.
@@ -46,16 +48,16 @@ event_t *D_PopEvent(void)
 
     // No more events waiting.
 
-    if (eventtail == eventhead)
+    if (de_.eventtail == de_.eventhead)
     {
         return NULL;
     }
     
-    result = &events[eventtail];
+    result = &de_.events[de_.eventtail];
 
     // Advance to the next event in the queue.
 
-    eventtail = (eventtail + 1) % MAXEVENTS;
+    de_.eventtail = (de_.eventtail + 1) % MAXEVENTS;
 
     return result;
 }
diff --git a/doomgeneric/d_items.c b/doomgeneric/d_items.c
index 33f310c..65c0c55 100644
--- a/doomgeneric/d_items.c
+++ b/doomgeneric/d_items.c
@@ -34,7 +34,7 @@
 // atkstate, i.e. attack/fire/hit frame
 // flashstate, muzzle flash
 //
-weaponinfo_t	weaponinfo[NUMWEAPONS] =
+const weaponinfo_t	weaponinfo[NUMWEAPONS] =
 {
     {
 	// fist
diff --git a/doomgeneric/d_items.h b/doomgeneric/d_items.h
index 3d22a06..b60caf6 100644
--- a/doomgeneric/d_items.h
+++ b/doomgeneric/d_items.h
@@ -36,6 +36,6 @@ typedef struct
 
 } weaponinfo_t;
 
-extern  weaponinfo_t    weaponinfo[NUMWEAPONS];
+extern  const weaponinfo_t    weaponinfo[NUMWEAPONS];
 
 #endif
diff --git a/doomgeneric/d_iwad.c b/doomgeneric/d_iwad.c
index 9da6337..04c233b 100644
--- a/doomgeneric/d_iwad.c
+++ b/doomgeneric/d_iwad.c
@@ -57,16 +57,18 @@ static const iwad_t iwads[] =
 
 #define MAX_IWAD_DIRS 128
 
-static boolean iwad_dirs_built = false;
-static char *iwad_dirs[MAX_IWAD_DIRS];
-static int num_iwad_dirs = 0;
+struct {
+    boolean iwad_dirs_built;
+    char *iwad_dirs[MAX_IWAD_DIRS];
+    int num_iwad_dirs;
+} di_;
 
 static void AddIWADDir(char *dir)
 {
-    if (num_iwad_dirs < MAX_IWAD_DIRS)
+    if (di_.num_iwad_dirs < MAX_IWAD_DIRS)
     {
-        iwad_dirs[num_iwad_dirs] = dir;
-        ++num_iwad_dirs;
+        di_.iwad_dirs[di_.num_iwad_dirs] = dir;
+        ++di_.num_iwad_dirs;
     }
 }
 
@@ -617,7 +619,7 @@ static void BuildIWADDirList(void)
 
     // Don't run this function again.
 
-    iwad_dirs_built = true;
+    di_.iwad_dirs_built = true;
 #endif
 }
 
@@ -641,20 +643,20 @@ char *D_FindWADByName(char *name)
 
     // Search through all IWAD paths for a file with the given name.
 
-    for (i=0; i<num_iwad_dirs; ++i)
+    for (i=0; i<di_.num_iwad_dirs; ++i)
     {
         // As a special case, if this is in DOOMWADDIR or DOOMWADPATH,
         // the "directory" may actually refer directly to an IWAD
         // file.
 
-        if (DirIsFile(iwad_dirs[i], name) && M_FileExists(iwad_dirs[i]))
+        if (DirIsFile(di_.iwad_dirs[i], name) && M_FileExists(di_.iwad_dirs[i]))
         {
-            return strdup(iwad_dirs[i]);
+            return strdup(di_.iwad_dirs[i]);
         }
 
         // Construct a string for the full path
 
-        path = M_StringJoin(iwad_dirs[i], DIR_SEPARATOR_S, name, NULL);
+        path = M_StringJoin(di_.iwad_dirs[i], DIR_SEPARATOR_S, name, NULL);
 
         if (M_FileExists(path))
         {
@@ -741,9 +743,9 @@ char *D_FindIWAD(int mask, GameMission_t *mission)
 
         BuildIWADDirList();
     
-        for (i=0; result == NULL && i<num_iwad_dirs; ++i)
+        for (i=0; result == NULL && i<di_.num_iwad_dirs; ++i)
         {
-            result = SearchDirectoryForIWAD(iwad_dirs[i], mask, mission);
+            result = SearchDirectoryForIWAD(di_.iwad_dirs[i], mask, mission);
         }
     }
 
diff --git a/doomgeneric/d_loop.c b/doomgeneric/d_loop.c
index 1939dbd..0524fda 100644
--- a/doomgeneric/d_loop.c
+++ b/doomgeneric/d_loop.c
@@ -40,6 +40,20 @@
 #include "net_sdl.h"
 #include "net_loop.h"
 
+// When set to true, a single tic is run each time TryRunTics() is called.
+// This is used for -timedemo mode.
+
+boolean singletics;
+
+// Reduce the bandwidth needed by sampling game input less and transmitting
+// less.  If ticdup is 2, sample half normal, 3 = one third normal, etc.
+
+int		ticdup;
+
+// The number of tics that have been run (using RunTic) so far.
+
+int gametic;
+
 // The complete set of data for a particular tic.
 
 typedef struct
@@ -48,8 +62,9 @@ typedef struct
     boolean ingame[NET_MAXPLAYERS];
 } ticcmd_set_t;
 
+struct {
 //
-// gametic is the tic about to (or currently being) run
+// gametic (above) is the tic about to (or currently being) run
 // maketic is the tic that hasn't had control made for it yet
 // recvtic is the latest tic received from the server.
 //
@@ -57,62 +72,48 @@ typedef struct
 // from all players.
 //
 
-static ticcmd_set_t ticdata[BACKUPTICS];
+    ticcmd_set_t ticdata[BACKUPTICS];
 
 // The index of the next tic to be made (with a call to BuildTiccmd).
 
-static int maketic;
+    int maketic;
 
 // The number of complete tics received from the server so far.
 
-static int recvtic;
-
-// The number of tics that have been run (using RunTic) so far.
-
-int gametic;
-
-// When set to true, a single tic is run each time TryRunTics() is called.
-// This is used for -timedemo mode.
-
-boolean singletics = false;
+    int recvtic;
 
 // Index of the local player.
 
-static int localplayer;
+    int localplayer;
 
 // Used for original sync code.
 
-static int      skiptics = 0;
-
-// Reduce the bandwidth needed by sampling game input less and transmitting
-// less.  If ticdup is 2, sample half normal, 3 = one third normal, etc.
-
-int		ticdup;
+    int      skiptics;
 
 // Amount to offset the timer for game sync.
 
-fixed_t         offsetms;
+    fixed_t         offsetms;
 
 // Use new client syncronisation code
 
-static boolean  new_sync = true;
+    boolean  new_sync;
 
 // Callback functions for loop code.
 
-static loop_interface_t *loop_interface = NULL;
+    loop_interface_t *loop_interface;
 
 // Current players in the multiplayer game.
 // This is distinct from playeringame[] used by the game code, which may
 // modify playeringame[] when playing back multiplayer demos.
 
-static boolean local_playeringame[NET_MAXPLAYERS];
+    boolean local_playeringame[NET_MAXPLAYERS];
 
 // Requested player class "sent" to the server on connect.
 // If we are only doing a single player game then this needs to be remembered
 // and saved in the game settings.
 
-static int player_class;
-
+    int player_class;
+} dl_;
 
 // 35 fps clock adjusted by offsetms milliseconds
 
@@ -122,12 +123,12 @@ static int GetAdjustedTime(void)
 
     time_ms = I_GetTimeMS();
 
-    if (new_sync)
+    if (dl_.new_sync)
     {
 	// Use the adjustments from net_client.c only if we are
 	// using the new sync mode.
 
-        time_ms += (offsetms / FRACUNIT);
+        time_ms += (dl_.offsetms / FRACUNIT);
     }
 
     return (time_ms * TICRATE) / 1000;
@@ -141,11 +142,11 @@ static boolean BuildNewTic(void)
     gameticdiv = gametic/ticdup;
 
     I_StartTic ();
-    loop_interface->ProcessEvents();
+    dl_.loop_interface->ProcessEvents();
 
     // Always run the menu
 
-    loop_interface->RunMenu();
+    dl_.loop_interface->RunMenu();
 
     if (drone)
     {
@@ -154,28 +155,28 @@ static boolean BuildNewTic(void)
         return false;
     }
 
-    if (new_sync)
+    if (dl_.new_sync)
     {
        // If playing single player, do not allow tics to buffer
        // up very far
 
-       if (!net_client_connected && maketic - gameticdiv > 2)
+       if (!net_client_connected && dl_.maketic - gameticdiv > 2)
            return false;
 
        // Never go more than ~200ms ahead
 
-       if (maketic - gameticdiv > 8)
+       if (dl_.maketic - gameticdiv > 8)
            return false;
     }
     else
     {
-       if (maketic - gameticdiv >= 5)
+       if (dl_.maketic - gameticdiv >= 5)
            return false;
     }
 
     //printf ("mk:%i ",maketic);
     memset(&cmd, 0, sizeof(ticcmd_t));
-    loop_interface->BuildTiccmd(&cmd, maketic);
+    dl_.loop_interface->BuildTiccmd(&cmd, dl_.maketic);
 
 #ifdef FEATURE_MULTIPLAYER
 
@@ -185,10 +186,10 @@ static boolean BuildNewTic(void)
     }
 
 #endif
-    ticdata[maketic % BACKUPTICS].cmds[localplayer] = cmd;
-    ticdata[maketic % BACKUPTICS].ingame[localplayer] = true;
+    dl_.ticdata[dl_.maketic % BACKUPTICS].cmds[dl_.localplayer] = cmd;
+    dl_.ticdata[dl_.maketic % BACKUPTICS].ingame[dl_.localplayer] = true;
 
-    ++maketic;
+    ++dl_.maketic;
 
     return true;
 }
@@ -227,14 +228,14 @@ void NetUpdate (void)
 
     lasttime = nowtime;
 
-    if (skiptics <= newtics)
+    if (dl_.skiptics <= newtics)
     {
-        newtics -= skiptics;
-        skiptics = 0;
+        newtics -= dl_.skiptics;
+        dl_.skiptics = 0;
     }
     else
     {
-        skiptics -= newtics;
+        dl_.skiptics -= newtics;
         newtics = 0;
     }
 
@@ -282,18 +283,18 @@ void D_ReceiveTic(ticcmd_t *ticcmds, boolean *players_mask)
 
     for (i = 0; i < NET_MAXPLAYERS; ++i)
     {
-        if (!drone && i == localplayer)
+        if (!drone && i == dl_.localplayer)
         {
             // This is us.  Don't overwrite it.
         }
         else
         {
-            ticdata[recvtic % BACKUPTICS].cmds[i] = ticcmds[i];
-            ticdata[recvtic % BACKUPTICS].ingame[i] = players_mask[i];
+            dl_.ticdata[dl_.recvtic % BACKUPTICS].cmds[i] = ticcmds[i];
+            dl_.ticdata[dl_.recvtic % BACKUPTICS].ingame[i] = players_mask[i];
         }
     }
 
-    ++recvtic;
+    ++dl_.recvtic;
 }
 
 //
@@ -439,13 +440,13 @@ void D_StartNetGame(net_gamesettings_t *settings,
 #else
     settings->consoleplayer = 0;
 	settings->num_players = 1;
-	settings->player_classes[0] = player_class;
+	settings->player_classes[0] = dl_.player_class;
 	settings->new_sync = 0;
 	settings->extratics = 1;
 	settings->ticdup = 1;
 
 	ticdup = settings->ticdup;
-	new_sync = settings->new_sync;
+	dl_.new_sync = settings->new_sync;
 #endif
 }
 
@@ -461,7 +462,7 @@ boolean D_InitNetGame(net_connect_data_t *connect_data)
 
     I_AtExit(D_QuitNetGame, true);
 
-    player_class = connect_data->player_class;
+    dl_.player_class = connect_data->player_class;
 
 #ifdef FEATURE_MULTIPLAYER
 
@@ -569,7 +570,7 @@ static int GetLowTic(void)
 {
     int lowtic;
 
-    lowtic = maketic;
+    lowtic = dl_.maketic;
 
 #ifdef FEATURE_MULTIPLAYER
     if (net_client_connected)
@@ -584,23 +585,24 @@ static int GetLowTic(void)
     return lowtic;
 }
 
-static int frameon;
-static int frameskip[4];
-static int oldnettics;
-
+struct {
+    int frameon;
+    int frameskip[4];
+    int oldnettics;
+} dlo_;
 static void OldNetSync(void)
 {
     unsigned int i;
     int keyplayer = -1;
 
-    frameon++;
+    dlo_.frameon++;
 
     // ideally maketic should be 1 - 3 tics above lowtic
     // if we are consistantly slower, speed up time
 
     for (i=0 ; i<NET_MAXPLAYERS ; i++)
     {
-        if (local_playeringame[i])
+        if (dl_.local_playeringame[i])
         {
             keyplayer = i;
             break;
@@ -614,24 +616,24 @@ static void OldNetSync(void)
         return;
     }
 
-    if (localplayer == keyplayer)
+    if (dl_.localplayer == keyplayer)
     {
         // the key player does not adapt
     }
     else
     {
-        if (maketic <= recvtic)
+        if (dl_.maketic <= dl_.recvtic)
         {
             lasttime--;
             // printf ("-");
         }
 
-        frameskip[frameon & 3] = oldnettics > recvtic;
-        oldnettics = maketic;
+        dlo_.frameskip[dlo_.frameon & 3] = dlo_.oldnettics > dl_.recvtic;
+        dlo_.oldnettics = dl_.maketic;
 
-        if (frameskip[0] && frameskip[1] && frameskip[2] && frameskip[3])
+        if (dlo_.frameskip[0] && dlo_.frameskip[1] && dlo_.frameskip[2] && dlo_.frameskip[3])
         {
-            skiptics = 1;
+            dl_.skiptics = 1;
             // printf ("+");
         }
     }
@@ -651,7 +653,7 @@ static boolean PlayersInGame(void)
     {
         for (i = 0; i < NET_MAXPLAYERS; ++i)
         {
-            result = result || local_playeringame[i];
+            result = result || dl_.local_playeringame[i];
         }
     }
 
@@ -692,7 +694,7 @@ static void SinglePlayerClear(ticcmd_set_t *set)
 
     for (i = 0; i < NET_MAXPLAYERS; ++i)
     {
-        if (i != localplayer)
+        if (i != dl_.localplayer)
         {
             set->ingame[i] = false;
         }
@@ -702,21 +704,22 @@ static void SinglePlayerClear(ticcmd_set_t *set)
 //
 // TryRunTics
 //
-
+struct {
+    int oldentertics;
+} dlt_;
 void TryRunTics (void)
 {
     int	i;
     int	lowtic;
     int	entertic;
-    static int oldentertics;
     int realtics;
     int	availabletics;
     int	counts;
 
     // get real tics
     entertic = I_GetTime() / ticdup;
-    realtics = entertic - oldentertics;
-    oldentertics = entertic;
+    realtics = entertic - dlt_.oldentertics;
+    dlt_.oldentertics = entertic;
 
     // in singletics mode, run a single tic every time this function
     // is called.
@@ -736,7 +739,7 @@ void TryRunTics (void)
 
     // decide how many tics to run
 
-    if (new_sync)
+    if (dl_.new_sync)
     {
 	counts = availabletics;
     }
@@ -794,7 +797,7 @@ void TryRunTics (void)
             return;
         }
 
-        set = &ticdata[(gametic / ticdup) % BACKUPTICS];
+        set = &dl_.ticdata[(gametic / ticdup) % BACKUPTICS];
 
         if (!net_client_connected)
         {
@@ -806,9 +809,9 @@ void TryRunTics (void)
             if (gametic/ticdup > lowtic)
                 I_Error ("gametic>lowtic");
 
-            memcpy(local_playeringame, set->ingame, sizeof(local_playeringame));
+            memcpy(dl_.local_playeringame, set->ingame, sizeof(dl_.local_playeringame));
 
-            loop_interface->RunTic(set->cmds, set->ingame);
+            dl_.loop_interface->RunTic(set->cmds, set->ingame);
 	    gametic++;
 
 	    // modify command for duplicated tics
@@ -822,5 +825,5 @@ void TryRunTics (void)
 
 void D_RegisterLoopCallbacks(loop_interface_t *i)
 {
-    loop_interface = i;
+    dl_.loop_interface = i;
 }
diff --git a/doomgeneric/d_main.c b/doomgeneric/d_main.c
index c7cf977..49e6f5a 100644
--- a/doomgeneric/d_main.c
+++ b/doomgeneric/d_main.c
@@ -120,12 +120,12 @@ boolean         storedemo;
 boolean         bfgedition;
 
 // If true, the main game loop has started.
-boolean         main_loop_started = false;
+boolean         main_loop_started;
 
 char		wadfile[1024];		// primary wad file
 char		mapdir[1024];           // directory of development maps
 
-int             show_endoom = 1;
+int             show_endoom;
 
 
 void D_ConnectNetGame(void);
@@ -161,19 +161,25 @@ void D_ProcessEvents (void)
 //
 
 // wipegamestate can be set to -1 to force a wipe on the next draw
-gamestate_t     wipegamestate = GS_DEMOSCREEN;
+gamestate_t     wipegamestate;
 extern  boolean setsizeneeded;
 extern  int             showMessages;
 void R_ExecuteSetViewSize (void);
 
+// previously static locals, now globals for uPython compat.
+// namespaced to avoid collisions.
+struct {
+    boolean		hasrun;
+    boolean		viewactivestate;
+    boolean		menuactivestate;
+    boolean		inhelpscreensstate;
+    boolean		fullscreen;
+    gamestate_t		oldgamestate;
+    int			borderdrawcount;
+} dm_;
+
 void D_Display (void)
 {
-    static  boolean		viewactivestate = false;
-    static  boolean		menuactivestate = false;
-    static  boolean		inhelpscreensstate = false;
-    static  boolean		fullscreen = false;
-    static  gamestate_t		oldgamestate = -1;
-    static  int			borderdrawcount;
     int				nowtime;
     int				tics;
     int				wipestart;
@@ -182,6 +188,14 @@ void D_Display (void)
     boolean			wipe;
     boolean			redrawsbar;
 
+	if (!dm_.hasrun) {
+		dm_.hasrun = true;
+		dm_.viewactivestate = false;
+		dm_.menuactivestate = false;
+		dm_.inhelpscreensstate = false;
+		dm_.oldgamestate = -1;
+		dm_.fullscreen = false;
+	}
     if (nodrawers)
     	return;                    // for comparative timing / profiling
 		
@@ -191,8 +205,8 @@ void D_Display (void)
     if (setsizeneeded)
     {
 		R_ExecuteSetViewSize ();
-		oldgamestate = -1;                      // force background redraw
-		borderdrawcount = 3;
+		dm_.oldgamestate = -1;                      // force background redraw
+		dm_.borderdrawcount = 3;
     }
 
     // save the current screen if about to wipe
@@ -215,12 +229,12 @@ void D_Display (void)
 			break;
 		if (automapactive)
 			AM_Drawer ();
-		if (wipe || (viewheight != 200 && fullscreen) )
+		if (wipe || (viewheight != 200 && dm_.fullscreen) )
 			redrawsbar = true;
-		if (inhelpscreensstate && !inhelpscreens)
+		if (dm_.inhelpscreensstate && !inhelpscreens)
 			redrawsbar = true;              // just put away the help screen
 		ST_Drawer (viewheight == 200, redrawsbar );
-		fullscreen = viewheight == 200;
+		dm_.fullscreen = viewheight == 200;
 		break;
 
       case GS_INTERMISSION:
@@ -247,25 +261,25 @@ void D_Display (void)
     	HU_Drawer ();
     
     // clean up border stuff
-    if (gamestate != oldgamestate && gamestate != GS_LEVEL)
+    if (gamestate != dm_.oldgamestate && gamestate != GS_LEVEL)
     	I_SetPalette (W_CacheLumpName (DEH_String("PLAYPAL"),PU_CACHE));
 
     // see if the border needs to be initially drawn
-    if (gamestate == GS_LEVEL && oldgamestate != GS_LEVEL)
+    if (gamestate == GS_LEVEL && dm_.oldgamestate != GS_LEVEL)
     {
-		viewactivestate = false;        // view was not active
+		dm_.viewactivestate = false;        // view was not active
 		R_FillBackScreen ();    // draw the pattern into the back screen
     }
 
     // see if the border needs to be updated to the screen
     if (gamestate == GS_LEVEL && !automapactive && scaledviewwidth != 320)
     {
-		if (menuactive || menuactivestate || !viewactivestate)
-			borderdrawcount = 3;
-		if (borderdrawcount)
+		if (menuactive || dm_.menuactivestate || !dm_.viewactivestate)
+			dm_.borderdrawcount = 3;
+		if (dm_.borderdrawcount)
 		{
 			R_DrawViewBorder ();    // erase old menu stuff
-			borderdrawcount--;
+			dm_.borderdrawcount--;
 		}
     }
 
@@ -276,10 +290,10 @@ void D_Display (void)
         V_DrawMouseSpeedBox(testcontrols_mousespeed);
     }
 
-    menuactivestate = menuactive;
-    viewactivestate = viewactive;
-    inhelpscreensstate = inhelpscreens;
-    oldgamestate = wipegamestate = gamestate;
+    dm_.menuactivestate = menuactive;
+    dm_.viewactivestate = viewactive;
+    dm_.inhelpscreensstate = inhelpscreens;
+    dm_.oldgamestate = wipegamestate = gamestate;
     
     // draw pause pic
     if (paused)
@@ -364,8 +378,8 @@ void D_BindVariables(void)
     M_BindVariable("screenblocks",           &screenblocks);
     M_BindVariable("detaillevel",            &detailLevel);
     M_BindVariable("snd_channels",           &snd_channels);
-    M_BindVariable("vanilla_savegame_limit", &vanilla_savegame_limit);
-    M_BindVariable("vanilla_demo_limit",     &vanilla_demo_limit);
+//TODO:PAA    M_BindVariable("vanilla_savegame_limit", &vanilla_savegame_limit);
+//TODO:PAA    M_BindVariable("vanilla_demo_limit",     &vanilla_demo_limit);
     M_BindVariable("show_endoom",            &show_endoom);
 
     // Multiplayer chat macros
@@ -375,7 +389,7 @@ void D_BindVariables(void)
         char buf[12];
 
         M_snprintf(buf, sizeof(buf), "chatmacro%i", i);
-        M_BindVariable(buf, &chat_macros[i]);
+//TODO:PAA        M_BindVariable(buf, &chat_macros[i]);
     }
 }
 
@@ -601,7 +615,7 @@ void D_StartTitle (void)
 // These are from the original source: some of them are perhaps
 // not used in any dehacked patches
 
-static char *banners[] =
+static const char * const banners[] =
 {
     // doom2.wad
     "                         "
@@ -647,7 +661,7 @@ static char *GetGameName(char *gamename)
     {
         // Has the banner been replaced?
 
-        deh_sub = DEH_String(banners[i]);
+        deh_sub = DEH_String((char *)banners[i]);
         
         if (deh_sub != banners[i])
         {
@@ -686,7 +700,7 @@ static void SetMissionForPackName(char *pack_name)
     int i;
     static const struct
     {
-        char *name;
+        const char *name;
         int mission;
     } packs[] = {
         { "doom2",    doom2 },
@@ -877,7 +891,7 @@ static boolean D_AddFile(char *filename)
 // Some dehacked mods replace these.  These are only displayed if they are 
 // replaced by dehacked.
 
-static char *copyright_banners[] =
+static const char * const copyright_banners[] =
 {
     "===========================================================================\n"
     "ATTENTION:  This version of DOOM has been modified.  If you would like to\n"
@@ -906,7 +920,7 @@ void PrintDehackedBanners(void)
     {
         char *deh_s;
 
-        deh_s = DEH_String(copyright_banners[i]);
+        deh_s = DEH_String((char *)copyright_banners[i]);
 
         if (deh_s != copyright_banners[i])
         {
@@ -923,11 +937,11 @@ void PrintDehackedBanners(void)
     }
 }
 
-static struct 
+static const struct 
 {
-    char *description;
-    char *cmdline;
-    GameVersion_t version;
+    const char *description;
+    const char *cmdline;
+    const GameVersion_t version;
 } gameversions[] = {
     {"Doom 1.666",           "1.666",      exe_doom_1_666},
     {"Doom 1.7/1.7a",        "1.7",        exe_doom_1_7},
@@ -1167,6 +1181,7 @@ void D_DoomMain (void)
     int numiwadlumps;
 #endif
 
+    D_initDoomstate();
     I_AtExit(D_Endoom, false);
 
     // print banner
@@ -1353,6 +1368,7 @@ void D_DoomMain (void)
 
     // Load configuration files before initialising other subsystems.
     DEH_printf("M_LoadDefaults: Load system defaults.\n");
+    M_InitConfig();
     M_SetConfigFilenames("default.cfg", PROGRAM_PREFIX "doom.cfg");
     D_BindVariables();
     M_LoadDefaults();
@@ -1778,6 +1794,9 @@ void D_DoomMain (void)
     DEH_printf("ST_Init: Init status bar.\n");
     ST_Init ();
 
+    DEH_printf("G_Init: Init game logic.\n");
+    G_Init ();
+
     // If Doom II without a MAP01 lump, this is a store demo.
     // Moved this here so that MAP01 isn't constantly looked up
     // in the main loop.
diff --git a/doomgeneric/d_mode.c b/doomgeneric/d_mode.c
index afd84ac..59b7f5d 100644
--- a/doomgeneric/d_mode.c
+++ b/doomgeneric/d_mode.c
@@ -29,7 +29,7 @@ static struct
     GameMode_t mode;
     int episode;
     int map;
-} valid_modes[] = {
+} const valid_modes[] = {
     { pack_chex, shareware,  1, 5 },
     { doom,      shareware,  1, 9 },
     { doom,      registered, 3, 9 },
@@ -119,7 +119,7 @@ int D_GetNumEpisodes(GameMission_t mission, GameMode_t mode)
 static struct {
     GameMission_t mission;
     GameVersion_t version;
-} valid_versions[] = {
+} const valid_versions[] = {
     { doom,     exe_doom_1_9 },
     { doom,     exe_hacx },
     { doom,     exe_ultimate },
diff --git a/doomgeneric/d_net.c b/doomgeneric/d_net.c
index b8962cc..54482f3 100644
--- a/doomgeneric/d_net.c
+++ b/doomgeneric/d_net.c
@@ -41,10 +41,9 @@
 ticcmd_t *netcmds;
 
 // Called when a player leaves the game
-
+char dn_exitmsg[80];
 static void PlayerQuitGame(player_t *player)
 {
-    static char exitmsg[80];
     unsigned int player_num;
 
     player_num = player - players;
@@ -52,13 +51,13 @@ static void PlayerQuitGame(player_t *player)
     // Do this the same way as Vanilla Doom does, to allow dehacked
     // replacements of this message
 
-    M_StringCopy(exitmsg, DEH_String("Player 1 left the game"),
-                 sizeof(exitmsg));
+    M_StringCopy(dn_exitmsg, DEH_String("Player 1 left the game"),
+                 sizeof(dn_exitmsg));
 
-    exitmsg[7] += player_num;
+    dn_exitmsg[7] += player_num;
 
     playeringame[player_num] = false;
-    players[consoleplayer].message = exitmsg;
+    players[consoleplayer].message = dn_exitmsg;
 
     // TODO: check if it is sensible to do this:
 
@@ -94,7 +93,7 @@ static void RunTic(ticcmd_t *cmds, boolean *ingame)
     G_Ticker ();
 }
 
-static loop_interface_t doom_loop_interface = {
+static const loop_interface_t doom_loop_interface = {
     D_ProcessEvents,
     G_BuildTiccmd,
     RunTic,
@@ -246,7 +245,7 @@ void D_CheckNetGame (void)
         autostart = true;
     }
 
-    D_RegisterLoopCallbacks(&doom_loop_interface);
+    D_RegisterLoopCallbacks((loop_interface_t *)&doom_loop_interface);
 
     SaveGameSettings(&settings);
     D_StartNetGame(&settings, NULL);
diff --git a/doomgeneric/doomdef.h b/doomgeneric/doomdef.h
index 62d729d..8f4b3bc 100644
--- a/doomgeneric/doomdef.h
+++ b/doomgeneric/doomdef.h
@@ -49,10 +49,10 @@
 // the game final animation, or a demo. 
 typedef enum
 {
+    GS_DEMOSCREEN,
     GS_LEVEL,
     GS_INTERMISSION,
     GS_FINALE,
-    GS_DEMOSCREEN,
 } gamestate_t;
 
 typedef enum
diff --git a/doomgeneric/doomgeneric.h b/doomgeneric/doomgeneric.h
index c2dc4b5..5aea621 100644
--- a/doomgeneric/doomgeneric.h
+++ b/doomgeneric/doomgeneric.h
@@ -4,8 +4,13 @@
 #include <stdlib.h>
 #include <stdint.h>
 
-#define DOOMGENERIC_RESX 640
-#define DOOMGENERIC_RESY 400
+// We scale down to TiDAL screen size:
+// for X this is exactly 0.75, so interpolate 3 from 4
+// for Y this is 0.675 (27/40), so we hack by scaling
+// the same as X (0.75), which gives 150 lines, then drop
+// last 15 lines during blit
+#define DOOMGENERIC_RESX 240
+#define DOOMGENERIC_RESY 150
 
 
 extern uint32_t* DG_ScreenBuffer;
diff --git a/doomgeneric/doomstat.c b/doomgeneric/doomstat.c
index ed4c6cc..78fe6bb 100644
--- a/doomgeneric/doomstat.c
+++ b/doomgeneric/doomstat.c
@@ -22,14 +22,16 @@
 
 
 // Game Mode - identify IWAD as shareware, retail etc.
-GameMode_t gamemode = indetermined;
-GameMission_t	gamemission = doom;
-GameVersion_t   gameversion = exe_final2;
+GameMode_t gamemode;
+GameMission_t	gamemission;
+GameVersion_t   gameversion;
 char *gamedescription;
 
 // Set if homebrew PWAD stuff has been added.
 boolean	modifiedgame;
 
-
-
-
+void D_initDoomstate(void) {
+	gamemode = indetermined;
+	gamemission = doom;
+	gameversion = exe_final2;
+}
diff --git a/doomgeneric/doomstat.h b/doomgeneric/doomstat.h
index acd65dc..ed68cc5 100644
--- a/doomgeneric/doomstat.h
+++ b/doomgeneric/doomstat.h
@@ -277,5 +277,5 @@ extern	int		rndindex;
 
 extern  ticcmd_t       *netcmds;
 
-
+extern void D_initDoomstate(void);
 #endif
diff --git a/doomgeneric/dstrings.c b/doomgeneric/dstrings.c
index b87f198..56d124d 100644
--- a/doomgeneric/dstrings.c
+++ b/doomgeneric/dstrings.c
@@ -20,7 +20,7 @@
 
 #include "dstrings.h"
 
-char *doom1_endmsg[] =
+const char *const doom1_endmsg[] =
 {
   "are you sure you want to\nquit this great game?",
   "please don't leave, there's more\ndemons to toast!",
@@ -32,7 +32,7 @@ char *doom1_endmsg[] =
   "go ahead and leave. see if i care.",
 };
 
-char *doom2_endmsg[] =
+const char *const doom2_endmsg[] =
 {
   // QuitDOOM II messages
   "are you sure you want to\nquit this great game?",
diff --git a/doomgeneric/dstrings.h b/doomgeneric/dstrings.h
index d3240b4..1202137 100644
--- a/doomgeneric/dstrings.h
+++ b/doomgeneric/dstrings.h
@@ -34,8 +34,8 @@
 // 8 per each game type
 #define NUM_QUITMESSAGES   8
 
-extern char *doom1_endmsg[];
-extern char *doom2_endmsg[];
+extern const char *const doom1_endmsg[];
+extern const char *const doom2_endmsg[];
 
 
 #endif
diff --git a/doomgeneric/f_finale.c b/doomgeneric/f_finale.c
index ca6775e..bc03d23 100644
--- a/doomgeneric/f_finale.c
+++ b/doomgeneric/f_finale.c
@@ -61,11 +61,11 @@ typedef struct
 {
     GameMission_t mission;
     int episode, level;
-    char *background;
-    char *text;
+    const char *background;
+    const char *text;
 } textscreen_t;
 
-static textscreen_t textscreens[] =
+static const textscreen_t textscreens[] =
 {
     { doom,      1, 8,  "FLOOR4_8",  E1TEXT},
     { doom,      2, 8,  "SFLR6_1",   E2TEXT},
@@ -127,7 +127,7 @@ void F_StartFinale (void)
 
     for (i=0; i<arrlen(textscreens); ++i)
     {
-        textscreen_t *screen = &textscreens[i];
+        textscreen_t *screen = (textscreen_t *)&textscreens[i];
 
         // Hack for Chex Quest
 
@@ -140,8 +140,8 @@ void F_StartFinale (void)
          && (logical_gamemission != doom || gameepisode == screen->episode)
          && gamemap == screen->level)
         {
-            finaletext = screen->text;
-            finaleflat = screen->background;
+            finaletext = (char *)screen->text;
+            finaleflat = (char *)screen->background;
         }
     }
 
@@ -303,7 +303,7 @@ typedef struct
     mobjtype_t	type;
 } castinfo_t;
 
-castinfo_t	castorder[] = {
+const castinfo_t	castorder[] = {
     {CC_ZOMBIE, MT_POSSESSED},
     {CC_SHOTGUN, MT_SHOTGUY},
     {CC_HEAVY, MT_CHAINGUY},
@@ -341,7 +341,7 @@ void F_StartCast (void)
 {
     wipegamestate = -1;		// force a screen wipe
     castnum = 0;
-    caststate = &states[mobjinfo[castorder[castnum].type].seestate];
+    caststate = (state_t *)&states[mobjinfo[castorder[castnum].type].seestate];
     casttics = caststate->tics;
     castdeath = false;
     finalestage = F_STAGE_CAST;
@@ -372,7 +372,7 @@ void F_CastTicker (void)
 	    castnum = 0;
 	if (mobjinfo[castorder[castnum].type].seesound)
 	    S_StartSound (NULL, mobjinfo[castorder[castnum].type].seesound);
-	caststate = &states[mobjinfo[castorder[castnum].type].seestate];
+	caststate = (state_t *)&states[mobjinfo[castorder[castnum].type].seestate];
 	castframes = 0;
     }
     else
@@ -381,7 +381,7 @@ void F_CastTicker (void)
 	if (caststate == &states[S_PLAY_ATK1])
 	    goto stopattack;	// Oh, gross hack!
 	st = caststate->nextstate;
-	caststate = &states[st];
+	caststate = (state_t *)&states[st];
 	castframes++;
 	
 	// sound hacks....
@@ -425,30 +425,30 @@ void F_CastTicker (void)
 	// go into attack frame
 	castattacking = true;
 	if (castonmelee)
-	    caststate=&states[mobjinfo[castorder[castnum].type].meleestate];
+	    caststate=(state_t *)&states[mobjinfo[castorder[castnum].type].meleestate];
 	else
-	    caststate=&states[mobjinfo[castorder[castnum].type].missilestate];
+	    caststate=(state_t *)&states[mobjinfo[castorder[castnum].type].missilestate];
 	castonmelee ^= 1;
 	if (caststate == &states[S_NULL])
 	{
 	    if (castonmelee)
 		caststate=
-		    &states[mobjinfo[castorder[castnum].type].meleestate];
+		    (state_t *)&states[mobjinfo[castorder[castnum].type].meleestate];
 	    else
 		caststate=
-		    &states[mobjinfo[castorder[castnum].type].missilestate];
+		    (state_t *)&states[mobjinfo[castorder[castnum].type].missilestate];
 	}
     }
 	
     if (castattacking)
     {
 	if (castframes == 24
-	    ||	caststate == &states[mobjinfo[castorder[castnum].type].seestate] )
+	    ||	caststate == (state_t *)&states[mobjinfo[castorder[castnum].type].seestate] )
 	{
 	  stopattack:
 	    castattacking = false;
 	    castframes = 0;
-	    caststate = &states[mobjinfo[castorder[castnum].type].seestate];
+	    caststate = (state_t *)&states[mobjinfo[castorder[castnum].type].seestate];
 	}
     }
 	
@@ -472,7 +472,7 @@ boolean F_CastResponder (event_t* ev)
 		
     // go into death frame
     castdeath = true;
-    caststate = &states[mobjinfo[castorder[castnum].type].deathstate];
+    caststate = (state_t *)&states[mobjinfo[castorder[castnum].type].deathstate];
     casttics = caststate->tics;
     castframes = 0;
     castattacking = false;
@@ -603,6 +603,7 @@ F_DrawPatchCol
 //
 // F_BunnyScroll
 //
+int fbs_laststage;
 void F_BunnyScroll (void)
 {
     signed int  scrolled;
@@ -611,7 +612,6 @@ void F_BunnyScroll (void)
     patch_t*	p2;
     char	name[10];
     int		stage;
-    static int	laststage;
 		
     p1 = W_CacheLumpName (DEH_String("PFUB2"), PU_LEVEL);
     p2 = W_CacheLumpName (DEH_String("PFUB1"), PU_LEVEL);
@@ -639,17 +639,17 @@ void F_BunnyScroll (void)
         V_DrawPatch((SCREENWIDTH - 13 * 8) / 2,
                     (SCREENHEIGHT - 8 * 8) / 2, 
                     W_CacheLumpName(DEH_String("END0"), PU_CACHE));
-	laststage = 0;
+	fbs_laststage = 0;
 	return;
     }
 	
     stage = (finalecount-1180) / 5;
     if (stage > 6)
 	stage = 6;
-    if (stage > laststage)
+    if (stage > fbs_laststage)
     {
 	S_StartSound (NULL, sfx_pistol);
-	laststage = stage;
+	fbs_laststage = stage;
     }
 	
     DEH_snprintf(name, 10, "END%i", stage);
diff --git a/doomgeneric/f_wipe.c b/doomgeneric/f_wipe.c
index 05852fd..84095e2 100644
--- a/doomgeneric/f_wipe.c
+++ b/doomgeneric/f_wipe.c
@@ -30,14 +30,14 @@
 //
 //                       SCREEN WIPE PACKAGE
 //
-
+struct {
 // when zero, stop the wipe
-static boolean	go = 0;
-
-static byte*	wipe_scr_start;
-static byte*	wipe_scr_end;
-static byte*	wipe_scr;
-
+    boolean	go;
+    byte*	wipe_scr_start;
+    byte*	wipe_scr_end;
+    byte*	wipe_scr;
+    int*	y;
+} fw_;
 
 void
 wipe_shittyColMajorXform
@@ -67,7 +67,7 @@ wipe_initColorXForm
   int	height,
   int	ticks )
 {
-    memcpy(wipe_scr, wipe_scr_start, width*height);
+    memcpy(fw_.wipe_scr, fw_.wipe_scr_start, width*height);
     return 0;
 }
 
@@ -83,10 +83,10 @@ wipe_doColorXForm
     int		newval;
 
     changed = false;
-    w = wipe_scr;
-    e = wipe_scr_end;
+    w = fw_.wipe_scr;
+    e = fw_.wipe_scr_end;
     
-    while (w!=wipe_scr+width*height)
+    while (w!=fw_.wipe_scr+width*height)
     {
 	if (*w != *e)
 	{
@@ -127,8 +127,6 @@ wipe_exitColorXForm
 }
 
 
-static int*	y;
-
 int
 wipe_initMelt
 ( int	width,
@@ -138,23 +136,23 @@ wipe_initMelt
     int i, r;
     
     // copy start screen to main screen
-    memcpy(wipe_scr, wipe_scr_start, width*height);
+    memcpy(fw_.wipe_scr, fw_.wipe_scr_start, width*height);
     
     // makes this wipe faster (in theory)
     // to have stuff in column-major format
-    wipe_shittyColMajorXform((short*)wipe_scr_start, width/2, height);
-    wipe_shittyColMajorXform((short*)wipe_scr_end, width/2, height);
+    wipe_shittyColMajorXform((short*)fw_.wipe_scr_start, width/2, height);
+    wipe_shittyColMajorXform((short*)fw_.wipe_scr_end, width/2, height);
     
     // setup initial column positions
     // (y<0 => not ready to scroll yet)
-    y = (int *) Z_Malloc(width*sizeof(int), PU_STATIC, 0);
-    y[0] = -(M_Random()%16);
+    fw_.y = (int *) Z_Malloc(width*sizeof(int), PU_STATIC, 0);
+    fw_.y[0] = -(M_Random()%16);
     for (i=1;i<width;i++)
     {
 	r = (M_Random()%3) - 1;
-	y[i] = y[i-1] + r;
-	if (y[i] > 0) y[i] = 0;
-	else if (y[i] == -16) y[i] = -15;
+	fw_.y[i] = fw_.y[i-1] + r;
+	if (fw_.y[i] > 0) fw_.y[i] = 0;
+	else if (fw_.y[i] == -16) fw_.y[i] = -15;
     }
 
     return 0;
@@ -181,27 +179,27 @@ wipe_doMelt
     {
 	for (i=0;i<width;i++)
 	{
-	    if (y[i]<0)
+	    if (fw_.y[i]<0)
 	    {
-		y[i]++; done = false;
+		fw_.y[i]++; done = false;
 	    }
-	    else if (y[i] < height)
+	    else if (fw_.y[i] < height)
 	    {
-		dy = (y[i] < 16) ? y[i]+1 : 8;
-		if (y[i]+dy >= height) dy = height - y[i];
-		s = &((short *)wipe_scr_end)[i*height+y[i]];
-		d = &((short *)wipe_scr)[y[i]*width+i];
+		dy = (fw_.y[i] < 16) ? fw_.y[i]+1 : 8;
+		if (fw_.y[i]+dy >= height) dy = height - fw_.y[i];
+		s = &((short *)fw_.wipe_scr_end)[i*height+fw_.y[i]];
+		d = &((short *)fw_.wipe_scr)[fw_.y[i]*width+i];
 		idx = 0;
 		for (j=dy;j;j--)
 		{
 		    d[idx] = *(s++);
 		    idx += width;
 		}
-		y[i] += dy;
-		s = &((short *)wipe_scr_start)[i*height];
-		d = &((short *)wipe_scr)[y[i]*width+i];
+		fw_.y[i] += dy;
+		s = &((short *)fw_.wipe_scr_start)[i*height];
+		d = &((short *)fw_.wipe_scr)[fw_.y[i]*width+i];
 		idx = 0;
-		for (j=height-y[i];j;j--)
+		for (j=height-fw_.y[i];j;j--)
 		{
 		    d[idx] = *(s++);
 		    idx += width;
@@ -221,9 +219,9 @@ wipe_exitMelt
   int	height,
   int	ticks )
 {
-    Z_Free(y);
-    Z_Free(wipe_scr_start);
-    Z_Free(wipe_scr_end);
+    Z_Free(fw_.y);
+    Z_Free(fw_.wipe_scr_start);
+    Z_Free(fw_.wipe_scr_end);
     return 0;
 }
 
@@ -234,8 +232,8 @@ wipe_StartScreen
   int	width,
   int	height )
 {
-    wipe_scr_start = Z_Malloc(SCREENWIDTH * SCREENHEIGHT, PU_STATIC, NULL);
-    I_ReadScreen(wipe_scr_start);
+    fw_.wipe_scr_start = Z_Malloc(SCREENWIDTH * SCREENHEIGHT, PU_STATIC, NULL);
+    I_ReadScreen(fw_.wipe_scr_start);
     return 0;
 }
 
@@ -246,12 +244,19 @@ wipe_EndScreen
   int	width,
   int	height )
 {
-    wipe_scr_end = Z_Malloc(SCREENWIDTH * SCREENHEIGHT, PU_STATIC, NULL);
-    I_ReadScreen(wipe_scr_end);
-    V_DrawBlock(x, y, width, height, wipe_scr_start); // restore start scr.
+    fw_.wipe_scr_end = Z_Malloc(SCREENWIDTH * SCREENHEIGHT, PU_STATIC, NULL);
+    I_ReadScreen(fw_.wipe_scr_end);
+    V_DrawBlock(x, y, width, height, fw_.wipe_scr_start); // restore start scr.
     return 0;
 }
 
+ int (*const wipes[])(int, int, int) =
+ {
+	wipe_initColorXForm, wipe_doColorXForm, wipe_exitColorXForm,
+	wipe_initMelt, wipe_doMelt, wipe_exitMelt
+ };
+
+
 int
 wipe_ScreenWipe
 ( int	wipeno,
@@ -262,18 +267,12 @@ wipe_ScreenWipe
   int	ticks )
 {
     int rc;
-    static int (*wipes[])(int, int, int) =
-    {
-	wipe_initColorXForm, wipe_doColorXForm, wipe_exitColorXForm,
-	wipe_initMelt, wipe_doMelt, wipe_exitMelt
-    };
-
     // initial stuff
-    if (!go)
+    if (!fw_.go)
     {
-	go = 1;
+	fw_.go = 1;
 	// wipe_scr = (byte *) Z_Malloc(width*height, PU_STATIC, 0); // DEBUG
-	wipe_scr = I_VideoBuffer;
+	fw_.wipe_scr = I_VideoBuffer;
 	(*wipes[wipeno*3])(width, height, ticks);
     }
 
@@ -285,10 +284,10 @@ wipe_ScreenWipe
     // final stuff
     if (rc)
     {
-	go = 0;
+	fw_.go = 0;
 	(*wipes[wipeno*3+2])(width, height, ticks);
     }
 
-    return !go;
+    return !fw_.go;
 }
 
diff --git a/doomgeneric/g_game.c b/doomgeneric/g_game.c
index 9954d78..dcdfc21 100644
--- a/doomgeneric/g_game.c
+++ b/doomgeneric/g_game.c
@@ -138,9 +138,9 @@ byte*		demo_p;
 byte*		demoend; 
 boolean         singledemo;            	// quit after playing a demo from cmdline 
  
-boolean         precache = true;        // if true, load all graphics at start 
+boolean         precache;        // if true, load all graphics at start 
 
-boolean         testcontrols = false;    // Invoked by setup to test controls
+boolean         testcontrols;    // Invoked by setup to test controls
 int             testcontrols_mousespeed;
  
 
@@ -153,11 +153,11 @@ byte		consistancy[MAXPLAYERS][BACKUPTICS];
  
 #define TURBOTHRESHOLD	0x32
 
-fixed_t         forwardmove[2] = {0x19, 0x32}; 
-fixed_t         sidemove[2] = {0x18, 0x28}; 
-fixed_t         angleturn[3] = {640, 1280, 320};    // + slow turn 
+const fixed_t         forwardmove[2] = {0x19, 0x32}; 
+const fixed_t         sidemove[2] = {0x18, 0x28}; 
+const fixed_t         angleturn[3] = {640, 1280, 320};    // + slow turn 
 
-static int *weapon_keys[] = {
+static const int * const weapon_keys[] = {
     &key_weapon1,
     &key_weapon2,
     &key_weapon3,
@@ -168,10 +168,6 @@ static int *weapon_keys[] = {
     &key_weapon8
 };
 
-// Set to -1 or +1 to switch to the previous or next weapon.
-
-static int next_weapon = 0;
-
 // Used for prev/next weapon keys.
 
 static const struct
@@ -195,40 +191,50 @@ static const struct
 #define NUMKEYS		256 
 #define MAX_JOY_BUTTONS 20
 
-static boolean  gamekeydown[NUMKEYS]; 
-static int      turnheld;		// for accelerative turning 
- 
-static boolean  mousearray[MAX_MOUSE_BUTTONS + 1];
-static boolean *mousebuttons = &mousearray[1];  // allow [-1]
-
 // mouse values are used once 
 int             mousex;
 int             mousey;         
 
-static int      dclicktime;
-static boolean  dclickstate;
-static int      dclicks; 
-static int      dclicktime2;
-static boolean  dclickstate2;
-static int      dclicks2;
+struct {
+// Set to -1 or +1 to switch to the previous or next weapon.
+    int next_weapon;
 
-// joystick values are repeated 
-static int      joyxmove;
-static int      joyymove;
-static int      joystrafemove;
-static boolean  joyarray[MAX_JOY_BUTTONS + 1]; 
-static boolean *joybuttons = &joyarray[1];		// allow [-1] 
+    boolean  gamekeydown[NUMKEYS]; 
+    int      turnheld;		// for accelerative turning 
  
-static int      savegameslot; 
-static char     savedescription[32]; 
+    boolean  mousearray[MAX_MOUSE_BUTTONS + 1];
+    boolean *mousebuttons;
+
+    int      dclicktime;
+    boolean  dclickstate;
+    int      dclicks; 
+    int      dclicktime2;
+    boolean  dclickstate2;
+    int      dclicks2;
+
+// joystick values are repeated 
+    int      joyxmove;
+    int      joyymove;
+    int      joystrafemove;
+    boolean  joyarray[MAX_JOY_BUTTONS + 1]; 
+    boolean *joybuttons;
  
+    int      savegameslot; 
+    char     savedescription[32]; 
+
+    signed short carry;
+    signed short desired_angleturn;
+
+    char turbomessage[80];
+} gg_;
+
 #define	BODYQUESIZE	32
 
 mobj_t*		bodyque[BODYQUESIZE]; 
 int		bodyqueslot; 
  
-int             vanilla_savegame_limit = 1;
-int             vanilla_demo_limit = 1;
+const int             vanilla_savegame_limit = 1;
+const int             vanilla_demo_limit = 1;
  
 int G_CmdChecksum (ticcmd_t* cmd) 
 { 
@@ -334,30 +340,30 @@ void G_BuildTiccmd (ticcmd_t* cmd, int maketic)
     cmd->consistancy = 
 	consistancy[consoleplayer][maketic%BACKUPTICS]; 
  
-    strafe = gamekeydown[key_strafe] || mousebuttons[mousebstrafe] 
-	|| joybuttons[joybstrafe]; 
+    strafe = gg_.gamekeydown[key_strafe] || gg_.mousebuttons[mousebstrafe] 
+	|| gg_.joybuttons[joybstrafe]; 
 
     // fraggle: support the old "joyb_speed = 31" hack which
     // allowed an autorun effect
 
     speed = key_speed >= NUMKEYS
          || joybspeed >= MAX_JOY_BUTTONS
-         || gamekeydown[key_speed] 
-         || joybuttons[joybspeed];
+         || gg_.gamekeydown[key_speed] 
+         || gg_.joybuttons[joybspeed];
  
     forward = side = 0;
     
     // use two stage accelerative turning
     // on the keyboard and joystick
-    if (joyxmove < 0
-	|| joyxmove > 0  
-	|| gamekeydown[key_right]
-	|| gamekeydown[key_left]) 
-	turnheld += ticdup; 
+    if (gg_.joyxmove < 0
+	|| gg_.joyxmove > 0  
+	|| gg_.gamekeydown[key_right]
+	|| gg_.gamekeydown[key_left]) 
+	gg_.turnheld += ticdup; 
     else 
-	turnheld = 0; 
+	gg_.turnheld = 0; 
 
-    if (turnheld < SLOWTURNTICS) 
+    if (gg_.turnheld < SLOWTURNTICS) 
 	tspeed = 2;             // slow turn 
     else 
 	tspeed = speed;
@@ -365,62 +371,58 @@ void G_BuildTiccmd (ticcmd_t* cmd, int maketic)
     // let movement keys cancel each other out
     if (strafe) 
     { 
-	if (gamekeydown[key_right]) 
+	if (gg_.gamekeydown[key_right]) 
 	{
-	    // fprintf(stderr, "strafe right\n");
 	    side += sidemove[speed]; 
 	}
-	if (gamekeydown[key_left]) 
+	if (gg_.gamekeydown[key_left]) 
 	{
-	    //	fprintf(stderr, "strafe left\n");
 	    side -= sidemove[speed]; 
 	}
-	if (joyxmove > 0) 
+	if (gg_.joyxmove > 0) 
 	    side += sidemove[speed]; 
-	if (joyxmove < 0) 
+	if (gg_.joyxmove < 0) 
 	    side -= sidemove[speed]; 
  
     } 
     else 
     { 
-	if (gamekeydown[key_right]) 
+	if (gg_.gamekeydown[key_right]) 
 	    cmd->angleturn -= angleturn[tspeed]; 
-	if (gamekeydown[key_left]) 
+	if (gg_.gamekeydown[key_left]) 
 	    cmd->angleturn += angleturn[tspeed]; 
-	if (joyxmove > 0) 
+	if (gg_.joyxmove > 0) 
 	    cmd->angleturn -= angleturn[tspeed]; 
-	if (joyxmove < 0) 
+	if (gg_.joyxmove < 0) 
 	    cmd->angleturn += angleturn[tspeed]; 
     } 
  
-    if (gamekeydown[key_up]) 
+    if (gg_.gamekeydown[key_up]) 
     {
-	// fprintf(stderr, "up\n");
 	forward += forwardmove[speed]; 
     }
-    if (gamekeydown[key_down]) 
+    if (gg_.gamekeydown[key_down]) 
     {
-	// fprintf(stderr, "down\n");
 	forward -= forwardmove[speed]; 
     }
 
-    if (joyymove < 0) 
+    if (gg_.joyymove < 0) 
         forward += forwardmove[speed]; 
-    if (joyymove > 0) 
+    if (gg_.joyymove > 0) 
         forward -= forwardmove[speed]; 
 
-    if (gamekeydown[key_strafeleft]
-     || joybuttons[joybstrafeleft]
-     || mousebuttons[mousebstrafeleft]
-     || joystrafemove < 0)
+    if (gg_.gamekeydown[key_strafeleft]
+     || gg_.joybuttons[joybstrafeleft]
+     || gg_.mousebuttons[mousebstrafeleft]
+     || gg_.joystrafemove < 0)
     {
         side -= sidemove[speed];
     }
 
-    if (gamekeydown[key_straferight]
-     || joybuttons[joybstraferight]
-     || mousebuttons[mousebstraferight]
-     || joystrafemove > 0)
+    if (gg_.gamekeydown[key_straferight]
+     || gg_.joybuttons[joybstraferight]
+     || gg_.mousebuttons[mousebstraferight]
+     || gg_.joystrafemove > 0)
     {
         side += sidemove[speed]; 
     }
@@ -428,26 +430,26 @@ void G_BuildTiccmd (ticcmd_t* cmd, int maketic)
     // buttons
     cmd->chatchar = HU_dequeueChatChar(); 
  
-    if (gamekeydown[key_fire] || mousebuttons[mousebfire] 
-	|| joybuttons[joybfire]) 
+    if (gg_.gamekeydown[key_fire] || gg_.mousebuttons[mousebfire] 
+	|| gg_.joybuttons[joybfire]) 
 	cmd->buttons |= BT_ATTACK; 
  
-    if (gamekeydown[key_use]
-     || joybuttons[joybuse]
-     || mousebuttons[mousebuse])
+    if (gg_.gamekeydown[key_use]
+     || gg_.joybuttons[joybuse]
+     || gg_.mousebuttons[mousebuse])
     { 
 	cmd->buttons |= BT_USE;
 	// clear double clicks if hit use button 
-	dclicks = 0;                   
+	gg_.dclicks = 0;                   
     } 
 
     // If the previous or next weapon button is pressed, the
     // next_weapon variable is set to change weapons when
     // we generate a ticcmd.  Choose a new weapon.
 
-    if (gamestate == GS_LEVEL && next_weapon != 0)
+    if (gamestate == GS_LEVEL && gg_.next_weapon != 0)
     {
-        i = G_NextWeapon(next_weapon);
+        i = G_NextWeapon(gg_.next_weapon);
         cmd->buttons |= BT_CHANGE;
         cmd->buttons |= i << BT_WEAPONSHIFT;
     }
@@ -459,7 +461,7 @@ void G_BuildTiccmd (ticcmd_t* cmd, int maketic)
         {
             int key = *weapon_keys[i];
 
-            if (gamekeydown[key])
+            if (gg_.gamekeydown[key])
             {
                 cmd->buttons |= BT_CHANGE;
                 cmd->buttons |= i<<BT_WEAPONSHIFT;
@@ -468,14 +470,14 @@ void G_BuildTiccmd (ticcmd_t* cmd, int maketic)
         }
     }
 
-    next_weapon = 0;
+    gg_.next_weapon = 0;
 
     // mouse
-    if (mousebuttons[mousebforward]) 
+    if (gg_.mousebuttons[mousebforward]) 
     {
 	forward += forwardmove[speed];
     }
-    if (mousebuttons[mousebbackward])
+    if (gg_.mousebuttons[mousebbackward])
     {
         forward -= forwardmove[speed];
     }
@@ -483,53 +485,53 @@ void G_BuildTiccmd (ticcmd_t* cmd, int maketic)
     if (dclick_use)
     {
         // forward double click
-        if (mousebuttons[mousebforward] != dclickstate && dclicktime > 1 ) 
+        if (gg_.mousebuttons[mousebforward] != gg_.dclickstate && gg_.dclicktime > 1 ) 
         { 
-            dclickstate = mousebuttons[mousebforward]; 
-            if (dclickstate) 
-                dclicks++; 
-            if (dclicks == 2) 
+            gg_.dclickstate = gg_.mousebuttons[mousebforward]; 
+            if (gg_.dclickstate) 
+                gg_.dclicks++; 
+            if (gg_.dclicks == 2) 
             { 
                 cmd->buttons |= BT_USE; 
-                dclicks = 0; 
+                gg_.dclicks = 0; 
             } 
             else 
-                dclicktime = 0; 
+                gg_.dclicktime = 0; 
         } 
         else 
         { 
-            dclicktime += ticdup; 
-            if (dclicktime > 20) 
+            gg_.dclicktime += ticdup; 
+            if (gg_.dclicktime > 20) 
             { 
-                dclicks = 0; 
-                dclickstate = 0; 
+                gg_.dclicks = 0; 
+                gg_.dclickstate = 0; 
             } 
         }
         
         // strafe double click
         bstrafe =
-            mousebuttons[mousebstrafe] 
-            || joybuttons[joybstrafe]; 
-        if (bstrafe != dclickstate2 && dclicktime2 > 1 ) 
+            gg_.mousebuttons[mousebstrafe] 
+            || gg_.joybuttons[joybstrafe]; 
+        if (bstrafe != gg_.dclickstate2 && gg_.dclicktime2 > 1 ) 
         { 
-            dclickstate2 = bstrafe; 
-            if (dclickstate2) 
-                dclicks2++; 
-            if (dclicks2 == 2) 
+            gg_.dclickstate2 = bstrafe; 
+            if (gg_.dclickstate2) 
+                gg_.dclicks2++; 
+            if (gg_.dclicks2 == 2) 
             { 
                 cmd->buttons |= BT_USE; 
-                dclicks2 = 0; 
+                gg_.dclicks2 = 0; 
             } 
             else 
-                dclicktime2 = 0; 
+                gg_.dclicktime2 = 0; 
         } 
         else 
         { 
-            dclicktime2 += ticdup; 
-            if (dclicktime2 > 20) 
+            gg_.dclicktime2 += ticdup; 
+            if (gg_.dclicktime2 > 20) 
             { 
-                dclicks2 = 0; 
-                dclickstate2 = 0; 
+                gg_.dclicks2 = 0; 
+                gg_.dclickstate2 = 0; 
             } 
         } 
     }
@@ -572,27 +574,24 @@ void G_BuildTiccmd (ticcmd_t* cmd, int maketic)
     if (sendsave) 
     { 
 	sendsave = false; 
-	cmd->buttons = BT_SPECIAL | BTS_SAVEGAME | (savegameslot<<BTS_SAVESHIFT); 
+	cmd->buttons = BT_SPECIAL | BTS_SAVEGAME | (gg_.savegameslot<<BTS_SAVESHIFT); 
     } 
 
     // low-res turning
 
     if (lowres_turn)
     {
-        static signed short carry = 0;
-        signed short desired_angleturn;
-
-        desired_angleturn = cmd->angleturn + carry;
+        gg_.desired_angleturn = cmd->angleturn + gg_.carry;
 
         // round angleturn to the nearest 256 unit boundary
         // for recording demos with single byte values for turn
 
-        cmd->angleturn = (desired_angleturn + 128) & 0xff00;
+        cmd->angleturn = (gg_.desired_angleturn + 128) & 0xff00;
 
         // Carry forward the error from the reduced resolution to the
         // next tic, so that successive small movements can accumulate.
 
-        carry = desired_angleturn - cmd->angleturn;
+        gg_.carry = gg_.desired_angleturn - cmd->angleturn;
     }
 } 
  
@@ -659,12 +658,12 @@ void G_DoLoadLevel (void)
     
     // clear cmd building stuff
 
-    memset (gamekeydown, 0, sizeof(gamekeydown));
-    joyxmove = joyymove = joystrafemove = 0;
+    memset (gg_.gamekeydown, 0, sizeof(gg_.gamekeydown));
+    gg_.joyxmove = gg_.joyymove = gg_.joystrafemove = 0;
     mousex = mousey = 0;
     sendpause = sendsave = paused = false;
-    memset(mousearray, 0, sizeof(mousearray));
-    memset(joyarray, 0, sizeof(joyarray));
+    memset(gg_.mousearray, 0, sizeof(gg_.mousearray));
+    memset(gg_.joyarray, 0, sizeof(gg_.joyarray));
 
     if (testcontrols)
     {
@@ -682,21 +681,21 @@ static void SetJoyButtons(unsigned int buttons_mask)
 
         // Detect button press:
 
-        if (!joybuttons[i] && button_on)
+        if (!gg_.joybuttons[i] && button_on)
         {
             // Weapon cycling:
 
             if (i == joybprevweapon)
             {
-                next_weapon = -1;
+                gg_.next_weapon = -1;
             }
             else if (i == joybnextweapon)
             {
-                next_weapon = 1;
+                gg_.next_weapon = 1;
             }
         }
 
-        joybuttons[i] = button_on;
+        gg_.joybuttons[i] = button_on;
     }
 }
 
@@ -710,19 +709,19 @@ static void SetMouseButtons(unsigned int buttons_mask)
 
         // Detect button press:
 
-        if (!mousebuttons[i] && button_on)
+        if (!gg_.mousebuttons[i] && button_on)
         {
             if (i == mousebprevweapon)
             {
-                next_weapon = -1;
+                gg_.next_weapon = -1;
             }
             else if (i == mousebnextweapon)
             {
-                next_weapon = 1;
+                gg_.next_weapon = 1;
             }
         }
 
-	mousebuttons[i] = button_on;
+	gg_.mousebuttons[i] = button_on;
     }
 }
 
@@ -799,11 +798,11 @@ boolean G_Responder (event_t* ev)
 
     if (ev->type == ev_keydown && ev->data1 == key_prevweapon)
     {
-        next_weapon = -1;
+        gg_.next_weapon = -1;
     }
     else if (ev->type == ev_keydown && ev->data1 == key_nextweapon)
     {
-        next_weapon = 1;
+        gg_.next_weapon = 1;
     }
 
     switch (ev->type) 
@@ -815,14 +814,14 @@ boolean G_Responder (event_t* ev)
 	}
         else if (ev->data1 <NUMKEYS) 
         {
-	    gamekeydown[ev->data1] = true; 
+	    gg_.gamekeydown[ev->data1] = true; 
         }
 
 	return true;    // eat key down events 
  
       case ev_keyup: 
 	if (ev->data1 <NUMKEYS) 
-	    gamekeydown[ev->data1] = false; 
+	    gg_.gamekeydown[ev->data1] = false; 
 	return false;   // always let key up events filter down 
 		 
       case ev_mouse: 
@@ -833,9 +832,9 @@ boolean G_Responder (event_t* ev)
  
       case ev_joystick: 
         SetJoyButtons(ev->data1);
-	joyxmove = ev->data2; 
-	joyymove = ev->data3; 
-        joystrafemove = ev->data4;
+	gg_.joyxmove = ev->data2; 
+	gg_.joyymove = ev->data3; 
+        gg_.joystrafemove = ev->data4;
 	return true;    // eat events 
  
       default: 
@@ -935,11 +934,10 @@ void G_Ticker (void)
              && ((gametic >> 5) % MAXPLAYERS) == i
              && turbodetected[i])
             {
-                static char turbomessage[80];
                 extern char *player_names[4];
-                M_snprintf(turbomessage, sizeof(turbomessage),
+                M_snprintf(gg_.turbomessage, sizeof(gg_.turbomessage),
                            "%s is turbo!", player_names[i]);
-                players[consoleplayer].message = turbomessage;
+                players[consoleplayer].message = gg_.turbomessage;
                 turbodetected[i] = false;
             }
 
@@ -977,13 +975,13 @@ void G_Ticker (void)
 		    break; 
 					 
 		  case BTS_SAVEGAME:
-		    if (!savedescription[0]) 
+		    if (!gg_.savedescription[0]) 
                     {
-                        M_StringCopy(savedescription, "NET GAME",
-                                     sizeof(savedescription));
+                        M_StringCopy(gg_.savedescription, "NET GAME",
+                                     sizeof(gg_.savedescription));
                     }
 
-		    savegameslot =  
+		    gg_.savegameslot =  
 			(players[i].cmd.buttons & BTS_SAVEMASK)>>BTS_SAVESHIFT; 
 		    gameaction = ga_savegame; 
 		    break; 
@@ -1301,7 +1299,7 @@ void G_ScreenShot (void)
 
 
 // DOOM Par Times
-int pars[4][10] = 
+int const pars[4][10] = 
 { 
     {0}, 
     {0,30,75,120,90,165,180,180,30,165}, 
@@ -1310,7 +1308,7 @@ int pars[4][10] =
 }; 
 
 // DOOM II Par Times
-int cpars[32] =
+int const cpars[32] =
 {
     30,90,120,120,90,150,120,120,270,90,	//  1-10
     210,150,150,150,210,150,420,150,210,150,	// 11-20
@@ -1602,8 +1600,8 @@ G_SaveGame
 ( int	slot,
   char*	description )
 {
-    savegameslot = slot;
-    M_StringCopy(savedescription, description, sizeof(savedescription));
+    gg_.savegameslot = slot;
+    M_StringCopy(gg_.savedescription, description, sizeof(gg_.savedescription));
     sendsave = true;
 }
 
@@ -1615,7 +1613,7 @@ void G_DoSaveGame (void)
 
     recovery_savegame_file = NULL;
     temp_savegame_file = P_TempSaveGameFile();
-    savegame_file = P_SaveGameFile(savegameslot);
+    savegame_file = P_SaveGameFile(gg_.savegameslot);
 
     // Open the savegame file for writing.  We write to a temporary file
     // and then rename it at the end if it was successfully written.
@@ -1638,7 +1636,7 @@ void G_DoSaveGame (void)
 
     savegame_error = false;
 
-    P_WriteSaveGameHeader(savedescription);
+    P_WriteSaveGameHeader(gg_.savedescription);
  
     P_ArchivePlayers (); 
     P_ArchiveWorld (); 
@@ -1676,14 +1674,14 @@ void G_DoSaveGame (void)
     rename(temp_savegame_file, savegame_file);
     
     gameaction = ga_nothing;
-    M_StringCopy(savedescription, "", sizeof(savedescription));
+    M_StringCopy(gg_.savedescription, "", sizeof(gg_.savedescription));
 
     players[consoleplayer].message = DEH_String(GGSAVED);
 
     // draw the pattern into the back screen
     R_FillBackScreen ();	
 } 
- 
+
 
 //
 // G_InitNew
@@ -1723,6 +1721,12 @@ void G_DoNewGame (void)
 } 
 
 
+void G_Init(void)
+{
+	gg_.mousebuttons = &gg_.mousearray[1];  // allow [-1]
+	gg_.joybuttons = &gg_.joyarray[1];		// allow [-1] 
+}
+
 void
 G_InitNew
 ( skill_t	skill,
@@ -1809,6 +1813,8 @@ G_InitNew
     else
 	respawnmonsters = false;
 
+#if 0
+	//TODO:PAA nightmare mode
     if (fastparm || (skill == sk_nightmare && gameskill != sk_nightmare) )
     {
 	for (i=S_SARG_RUN1 ; i<=S_SARG_PAIN2 ; i++)
@@ -1825,7 +1831,7 @@ G_InitNew
 	mobjinfo[MT_HEADSHOT].speed = 10*FRACUNIT;
 	mobjinfo[MT_TROOPSHOT].speed = 10*FRACUNIT;
     }
-
+#endif
     // force players to be initialized upon first level load
     for (i=0 ; i<MAXPLAYERS ; i++)
 	players[i].playerstate = PST_REBORN;
@@ -1957,7 +1963,7 @@ void G_WriteDemoTiccmd (ticcmd_t* cmd)
 { 
     byte *demo_start;
 
-    if (gamekeydown[key_demo_quit])           // press q to end demo recording 
+    if (gg_.gamekeydown[key_demo_quit])           // press q to end demo recording 
 	G_CheckDemoStatus (); 
 
     demo_start = demo_p;
@@ -2111,11 +2117,9 @@ void G_DeferedPlayDemo (char* name)
 } 
 
 // Generate a string describing a demo version
-
+char gg_demoversion[16];
 static char *DemoVersionDescription(int version)
 {
-    static char resultbuf[16];
-
     switch (version)
     {
         case 104:
@@ -2143,9 +2147,9 @@ static char *DemoVersionDescription(int version)
     }
     else
     {
-        M_snprintf(resultbuf, sizeof(resultbuf),
+        M_snprintf(gg_demoversion, sizeof(gg_demoversion),
                    "%i.%i (unknown)", version / 100, version % 100);
-        return resultbuf;
+        return gg_demoversion;
     }
 }
 
diff --git a/doomgeneric/g_game.h b/doomgeneric/g_game.h
index da0df39..2258c05 100644
--- a/doomgeneric/g_game.h
+++ b/doomgeneric/g_game.h
@@ -29,7 +29,7 @@
 // GAME
 //
 void G_DeathMatchSpawnPlayer (int playernum);
-
+void G_Init(void);
 void G_InitNew (skill_t skill, int episode, int map);
 
 // Can be called by the startup code or M_Responder.
@@ -74,7 +74,7 @@ void G_ScreenShot (void);
 void G_DrawMouseSpeedBox(void);
 int G_VanillaVersionCode(void);
 
-extern int vanilla_savegame_limit;
-extern int vanilla_demo_limit;
+extern const int vanilla_savegame_limit;
+extern const int vanilla_demo_limit;
 #endif
 
diff --git a/doomgeneric/hu_stuff.c b/doomgeneric/hu_stuff.c
index b63cac7..57335b3 100644
--- a/doomgeneric/hu_stuff.c
+++ b/doomgeneric/hu_stuff.c
@@ -61,7 +61,7 @@
 
 
 
-char *chat_macros[10] =
+const char * const chat_macros[10] =
 {
     HUSTR_CHATMACRO0,
     HUSTR_CHATMACRO1,
@@ -75,7 +75,7 @@ char *chat_macros[10] =
     HUSTR_CHATMACRO9
 };
 
-char*	player_names[] =
+const char*	const player_names[] =
 {
     HUSTR_PLRGREEN,
     HUSTR_PLRINDIGO,
@@ -83,33 +83,41 @@ char*	player_names[] =
     HUSTR_PLRRED
 };
 
-char			chat_char; // remove later.
-static player_t*	plr;
 patch_t*		hu_font[HU_FONTSIZE];
-static hu_textline_t	w_title;
+char			chat_char; // remove later.
 boolean			chat_on;
-static hu_itext_t	w_chat;
-static boolean		always_off = false;
-static char		chat_dest[MAXPLAYERS];
-static hu_itext_t w_inputbuffer[MAXPLAYERS];
-
-static boolean		message_on;
 boolean			message_dontfuckwithme;
-static boolean		message_nottobefuckedwith;
-
-static hu_stext_t	w_message;
-static int		message_counter;
 
 extern int		showMessages;
 
-static boolean		headsupactive = false;
+struct {
+    player_t*	plr;
+    hu_textline_t	w_title;
+    hu_itext_t	w_chat;
+    boolean		always_off;
+    char		chat_dest[MAXPLAYERS];
+    hu_itext_t w_inputbuffer[MAXPLAYERS];
+
+    boolean		message_on;
+    boolean		message_nottobefuckedwith;
+
+    hu_stext_t	w_message;
+    int		message_counter;
+
+    boolean		headsupactive;
+
+    #define QUEUESIZE		128
+    char	chatchars[QUEUESIZE];
+    int	head;
+    int	tail;
+} hu_;
 
 //
 // Builtin map names.
 // The actual names can be found in DStrings.h.
 //
 
-char*	mapnames[] =	// DOOM shareware/registered/retail (Ultimate) names.
+const char * const mapnames[] =	// DOOM shareware/registered/retail (Ultimate) names.
 {
 
     HUSTR_E1M1,
@@ -169,7 +177,7 @@ char*	mapnames[] =	// DOOM shareware/registered/retail (Ultimate) names.
 // the layout in the Vanilla executable, where it is possible to
 // overflow the end of one array into the next.
 
-char *mapnames_commercial[] =
+const char * const mapnames_commercial[] =
 {
     // DOOM 2 map names.
 
@@ -302,7 +310,7 @@ void HU_Init(void)
 
 void HU_Stop(void)
 {
-    headsupactive = false;
+    hu_.headsupactive = false;
 }
 
 void HU_Start(void)
@@ -311,23 +319,23 @@ void HU_Start(void)
     int		i;
     char*	s;
 
-    if (headsupactive)
+    if (hu_.headsupactive)
 	HU_Stop();
 
-    plr = &players[consoleplayer];
-    message_on = false;
+    hu_.plr = &players[consoleplayer];
+    hu_.message_on = false;
     message_dontfuckwithme = false;
-    message_nottobefuckedwith = false;
+    hu_.message_nottobefuckedwith = false;
     chat_on = false;
 
     // create the message widget
-    HUlib_initSText(&w_message,
+    HUlib_initSText(&hu_.w_message,
 		    HU_MSGX, HU_MSGY, HU_MSGHEIGHT,
 		    hu_font,
-		    HU_FONTSTART, &message_on);
+		    HU_FONTSTART, &hu_.message_on);
 
     // create the map title widget
-    HUlib_initTextLine(&w_title,
+    HUlib_initTextLine(&hu_.w_title,
 		       HU_TITLEX, HU_TITLEY,
 		       hu_font,
 		       HU_FONTSTART);
@@ -335,16 +343,16 @@ void HU_Start(void)
     switch ( logical_gamemission )
     {
       case doom:
-	s = HU_TITLE;
+	s = (char *)HU_TITLE;
 	break;
       case doom2:
-	 s = HU_TITLE2;
+	 s = (char *)HU_TITLE2;
 	 break;
       case pack_plut:
-	s = HU_TITLEP;
+	s = (char *)HU_TITLEP;
 	break;
       case pack_tnt:
-	s = HU_TITLET;
+	s = (char *)HU_TITLET;
 	break;
       default:
          s = "Unknown level";
@@ -356,7 +364,7 @@ void HU_Start(void)
 
     if (gameversion == exe_chex)
     {
-        s = HU_TITLE_CHEX;
+        s = (char *)HU_TITLE_CHEX;
     }
 
     // dehacked substitution to get modified level name
@@ -364,38 +372,38 @@ void HU_Start(void)
     s = DEH_String(s);
     
     while (*s)
-	HUlib_addCharToTextLine(&w_title, *(s++));
+	HUlib_addCharToTextLine(&hu_.w_title, *(s++));
 
     // create the chat widget
-    HUlib_initIText(&w_chat,
+    HUlib_initIText(&hu_.w_chat,
 		    HU_INPUTX, HU_INPUTY,
 		    hu_font,
 		    HU_FONTSTART, &chat_on);
 
     // create the inputbuffer widgets
     for (i=0 ; i<MAXPLAYERS ; i++)
-	HUlib_initIText(&w_inputbuffer[i], 0, 0, 0, 0, &always_off);
+	HUlib_initIText(&hu_.w_inputbuffer[i], 0, 0, 0, 0, &hu_.always_off);
 
-    headsupactive = true;
+    hu_.headsupactive = true;
 
 }
 
 void HU_Drawer(void)
 {
 
-    HUlib_drawSText(&w_message);
-    HUlib_drawIText(&w_chat);
+    HUlib_drawSText(&hu_.w_message);
+    HUlib_drawIText(&hu_.w_chat);
     if (automapactive)
-	HUlib_drawTextLine(&w_title, false);
+	HUlib_drawTextLine(&hu_.w_title, false);
 
 }
 
 void HU_Erase(void)
 {
 
-    HUlib_eraseSText(&w_message);
-    HUlib_eraseIText(&w_chat);
-    HUlib_eraseTextLine(&w_title);
+    HUlib_eraseSText(&hu_.w_message);
+    HUlib_eraseIText(&hu_.w_chat);
+    HUlib_eraseTextLine(&hu_.w_title);
 
 }
 
@@ -406,24 +414,24 @@ void HU_Ticker(void)
     char c;
 
     // tick down message counter if message is up
-    if (message_counter && !--message_counter)
+    if (hu_.message_counter && !--hu_.message_counter)
     {
-	message_on = false;
-	message_nottobefuckedwith = false;
+	hu_.message_on = false;
+	hu_.message_nottobefuckedwith = false;
     }
 
     if (showMessages || message_dontfuckwithme)
     {
 
 	// display message if necessary
-	if ((plr->message && !message_nottobefuckedwith)
-	    || (plr->message && message_dontfuckwithme))
+	if ((hu_.plr->message && !hu_.message_nottobefuckedwith)
+	    || (hu_.plr->message && message_dontfuckwithme))
 	{
-	    HUlib_addMessageToSText(&w_message, 0, plr->message);
-	    plr->message = 0;
-	    message_on = true;
-	    message_counter = HU_MSGTIMEOUT;
-	    message_nottobefuckedwith = message_dontfuckwithme;
+	    HUlib_addMessageToSText(&hu_.w_message, 0, hu_.plr->message);
+	    hu_.plr->message = 0;
+	    hu_.message_on = true;
+	    hu_.message_counter = HU_MSGTIMEOUT;
+	    hu_.message_nottobefuckedwith = message_dontfuckwithme;
 	    message_dontfuckwithme = 0;
 	}
 
@@ -440,29 +448,29 @@ void HU_Ticker(void)
 		&& (c = players[i].cmd.chatchar))
 	    {
 		if (c <= HU_BROADCAST)
-		    chat_dest[i] = c;
+		    hu_.chat_dest[i] = c;
 		else
 		{
-		    rc = HUlib_keyInIText(&w_inputbuffer[i], c);
+		    rc = HUlib_keyInIText(&hu_.w_inputbuffer[i], c);
 		    if (rc && c == KEY_ENTER)
 		    {
-			if (w_inputbuffer[i].l.len
-			    && (chat_dest[i] == consoleplayer+1
-				|| chat_dest[i] == HU_BROADCAST))
+			if (hu_.w_inputbuffer[i].l.len
+			    && (hu_.chat_dest[i] == consoleplayer+1
+				|| hu_.chat_dest[i] == HU_BROADCAST))
 			{
-			    HUlib_addMessageToSText(&w_message,
-						    DEH_String(player_names[i]),
-						    w_inputbuffer[i].l.l);
+			    HUlib_addMessageToSText(&hu_.w_message,
+						    DEH_String((char *)player_names[i]),
+						    hu_.w_inputbuffer[i].l.l);
 			    
-			    message_nottobefuckedwith = true;
-			    message_on = true;
-			    message_counter = HU_MSGTIMEOUT;
+			    hu_.message_nottobefuckedwith = true;
+			    hu_.message_on = true;
+			    hu_.message_counter = HU_MSGTIMEOUT;
 			    if ( gamemode == commercial )
 			      S_StartSound(0, sfx_radio);
 			    else
 			      S_StartSound(0, sfx_tink);
 			}
-			HUlib_resetIText(&w_inputbuffer[i]);
+			HUlib_resetIText(&hu_.w_inputbuffer[i]);
 		    }
 		}
 		players[i].cmd.chatchar = 0;
@@ -472,23 +480,17 @@ void HU_Ticker(void)
 
 }
 
-#define QUEUESIZE		128
-
-static char	chatchars[QUEUESIZE];
-static int	head = 0;
-static int	tail = 0;
-
 
 void HU_queueChatChar(char c)
 {
-    if (((head + 1) & (QUEUESIZE-1)) == tail)
+    if (((hu_.head + 1) & (QUEUESIZE-1)) == hu_.tail)
     {
-	plr->message = DEH_String(HUSTR_MSGU);
+	hu_.plr->message = DEH_String(HUSTR_MSGU);
     }
     else
     {
-	chatchars[head] = c;
-	head = (head + 1) & (QUEUESIZE-1);
+	hu_.chatchars[hu_.head] = c;
+	hu_.head = (hu_.head + 1) & (QUEUESIZE-1);
     }
 }
 
@@ -496,10 +498,10 @@ char HU_dequeueChatChar(void)
 {
     char c;
 
-    if (head != tail)
+    if (hu_.head != hu_.tail)
     {
-	c = chatchars[tail];
-	tail = (tail + 1) & (QUEUESIZE-1);
+	c = hu_.chatchars[hu_.tail];
+	hu_.tail = (hu_.tail + 1) & (QUEUESIZE-1);
     }
     else
     {
@@ -509,18 +511,20 @@ char HU_dequeueChatChar(void)
     return c;
 }
 
+struct {
+        char	lastmessage[HU_MAXLINELENGTH+1];
+        boolean	altdown;
+        int		num_nobrainers;
+} hur_;
 boolean HU_Responder(event_t *ev)
 {
 
-    static char		lastmessage[HU_MAXLINELENGTH+1];
     char*		macromessage;
     boolean		eatkey = false;
-    static boolean	altdown = false;
     unsigned char 	c;
     int			i;
     int			numplayers;
     
-    static int		num_nobrainers = 0;
 
     numplayers = 0;
     for (i=0 ; i<MAXPLAYERS ; i++)
@@ -532,7 +536,7 @@ boolean HU_Responder(event_t *ev)
     }
     else if (ev->data1 == KEY_RALT || ev->data1 == KEY_LALT)
     {
-	altdown = ev->type == ev_keydown;
+	hur_.altdown = ev->type == ev_keydown;
 	return false;
     }
 
@@ -543,14 +547,14 @@ boolean HU_Responder(event_t *ev)
     {
 	if (ev->data1 == key_message_refresh)
 	{
-	    message_on = true;
-	    message_counter = HU_MSGTIMEOUT;
+	    hu_.message_on = true;
+	    hu_.message_counter = HU_MSGTIMEOUT;
 	    eatkey = true;
 	}
 	else if (netgame && ev->data2 == key_multi_msg)
 	{
 	    eatkey = chat_on = true;
-	    HUlib_resetIText(&w_chat);
+	    HUlib_resetIText(&hu_.w_chat);
 	    HU_queueChatChar(HU_BROADCAST);
 	}
 	else if (netgame && numplayers > 2)
@@ -562,23 +566,23 @@ boolean HU_Responder(event_t *ev)
 		    if (playeringame[i] && i!=consoleplayer)
 		    {
 			eatkey = chat_on = true;
-			HUlib_resetIText(&w_chat);
+			HUlib_resetIText(&hu_.w_chat);
 			HU_queueChatChar(i+1);
 			break;
 		    }
 		    else if (i == consoleplayer)
 		    {
-			num_nobrainers++;
-			if (num_nobrainers < 3)
-			    plr->message = DEH_String(HUSTR_TALKTOSELF1);
-			else if (num_nobrainers < 6)
-			    plr->message = DEH_String(HUSTR_TALKTOSELF2);
-			else if (num_nobrainers < 9)
-			    plr->message = DEH_String(HUSTR_TALKTOSELF3);
-			else if (num_nobrainers < 32)
-			    plr->message = DEH_String(HUSTR_TALKTOSELF4);
+			hur_.num_nobrainers++;
+			if (hur_.num_nobrainers < 3)
+			    hu_.plr->message = DEH_String(HUSTR_TALKTOSELF1);
+			else if (hur_.num_nobrainers < 6)
+			    hu_.plr->message = DEH_String(HUSTR_TALKTOSELF2);
+			else if (hur_.num_nobrainers < 9)
+			    hu_.plr->message = DEH_String(HUSTR_TALKTOSELF3);
+			else if (hur_.num_nobrainers < 32)
+			    hu_.plr->message = DEH_String(HUSTR_TALKTOSELF4);
 			else
-			    plr->message = DEH_String(HUSTR_TALKTOSELF5);
+			    hu_.plr->message = DEH_String(HUSTR_TALKTOSELF5);
 		    }
 		}
 	    }
@@ -587,13 +591,12 @@ boolean HU_Responder(event_t *ev)
     else
     {
 	// send a macro
-	if (altdown)
+	if (hur_.altdown)
 	{
 	    c = ev->data1 - '0';
 	    if (c > 9)
 		return false;
-	    // fprintf(stderr, "got here\n");
-	    macromessage = chat_macros[c];
+	    macromessage = (char *)chat_macros[c];
 	    
 	    // kill last message with a '\n'
 	    HU_queueChatChar(KEY_ENTER); // DEBUG!!!
@@ -605,15 +608,15 @@ boolean HU_Responder(event_t *ev)
 	    
             // leave chat mode and notify that it was sent
             chat_on = false;
-            M_StringCopy(lastmessage, chat_macros[c], sizeof(lastmessage));
-            plr->message = lastmessage;
+            M_StringCopy(hur_.lastmessage, chat_macros[c], sizeof(hur_.lastmessage));
+            hu_.plr->message = hur_.lastmessage;
             eatkey = true;
 	}
 	else
 	{
             c = ev->data2;
 
-	    eatkey = HUlib_keyInIText(&w_chat, c);
+	    eatkey = HUlib_keyInIText(&hu_.w_chat, c);
 	    if (eatkey)
 	    {
 		// static unsigned char buf[20]; // DEBUG
@@ -625,10 +628,10 @@ boolean HU_Responder(event_t *ev)
 	    if (c == KEY_ENTER)
 	    {
 		chat_on = false;
-                if (w_chat.l.len)
+                if (hu_.w_chat.l.len)
                 {
-                    M_StringCopy(lastmessage, w_chat.l.l, sizeof(lastmessage));
-                    plr->message = lastmessage;
+                    M_StringCopy(hur_.lastmessage, hu_.w_chat.l.l, sizeof(hur_.lastmessage));
+                    hu_.plr->message = hur_.lastmessage;
                 }
 	    }
 	    else if (c == KEY_ESCAPE)
diff --git a/doomgeneric/hu_stuff.h b/doomgeneric/hu_stuff.h
index a3affc5..72a0d9e 100644
--- a/doomgeneric/hu_stuff.h
+++ b/doomgeneric/hu_stuff.h
@@ -53,7 +53,7 @@ void HU_Drawer(void);
 char HU_dequeueChatChar(void);
 void HU_Erase(void);
 
-extern char *chat_macros[10];
+extern const char * const chat_macros[10];
 
 #endif
 
diff --git a/doomgeneric/i_cdmus.c b/doomgeneric/i_cdmus.c
index 6a9a9a6..784ed71 100644
--- a/doomgeneric/i_cdmus.c
+++ b/doomgeneric/i_cdmus.c
@@ -99,7 +99,7 @@ void I_CDMusPrintStartup(void)
 
     if (startup_error != NULL)
     {
-        fprintf(stderr, "I_CDMusInit: %s\n", startup_error);
+        printf("I_CDMusInit: %s\n", startup_error);
     }
 #endif
 }
diff --git a/doomgeneric/i_input.c b/doomgeneric/i_input.c
index 7ec4b63..99088fc 100644
--- a/doomgeneric/i_input.c
+++ b/doomgeneric/i_input.c
@@ -41,13 +41,14 @@
 
 #include "doomgeneric.h"
 
-int vanilla_keyboard_mapping = 1;
+int vanilla_keyboard_mapping;
 
 // Is the shift key currently down?
 
-static int shiftdown = 0;
+int ii_shiftdown;
 
 // Lookup table for mapping AT keycodes to their doom keycode
+#if 0
 static const char at_to_doom[] =
 {
     /* 0x00 */ 0x00,
@@ -179,6 +180,7 @@ static const char at_to_doom[] =
     /* 0x7e */ 0x0,
     /* 0x7f */ KEY_FIRE, //KEY_RCTRL,
 };
+#endif
 
 // Lookup table for mapping ASCII characters to their equivalent when
 // shift is pressed on an American layout keyboard:
@@ -245,7 +247,7 @@ static unsigned char GetTypedChar(unsigned char key)
 
     // Is shift held down?  If so, perform a translation.
 
-    if (shiftdown > 0)
+    if (ii_shiftdown > 0)
     {
         if (key >= 0 && key < arrlen(shiftxform))
         {
@@ -271,7 +273,7 @@ static void UpdateShiftStatus(int pressed, unsigned char key)
     }
 
     if (key == KEY_RSHIFT) {
-        shiftdown += change;
+        ii_shiftdown += change;
     }
 }
 
@@ -337,5 +339,6 @@ void I_GetEvent(void)
 
 void I_InitInput(void)
 {
+	vanilla_keyboard_mapping = 1;
 }
 
diff --git a/doomgeneric/i_joystick.c b/doomgeneric/i_joystick.c
index 755aec3..e381cd1 100644
--- a/doomgeneric/i_joystick.c
+++ b/doomgeneric/i_joystick.c
@@ -38,41 +38,44 @@
 #define DEAD_ZONE (32768 / 3)
 
 #ifdef ORIGCODE
-static SDL_Joystick *joystick = NULL;
+static SDL_Joystick *joystick;
 #endif
 
 // Configuration variables:
-
+struct {
 // Standard default.cfg Joystick enable/disable
 
-static int usejoystick = 0;
+    int usejoystick;
 
 // Joystick to use, as an SDL joystick index:
 
-static int joystick_index = -1;
+    int joystick_index;
 
 // Which joystick axis to use for horizontal movement, and whether to
 // invert the direction:
 
-static int joystick_x_axis = 0;
-static int joystick_x_invert = 0;
+    int joystick_x_axis;
+    int joystick_x_invert;
 
 // Which joystick axis to use for vertical movement, and whether to
 // invert the direction:
 
-static int joystick_y_axis = 1;
-static int joystick_y_invert = 0;
+    int joystick_y_axis;
+    int joystick_y_invert;
 
 // Which joystick axis to use for strafing?
 
-static int joystick_strafe_axis = -1;
-static int joystick_strafe_invert = 0;
+    int joystick_strafe_axis;
+    int joystick_strafe_invert;
+} ij_;
 
 // Virtual to physical button joystick button mapping. By default this
 // is a straight mapping.
-static int joystick_physical_buttons[NUM_VIRTUAL_BUTTONS] = {
+/*TODO:PAA
+static int const joystick_physical_buttons[NUM_VIRTUAL_BUTTONS] = {
     0, 1, 2, 3, 4, 5, 6, 7, 8, 9
 };
+*/
 
 void I_ShutdownJoystick(void)
 {
@@ -340,20 +343,23 @@ void I_BindJoystickVariables(void)
 {
     int i;
 
-    M_BindVariable("use_joystick",          &usejoystick);
-    M_BindVariable("joystick_index",        &joystick_index);
-    M_BindVariable("joystick_x_axis",       &joystick_x_axis);
-    M_BindVariable("joystick_y_axis",       &joystick_y_axis);
-    M_BindVariable("joystick_strafe_axis",  &joystick_strafe_axis);
-    M_BindVariable("joystick_x_invert",     &joystick_x_invert);
-    M_BindVariable("joystick_y_invert",     &joystick_y_invert);
-    M_BindVariable("joystick_strafe_invert",&joystick_strafe_invert);
+	ij_.joystick_index = -1;
+	ij_.joystick_y_axis = 1;
+	ij_.joystick_strafe_axis = -1;
+    M_BindVariable("use_joystick",          &ij_.usejoystick);
+    M_BindVariable("joystick_index",        &ij_.joystick_index);
+    M_BindVariable("joystick_x_axis",       &ij_.joystick_x_axis);
+    M_BindVariable("joystick_y_axis",       &ij_.joystick_y_axis);
+    M_BindVariable("joystick_strafe_axis",  &ij_.joystick_strafe_axis);
+    M_BindVariable("joystick_x_invert",     &ij_.joystick_x_invert);
+    M_BindVariable("joystick_y_invert",     &ij_.joystick_y_invert);
+    M_BindVariable("joystick_strafe_invert",&ij_.joystick_strafe_invert);
 
     for (i = 0; i < NUM_VIRTUAL_BUTTONS; ++i)
     {
         char name[32];
         M_snprintf(name, sizeof(name), "joystick_physical_button%i", i);
-        M_BindVariable(name, &joystick_physical_buttons[i]);
+//TODO:PAA        M_BindVariable(name, &joystick_physical_buttons[i]);
     }
 }
 
diff --git a/doomgeneric/i_scale.c b/doomgeneric/i_scale.c
index f88c694..d0d4310 100644
--- a/doomgeneric/i_scale.c
+++ b/doomgeneric/i_scale.c
@@ -32,37 +32,39 @@
 #define inline __inline
 #endif
 
+struct {
 // Should be I_VideoBuffer
 
-static byte *src_buffer;
+    byte *src_buffer;
 
 // Destination buffer, ie. screen->pixels.
 
-static byte *dest_buffer;
+    byte *dest_buffer;
 
 // Pitch of destination buffer, ie. screen->pitch.
 
-static int dest_pitch;
+    int dest_pitch;
 
 // Lookup tables used for aspect ratio correction stretching code.
-// stretch_tables[0] : 20% / 80%
-// stretch_tables[1] : 40% / 60%
+// is_.stretch_tables[0] : 20% / 80%
+// is_.stretch_tables[1] : 40% / 60%
 // All other combinations can be reached from these two tables.
 
-static byte *stretch_tables[2] = { NULL, NULL };
+    byte *stretch_tables[2];
 
 // 50%/50% stretch table, for 800x600 squash mode
 
-static byte *half_stretch_table = NULL;
+    byte *half_stretch_table;
+} is_;
 
 // Called to set the source and destination buffers before doing the
 // scale.
 
 void I_InitScale(byte *_src_buffer, byte *_dest_buffer, int _dest_pitch)
 {
-    src_buffer = _src_buffer;
-    dest_buffer = _dest_buffer;
-    dest_pitch = _dest_pitch;
+    is_.src_buffer = _src_buffer;
+    is_.dest_buffer = _dest_buffer;
+    is_.dest_pitch = _dest_pitch;
 }
 
 //
@@ -80,20 +82,20 @@ static boolean I_Scale1x(int x1, int y1, int x2, int y2)
     
     // Need to byte-copy from buffer into the screen buffer
 
-    bufp = src_buffer + y1 * SCREENWIDTH + x1;
-    screenp = (byte *) dest_buffer + y1 * dest_pitch + x1;
+    bufp = is_.src_buffer + y1 * SCREENWIDTH + x1;
+    screenp = (byte *) is_.dest_buffer + y1 * is_.dest_pitch + x1;
 
     for (y=y1; y<y2; ++y)
     {
         memcpy(screenp, bufp, w);
-        screenp += dest_pitch;
+        screenp += is_.dest_pitch;
         bufp += SCREENWIDTH;
     }
 
     return true;
 }
 
-screen_mode_t mode_scale_1x = {
+const screen_mode_t mode_scale_1x = {
     SCREENWIDTH, SCREENHEIGHT,
     NULL,
     I_Scale1x,
@@ -108,10 +110,10 @@ static boolean I_Scale2x(int x1, int y1, int x2, int y2)
     int x, y;
     int multi_pitch;
 
-    multi_pitch = dest_pitch * 2;
-    bufp = src_buffer + y1 * SCREENWIDTH + x1;
-    screenp = (byte *) dest_buffer + (y1 * dest_pitch + x1) * 2;
-    screenp2 = screenp + dest_pitch;
+    multi_pitch = is_.dest_pitch * 2;
+    bufp = is_.src_buffer + y1 * SCREENWIDTH + x1;
+    screenp = (byte *) is_.dest_buffer + (y1 * is_.dest_pitch + x1) * 2;
+    screenp2 = screenp + is_.dest_pitch;
 
     for (y=y1; y<y2; ++y)
     {
@@ -134,7 +136,7 @@ static boolean I_Scale2x(int x1, int y1, int x2, int y2)
     return true;
 }
 
-screen_mode_t mode_scale_2x = {
+const screen_mode_t mode_scale_2x = {
     SCREENWIDTH * 2, SCREENHEIGHT * 2,
     NULL,
     I_Scale2x,
@@ -149,11 +151,11 @@ static boolean I_Scale3x(int x1, int y1, int x2, int y2)
     int x, y;
     int multi_pitch;
 
-    multi_pitch = dest_pitch * 3;
-    bufp = src_buffer + y1 * SCREENWIDTH + x1;
-    screenp = (byte *) dest_buffer + (y1 * dest_pitch + x1) * 3;
-    screenp2 = screenp + dest_pitch;
-    screenp3 = screenp + dest_pitch * 2;
+    multi_pitch = is_.dest_pitch * 3;
+    bufp = is_.src_buffer + y1 * SCREENWIDTH + x1;
+    screenp = (byte *) is_.dest_buffer + (y1 * is_.dest_pitch + x1) * 3;
+    screenp2 = screenp + is_.dest_pitch;
+    screenp3 = screenp + is_.dest_pitch * 2;
 
     for (y=y1; y<y2; ++y)
     {
@@ -179,7 +181,7 @@ static boolean I_Scale3x(int x1, int y1, int x2, int y2)
     return true;
 }
 
-screen_mode_t mode_scale_3x = {
+const screen_mode_t mode_scale_3x = {
     SCREENWIDTH * 3, SCREENHEIGHT * 3,
     NULL,
     I_Scale3x,
@@ -194,12 +196,12 @@ static boolean I_Scale4x(int x1, int y1, int x2, int y2)
     int x, y;
     int multi_pitch;
 
-    multi_pitch = dest_pitch * 4;
-    bufp = src_buffer + y1 * SCREENWIDTH + x1;
-    screenp = (byte *) dest_buffer + (y1 * dest_pitch + x1) * 4;
-    screenp2 = screenp + dest_pitch;
-    screenp3 = screenp + dest_pitch * 2;
-    screenp4 = screenp + dest_pitch * 3;
+    multi_pitch = is_.dest_pitch * 4;
+    bufp = is_.src_buffer + y1 * SCREENWIDTH + x1;
+    screenp = (byte *) is_.dest_buffer + (y1 * is_.dest_pitch + x1) * 4;
+    screenp2 = screenp + is_.dest_pitch;
+    screenp3 = screenp + is_.dest_pitch * 2;
+    screenp4 = screenp + is_.dest_pitch * 3;
 
     for (y=y1; y<y2; ++y)
     {
@@ -228,7 +230,7 @@ static boolean I_Scale4x(int x1, int y1, int x2, int y2)
     return true;
 }
 
-screen_mode_t mode_scale_4x = {
+const screen_mode_t mode_scale_4x = {
     SCREENWIDTH * 4, SCREENHEIGHT * 4,
     NULL,
     I_Scale4x,
@@ -243,13 +245,13 @@ static boolean I_Scale5x(int x1, int y1, int x2, int y2)
     int x, y;
     int multi_pitch;
 
-    multi_pitch = dest_pitch * 5;
-    bufp = src_buffer + y1 * SCREENWIDTH + x1;
-    screenp = (byte *) dest_buffer + (y1 * dest_pitch + x1) * 5;
-    screenp2 = screenp + dest_pitch;
-    screenp3 = screenp + dest_pitch * 2;
-    screenp4 = screenp + dest_pitch * 3;
-    screenp5 = screenp + dest_pitch * 4;
+    multi_pitch = is_.dest_pitch * 5;
+    bufp = is_.src_buffer + y1 * SCREENWIDTH + x1;
+    screenp = (byte *) is_.dest_buffer + (y1 * is_.dest_pitch + x1) * 5;
+    screenp2 = screenp + is_.dest_pitch;
+    screenp3 = screenp + is_.dest_pitch * 2;
+    screenp4 = screenp + is_.dest_pitch * 3;
+    screenp5 = screenp + is_.dest_pitch * 4;
 
     for (y=y1; y<y2; ++y)
     {
@@ -281,7 +283,7 @@ static boolean I_Scale5x(int x1, int y1, int x2, int y2)
     return true;
 }
 
-screen_mode_t mode_scale_5x = {
+const screen_mode_t mode_scale_5x = {
     SCREENWIDTH * 5, SCREENHEIGHT * 5,
     NULL,
     I_Scale5x,
@@ -360,7 +362,7 @@ static byte *GenerateStretchTable(byte *palette, int pct)
 
 static void I_InitStretchTables(byte *palette)
 {
-    if (stretch_tables[0] != NULL)
+    if (is_.stretch_tables[0] != NULL)
     {
         return;
     }
@@ -368,17 +370,16 @@ static void I_InitStretchTables(byte *palette)
     // We only actually need two lookup tables:
     //
     // mix 0%   =  just write line 1
-    // mix 20%  =  stretch_tables[0]
-    // mix 40%  =  stretch_tables[1]
-    // mix 60%  =  stretch_tables[1] used backwards
-    // mix 80%  =  stretch_tables[0] used backwards
+    // mix 20%  =  is_.stretch_tables[0]
+    // mix 40%  =  is_.stretch_tables[1]
+    // mix 60%  =  is_.stretch_tables[1] used backwards
+    // mix 80%  =  is_.stretch_tables[0] used backwards
     // mix 100% =  just write line 2
 
     printf("I_InitStretchTables: Generating lookup tables..");
-    fflush(stdout);
-    stretch_tables[0] = GenerateStretchTable(palette, 20);
-    printf(".."); fflush(stdout);
-    stretch_tables[1] = GenerateStretchTable(palette, 40);
+    is_.stretch_tables[0] = GenerateStretchTable(palette, 20);
+    printf("..");
+    is_.stretch_tables[1] = GenerateStretchTable(palette, 40);
     puts("");
 }
 
@@ -386,14 +387,13 @@ static void I_InitStretchTables(byte *palette)
 
 static void I_InitSquashTable(byte *palette)
 {
-    if (half_stretch_table != NULL)
+    if (is_.half_stretch_table != NULL)
     {
         return;
     }
 
     printf("I_InitSquashTable: Generating lookup table..");
-    fflush(stdout);
-    half_stretch_table = GenerateStretchTable(palette, 50);
+    is_.half_stretch_table = GenerateStretchTable(palette, 50);
     puts("");
 }
 
@@ -403,23 +403,23 @@ static void I_InitSquashTable(byte *palette)
 
 void I_ResetScaleTables(byte *palette)
 {
-    if (stretch_tables[0] != NULL)
+    if (is_.stretch_tables[0] != NULL)
     {
-        Z_Free(stretch_tables[0]);
-        Z_Free(stretch_tables[1]);
+        Z_Free(is_.stretch_tables[0]);
+        Z_Free(is_.stretch_tables[1]);
 
         printf("I_ResetScaleTables: Regenerating lookup tables..\n");
-        stretch_tables[0] = GenerateStretchTable(palette, 20);
-        stretch_tables[1] = GenerateStretchTable(palette, 40);
+        is_.stretch_tables[0] = GenerateStretchTable(palette, 20);
+        is_.stretch_tables[1] = GenerateStretchTable(palette, 40);
     }
 
-    if (half_stretch_table != NULL)
+    if (is_.half_stretch_table != NULL)
     {
-        Z_Free(half_stretch_table);
+        Z_Free(is_.half_stretch_table);
 
         printf("I_ResetScaleTables: Regenerating lookup table..\n");
 
-        half_stretch_table = GenerateStretchTable(palette, 50);
+        is_.half_stretch_table = GenerateStretchTable(palette, 50);
     }
 }
 
@@ -461,43 +461,43 @@ static boolean I_Stretch1x(int x1, int y1, int x2, int y2)
 
     // Need to byte-copy from buffer into the screen buffer
 
-    bufp = src_buffer + y1 * SCREENWIDTH + x1;
-    screenp = (byte *) dest_buffer + y1 * dest_pitch + x1;
+    bufp = is_.src_buffer + y1 * SCREENWIDTH + x1;
+    screenp = (byte *) is_.dest_buffer + y1 * is_.dest_pitch + x1;
 
-    // For every 5 lines of src_buffer, 6 lines are written to dest_buffer
+    // For every 5 lines of is_.src_buffer, 6 lines are written to is_.dest_buffer
     // (200 -> 240)
 
     for (y=0; y<SCREENHEIGHT; y += 5)
     {
         // 100% line 0
         memcpy(screenp, bufp, SCREENWIDTH);
-        screenp += dest_pitch;
+        screenp += is_.dest_pitch;
 
         // 20% line 0, 80% line 1
-        WriteBlendedLine1x(screenp, bufp, bufp + SCREENWIDTH, stretch_tables[0]);
-        screenp += dest_pitch; bufp += SCREENWIDTH;
+        WriteBlendedLine1x(screenp, bufp, bufp + SCREENWIDTH, is_.stretch_tables[0]);
+        screenp += is_.dest_pitch; bufp += SCREENWIDTH;
 
         // 40% line 1, 60% line 2
-        WriteBlendedLine1x(screenp, bufp, bufp + SCREENWIDTH, stretch_tables[1]);
-        screenp += dest_pitch; bufp += SCREENWIDTH;
+        WriteBlendedLine1x(screenp, bufp, bufp + SCREENWIDTH, is_.stretch_tables[1]);
+        screenp += is_.dest_pitch; bufp += SCREENWIDTH;
 
         // 60% line 2, 40% line 3
-        WriteBlendedLine1x(screenp, bufp + SCREENWIDTH, bufp, stretch_tables[1]);
-        screenp += dest_pitch; bufp += SCREENWIDTH;
+        WriteBlendedLine1x(screenp, bufp + SCREENWIDTH, bufp, is_.stretch_tables[1]);
+        screenp += is_.dest_pitch; bufp += SCREENWIDTH;
 
         // 80% line 3, 20% line 4
-        WriteBlendedLine1x(screenp, bufp + SCREENWIDTH, bufp, stretch_tables[0]);
-        screenp += dest_pitch; bufp += SCREENWIDTH;
+        WriteBlendedLine1x(screenp, bufp + SCREENWIDTH, bufp, is_.stretch_tables[0]);
+        screenp += is_.dest_pitch; bufp += SCREENWIDTH;
 
         // 100% line 4
         memcpy(screenp, bufp, SCREENWIDTH);
-        screenp += dest_pitch; bufp += SCREENWIDTH;
+        screenp += is_.dest_pitch; bufp += SCREENWIDTH;
     }
 
     return true;
 }
 
-screen_mode_t mode_stretch_1x = {
+const screen_mode_t mode_stretch_1x = {
     SCREENWIDTH, SCREENHEIGHT_4_3,
     I_InitStretchTables,
     I_Stretch1x,
@@ -550,67 +550,67 @@ static boolean I_Stretch2x(int x1, int y1, int x2, int y2)
 
     // Need to byte-copy from buffer into the screen buffer
 
-    bufp = src_buffer + y1 * SCREENWIDTH + x1;
-    screenp = (byte *) dest_buffer + y1 * dest_pitch + x1;
+    bufp = is_.src_buffer + y1 * SCREENWIDTH + x1;
+    screenp = (byte *) is_.dest_buffer + y1 * is_.dest_pitch + x1;
 
-    // For every 5 lines of src_buffer, 12 lines are written to dest_buffer.
+    // For every 5 lines of is_.src_buffer, 12 lines are written to is_.dest_buffer.
     // (200 -> 480)
 
     for (y=0; y<SCREENHEIGHT; y += 5)
     {
         // 100% line 0
         WriteLine2x(screenp, bufp);
-        screenp += dest_pitch;
+        screenp += is_.dest_pitch;
 
         // 100% line 0
         WriteLine2x(screenp, bufp);
-        screenp += dest_pitch;
+        screenp += is_.dest_pitch;
 
         // 40% line 0, 60% line 1
-        WriteBlendedLine2x(screenp, bufp, bufp + SCREENWIDTH, stretch_tables[1]);
-        screenp += dest_pitch; bufp += SCREENWIDTH;
+        WriteBlendedLine2x(screenp, bufp, bufp + SCREENWIDTH, is_.stretch_tables[1]);
+        screenp += is_.dest_pitch; bufp += SCREENWIDTH;
 
         // 100% line 1
         WriteLine2x(screenp, bufp);
-        screenp += dest_pitch;
+        screenp += is_.dest_pitch;
 
         // 80% line 1, 20% line 2
-        WriteBlendedLine2x(screenp, bufp + SCREENWIDTH, bufp, stretch_tables[0]);
-        screenp += dest_pitch; bufp += SCREENWIDTH;
+        WriteBlendedLine2x(screenp, bufp + SCREENWIDTH, bufp, is_.stretch_tables[0]);
+        screenp += is_.dest_pitch; bufp += SCREENWIDTH;
 
         // 100% line 2
         WriteLine2x(screenp, bufp);
-        screenp += dest_pitch;
+        screenp += is_.dest_pitch;
 
         // 100% line 2
         WriteLine2x(screenp, bufp);
-        screenp += dest_pitch;
+        screenp += is_.dest_pitch;
 
         // 20% line 2, 80% line 3
-        WriteBlendedLine2x(screenp, bufp, bufp + SCREENWIDTH, stretch_tables[0]);
-        screenp += dest_pitch; bufp += SCREENWIDTH;
+        WriteBlendedLine2x(screenp, bufp, bufp + SCREENWIDTH, is_.stretch_tables[0]);
+        screenp += is_.dest_pitch; bufp += SCREENWIDTH;
 
         // 100% line 3
         WriteLine2x(screenp, bufp);
-        screenp += dest_pitch;
+        screenp += is_.dest_pitch;
 
         // 60% line 3, 40% line 4
-        WriteBlendedLine2x(screenp, bufp + SCREENWIDTH, bufp, stretch_tables[1]);
-        screenp += dest_pitch; bufp += SCREENWIDTH;
+        WriteBlendedLine2x(screenp, bufp + SCREENWIDTH, bufp, is_.stretch_tables[1]);
+        screenp += is_.dest_pitch; bufp += SCREENWIDTH;
 
         // 100% line 4
         WriteLine2x(screenp, bufp);
-        screenp += dest_pitch;
+        screenp += is_.dest_pitch;
 
         // 100% line 4
         WriteLine2x(screenp, bufp);
-        screenp += dest_pitch; bufp += SCREENWIDTH;
+        screenp += is_.dest_pitch; bufp += SCREENWIDTH;
     }
 
     return true;
 }
 
-screen_mode_t mode_stretch_2x = {
+const screen_mode_t mode_stretch_2x = {
     SCREENWIDTH * 2, SCREENHEIGHT_4_3 * 2,
     I_InitStretchTables,
     I_Stretch2x,
@@ -665,91 +665,91 @@ static boolean I_Stretch3x(int x1, int y1, int x2, int y2)
 
     // Need to byte-copy from buffer into the screen buffer
 
-    bufp = src_buffer + y1 * SCREENWIDTH + x1;
-    screenp = (byte *) dest_buffer + y1 * dest_pitch + x1;
+    bufp = is_.src_buffer + y1 * SCREENWIDTH + x1;
+    screenp = (byte *) is_.dest_buffer + y1 * is_.dest_pitch + x1;
 
-    // For every 5 lines of src_buffer, 18 lines are written to dest_buffer.
+    // For every 5 lines of is_.src_buffer, 18 lines are written to is_.dest_buffer.
     // (200 -> 720)
 
     for (y=0; y<SCREENHEIGHT; y += 5)
     {
         // 100% line 0
         WriteLine3x(screenp, bufp);
-        screenp += dest_pitch;
+        screenp += is_.dest_pitch;
 
         // 100% line 0
         WriteLine3x(screenp, bufp);
-        screenp += dest_pitch;
+        screenp += is_.dest_pitch;
 
         // 100% line 0
         WriteLine3x(screenp, bufp);
-        screenp += dest_pitch;
+        screenp += is_.dest_pitch;
 
         // 60% line 0, 40% line 1
-        WriteBlendedLine3x(screenp, bufp + SCREENWIDTH, bufp, stretch_tables[1]);
-        screenp += dest_pitch; bufp += SCREENWIDTH;
+        WriteBlendedLine3x(screenp, bufp + SCREENWIDTH, bufp, is_.stretch_tables[1]);
+        screenp += is_.dest_pitch; bufp += SCREENWIDTH;
 
         // 100% line 1
         WriteLine3x(screenp, bufp);
-        screenp += dest_pitch;
+        screenp += is_.dest_pitch;
 
         // 100% line 1
         WriteLine3x(screenp, bufp);
-        screenp += dest_pitch;
+        screenp += is_.dest_pitch;
 
         // 100% line 1
         WriteLine3x(screenp, bufp);
-        screenp += dest_pitch;
+        screenp += is_.dest_pitch;
 
         // 20% line 1, 80% line 2
-        WriteBlendedLine3x(screenp, bufp, bufp + SCREENWIDTH, stretch_tables[0]);
-        screenp += dest_pitch; bufp += SCREENWIDTH;
+        WriteBlendedLine3x(screenp, bufp, bufp + SCREENWIDTH, is_.stretch_tables[0]);
+        screenp += is_.dest_pitch; bufp += SCREENWIDTH;
 
         // 100% line 2
         WriteLine3x(screenp, bufp);
-        screenp += dest_pitch;
+        screenp += is_.dest_pitch;
 
         // 100% line 2
         WriteLine3x(screenp, bufp);
-        screenp += dest_pitch;
+        screenp += is_.dest_pitch;
 
         // 80% line 2, 20% line 3
-        WriteBlendedLine3x(screenp, bufp + SCREENWIDTH, bufp, stretch_tables[0]);
-        screenp += dest_pitch; bufp += SCREENWIDTH;
+        WriteBlendedLine3x(screenp, bufp + SCREENWIDTH, bufp, is_.stretch_tables[0]);
+        screenp += is_.dest_pitch; bufp += SCREENWIDTH;
 
         // 100% line 3
         WriteLine3x(screenp, bufp);
-        screenp += dest_pitch;
+        screenp += is_.dest_pitch;
 
         // 100% line 3
         WriteLine3x(screenp, bufp);
-        screenp += dest_pitch;
+        screenp += is_.dest_pitch;
 
         // 100% line 3
         WriteLine3x(screenp, bufp);
-        screenp += dest_pitch;
+        screenp += is_.dest_pitch;
 
         // 40% line 3, 60% line 4
-        WriteBlendedLine3x(screenp, bufp, bufp + SCREENWIDTH, stretch_tables[1]);
-        screenp += dest_pitch; bufp += SCREENWIDTH;
+        WriteBlendedLine3x(screenp, bufp, bufp + SCREENWIDTH, is_.stretch_tables[1]);
+        screenp += is_.dest_pitch; bufp += SCREENWIDTH;
 
         // 100% line 4
         WriteLine3x(screenp, bufp);
-        screenp += dest_pitch;
+        screenp += is_.dest_pitch;
 
         // 100% line 4
         WriteLine3x(screenp, bufp);
-        screenp += dest_pitch;
+        screenp += is_.dest_pitch;
 
         // 100% line 4
         WriteLine3x(screenp, bufp);
-        screenp += dest_pitch; bufp += SCREENWIDTH;
+        screenp += is_.dest_pitch; bufp += SCREENWIDTH;
     }
 
     return true;
 }
 
-screen_mode_t mode_stretch_3x = {
+const screen_mode_t mode_stretch_3x = {
     SCREENWIDTH * 3, SCREENHEIGHT_4_3 * 3,
     I_InitStretchTables,
     I_Stretch3x,
@@ -806,115 +806,115 @@ static boolean I_Stretch4x(int x1, int y1, int x2, int y2)
 
     // Need to byte-copy from buffer into the screen buffer
 
-    bufp = src_buffer + y1 * SCREENWIDTH + x1;
-    screenp = (byte *) dest_buffer + y1 * dest_pitch + x1;
+    bufp = is_.src_buffer + y1 * SCREENWIDTH + x1;
+    screenp = (byte *) is_.dest_buffer + y1 * is_.dest_pitch + x1;
 
-    // For every 5 lines of src_buffer, 24 lines are written to dest_buffer.
+    // For every 5 lines of is_.src_buffer, 24 lines are written to is_.dest_buffer.
     // (200 -> 960)
 
     for (y=0; y<SCREENHEIGHT; y += 5)
     {
         // 100% line 0
         WriteLine4x(screenp, bufp);
-        screenp += dest_pitch;
+        screenp += is_.dest_pitch;
 
         // 100% line 0
         WriteLine4x(screenp, bufp);
-        screenp += dest_pitch;
+        screenp += is_.dest_pitch;
 
         // 100% line 0
         WriteLine4x(screenp, bufp);
-        screenp += dest_pitch;
+        screenp += is_.dest_pitch;
 
         // 100% line 0
         WriteLine4x(screenp, bufp);
-        screenp += dest_pitch;
+        screenp += is_.dest_pitch;
 
         // 90% line 0, 20% line 1
-        WriteBlendedLine4x(screenp, bufp + SCREENWIDTH, bufp, stretch_tables[0]);
-        screenp += dest_pitch; bufp += SCREENWIDTH;
+        WriteBlendedLine4x(screenp, bufp + SCREENWIDTH, bufp, is_.stretch_tables[0]);
+        screenp += is_.dest_pitch; bufp += SCREENWIDTH;
 
         // 100% line 1
         WriteLine4x(screenp, bufp);
-        screenp += dest_pitch;
+        screenp += is_.dest_pitch;
 
         // 100% line 1
         WriteLine4x(screenp, bufp);
-        screenp += dest_pitch;
+        screenp += is_.dest_pitch;
 
         // 100% line 1
         WriteLine4x(screenp, bufp);
-        screenp += dest_pitch;
+        screenp += is_.dest_pitch;
 
         // 100% line 1
         WriteLine4x(screenp, bufp);
-        screenp += dest_pitch;
+        screenp += is_.dest_pitch;
 
         // 60% line 1, 40% line 2
-        WriteBlendedLine4x(screenp, bufp + SCREENWIDTH, bufp, stretch_tables[1]);
-        screenp += dest_pitch; bufp += SCREENWIDTH;
+        WriteBlendedLine4x(screenp, bufp + SCREENWIDTH, bufp, is_.stretch_tables[1]);
+        screenp += is_.dest_pitch; bufp += SCREENWIDTH;
 
         // 100% line 2
         WriteLine4x(screenp, bufp);
-        screenp += dest_pitch;
+        screenp += is_.dest_pitch;
 
         // 100% line 2
         WriteLine4x(screenp, bufp);
-        screenp += dest_pitch;
+        screenp += is_.dest_pitch;
 
         // 100% line 2
         WriteLine4x(screenp, bufp);
-        screenp += dest_pitch;
+        screenp += is_.dest_pitch;
 
         // 100% line 2
         WriteLine4x(screenp, bufp);
-        screenp += dest_pitch;
+        screenp += is_.dest_pitch;
 
         // 40% line 2, 60% line 3
-        WriteBlendedLine4x(screenp, bufp, bufp + SCREENWIDTH, stretch_tables[1]);
-        screenp += dest_pitch; bufp += SCREENWIDTH;
+        WriteBlendedLine4x(screenp, bufp, bufp + SCREENWIDTH, is_.stretch_tables[1]);
+        screenp += is_.dest_pitch; bufp += SCREENWIDTH;
 
         // 100% line 3
         WriteLine4x(screenp, bufp);
-        screenp += dest_pitch;
+        screenp += is_.dest_pitch;
 
         // 100% line 3
         WriteLine4x(screenp, bufp);
-        screenp += dest_pitch;
+        screenp += is_.dest_pitch;
 
         // 100% line 3
         WriteLine4x(screenp, bufp);
-        screenp += dest_pitch;
+        screenp += is_.dest_pitch;
 
         // 100% line 3
         WriteLine4x(screenp, bufp);
-        screenp += dest_pitch;
+        screenp += is_.dest_pitch;
 
         // 20% line 3, 80% line 4
-        WriteBlendedLine4x(screenp, bufp, bufp + SCREENWIDTH, stretch_tables[0]);
-        screenp += dest_pitch; bufp += SCREENWIDTH;
+        WriteBlendedLine4x(screenp, bufp, bufp + SCREENWIDTH, is_.stretch_tables[0]);
+        screenp += is_.dest_pitch; bufp += SCREENWIDTH;
 
         // 100% line 4
         WriteLine4x(screenp, bufp);
-        screenp += dest_pitch;
+        screenp += is_.dest_pitch;
 
         // 100% line 4
         WriteLine4x(screenp, bufp);
-        screenp += dest_pitch;
+        screenp += is_.dest_pitch;
 
         // 100% line 4
         WriteLine4x(screenp, bufp);
-        screenp += dest_pitch;
+        screenp += is_.dest_pitch;
 
         // 100% line 4
         WriteLine4x(screenp, bufp);
-        screenp += dest_pitch; bufp += SCREENWIDTH;
+        screenp += is_.dest_pitch; bufp += SCREENWIDTH;
     }
 
     return true;
 }
 
-screen_mode_t mode_stretch_4x = {
+const screen_mode_t mode_stretch_4x = {
     SCREENWIDTH * 4, SCREENHEIGHT_4_3 * 4,
     I_InitStretchTables,
     I_Stretch4x,
@@ -953,37 +953,37 @@ static boolean I_Stretch5x(int x1, int y1, int x2, int y2)
 
     // Need to byte-copy from buffer into the screen buffer
 
-    bufp = src_buffer + y1 * SCREENWIDTH + x1;
-    screenp = (byte *) dest_buffer + y1 * dest_pitch + x1;
+    bufp = is_.src_buffer + y1 * SCREENWIDTH + x1;
+    screenp = (byte *) is_.dest_buffer + y1 * is_.dest_pitch + x1;
 
-    // For every 1 line of src_buffer, 6 lines are written to dest_buffer.
+    // For every 1 line of is_.src_buffer, 6 lines are written to is_.dest_buffer.
     // (200 -> 1200)
 
     for (y=0; y<SCREENHEIGHT; y += 1)
     {
         // 100% line 0
         WriteLine5x(screenp, bufp);
-        screenp += dest_pitch;
+        screenp += is_.dest_pitch;
 
         // 100% line 0
         WriteLine5x(screenp, bufp);
-        screenp += dest_pitch;
+        screenp += is_.dest_pitch;
 
         // 100% line 0
         WriteLine5x(screenp, bufp);
-        screenp += dest_pitch;
+        screenp += is_.dest_pitch;
 
         // 100% line 0
         WriteLine5x(screenp, bufp);
-        screenp += dest_pitch;
+        screenp += is_.dest_pitch;
 
         // 100% line 0
         WriteLine5x(screenp, bufp);
-        screenp += dest_pitch;
+        screenp += is_.dest_pitch;
 
         // 100% line 0
         WriteLine5x(screenp, bufp);
-        screenp += dest_pitch; bufp += SCREENWIDTH;
+        screenp += is_.dest_pitch; bufp += SCREENWIDTH;
     }
 
     // test hack for Porsche Monty... scan line simulation:
@@ -991,20 +991,20 @@ static boolean I_Stretch5x(int x1, int y1, int x2, int y2)
 
     if (M_CheckParm("-scanline") > 0)
     {
-        screenp = (byte *) dest_buffer + 2 * dest_pitch;
+        screenp = (byte *) is_.dest_buffer + 2 * is_.dest_pitch;
 
         for (y=0; y<1198; y += 3)
         {
             memset(screenp, 0, 1600);
 
-            screenp += dest_pitch * 3;
+            screenp += is_.dest_pitch * 3;
         }
     }
 
     return true;
 }
 
-screen_mode_t mode_stretch_5x = {
+const screen_mode_t mode_stretch_5x = {
     SCREENWIDTH * 5, SCREENHEIGHT_4_3 * 5,
     I_InitStretchTables,
     I_Stretch5x,
@@ -1037,19 +1037,19 @@ static inline void WriteSquashedLine1x(byte *dest, byte *src)
 
         // 80% pixel 0,   20% pixel 1
 
-        *dest++ = stretch_tables[0][src[1] * 256 + src[0]];
+        *dest++ = is_.stretch_tables[0][src[1] * 256 + src[0]];
 
         // 60% pixel 1,   40% pixel 2
 
-        *dest++ = stretch_tables[1][src[2] * 256 + src[1]];
+        *dest++ = is_.stretch_tables[1][src[2] * 256 + src[1]];
 
         // 40% pixel 2,   60% pixel 3
 
-        *dest++ = stretch_tables[1][src[2] * 256 + src[3]];
+        *dest++ = is_.stretch_tables[1][src[2] * 256 + src[3]];
 
         // 20% pixel 3,   80% pixel 4
 
-        *dest++ = stretch_tables[0][src[3] * 256 + src[4]];
+        *dest++ = is_.stretch_tables[0][src[3] * 256 + src[4]];
 
         x += 5;
         src += 5;
@@ -1070,21 +1070,21 @@ static boolean I_Squash1x(int x1, int y1, int x2, int y2)
         return false;
     }    
 
-    bufp = src_buffer;
-    screenp = (byte *) dest_buffer;
+    bufp = is_.src_buffer;
+    screenp = (byte *) is_.dest_buffer;
 
     for (y=0; y<SCREENHEIGHT; ++y) 
     {
         WriteSquashedLine1x(screenp, bufp);
 
-        screenp += dest_pitch;
+        screenp += is_.dest_pitch;
         bufp += SCREENWIDTH;
     }
 
     return true;
 }
 
-screen_mode_t mode_squash_1x = {
+const screen_mode_t mode_squash_1x = {
     SCREENWIDTH_4_3, SCREENHEIGHT,
     I_InitStretchTables,
     I_Squash1x,
@@ -1104,7 +1104,7 @@ static inline void WriteSquashedLine2x(byte *dest, byte *src)
     byte *dest2;
     int x, c;
 
-    dest2 = dest + dest_pitch;
+    dest2 = dest + is_.dest_pitch;
 
     for (x=0; x<SCREENWIDTH; )
     {
@@ -1117,7 +1117,7 @@ static inline void WriteSquashedLine2x(byte *dest, byte *src)
 
         // 60% pixel 0, 40% pixel 1
 
-        c = stretch_tables[1][src[1] * 256 + src[0]];
+        c = is_.stretch_tables[1][src[1] * 256 + src[0]];
         DRAW_PIXEL2;
 
         // 100% pixel 1
@@ -1127,12 +1127,12 @@ static inline void WriteSquashedLine2x(byte *dest, byte *src)
 
         // 20% pixel 1, 80% pixel 2
 
-        c = stretch_tables[0][src[1] * 256 + src[2]];
+        c = is_.stretch_tables[0][src[1] * 256 + src[2]];
         DRAW_PIXEL2;
 
         // 80% pixel 2, 20% pixel 3
 
-        c = stretch_tables[0][src[3] * 256 + src[2]];
+        c = is_.stretch_tables[0][src[3] * 256 + src[2]];
         DRAW_PIXEL2;
 
         // 100% pixel 3
@@ -1142,7 +1142,7 @@ static inline void WriteSquashedLine2x(byte *dest, byte *src)
 
         // 40% pixel 3, 60% pixel 4
 
-        c = stretch_tables[1][src[3] * 256 + src[4]];
+        c = is_.stretch_tables[1][src[3] * 256 + src[4]];
         DRAW_PIXEL2;
 
         // 100% pixel 4
@@ -1169,21 +1169,21 @@ static boolean I_Squash2x(int x1, int y1, int x2, int y2)
         return false;
     }    
 
-    bufp = src_buffer;
-    screenp = (byte *) dest_buffer;
+    bufp = is_.src_buffer;
+    screenp = (byte *) is_.dest_buffer;
 
     for (y=0; y<SCREENHEIGHT; ++y) 
     {
         WriteSquashedLine2x(screenp, bufp);
 
-        screenp += dest_pitch * 2;
+        screenp += is_.dest_pitch * 2;
         bufp += SCREENWIDTH;
     }
 
     return true;
 }
 
-screen_mode_t mode_squash_2x = {
+const screen_mode_t mode_squash_2x = {
     SCREENWIDTH_4_3 * 2, SCREENHEIGHT * 2,
     I_InitStretchTables,
     I_Squash2x,
@@ -1199,8 +1199,8 @@ static inline void WriteSquashedLine3x(byte *dest, byte *src)
     byte *dest2, *dest3;
     int x, c;
 
-    dest2 = dest + dest_pitch;
-    dest3 = dest + dest_pitch * 2;
+    dest2 = dest + is_.dest_pitch;
+    dest3 = dest + is_.dest_pitch * 2;
 
     for (x=0; x<SCREENWIDTH; )
     {
@@ -1215,7 +1215,7 @@ static inline void WriteSquashedLine3x(byte *dest, byte *src)
 
         // 50% pixel 0, 50% pixel 1
 
-        c = half_stretch_table[src[0] * 256 + src[1]];
+        c = is_.half_stretch_table[src[0] * 256 + src[1]];
 
         DRAW_PIXEL3;
 
@@ -1235,8 +1235,8 @@ static inline void WriteSquashedLine3x(byte *dest, byte *src)
 //
 // 3x scale squashed (800x600)
 //
-// This is a special case that uses the half_stretch_table (50%) rather
-// than the normal stretch_tables(20,40%), to scale up to 800x600 
+// This is a special case that uses the is_.half_stretch_table (50%) rather
+// than the normal is_.stretch_tables(20,40%), to scale up to 800x600 
 // exactly.
 //
 
@@ -1252,21 +1252,21 @@ static boolean I_Squash3x(int x1, int y1, int x2, int y2)
         return false;
     }    
 
-    bufp = src_buffer;
-    screenp = (byte *) dest_buffer;
+    bufp = is_.src_buffer;
+    screenp = (byte *) is_.dest_buffer;
 
     for (y=0; y<SCREENHEIGHT; ++y) 
     {
         WriteSquashedLine3x(screenp, bufp);
 
-        screenp += dest_pitch * 3;
+        screenp += is_.dest_pitch * 3;
         bufp += SCREENWIDTH;
     }
 
     return true;
 }
 
-screen_mode_t mode_squash_3x = {
+const screen_mode_t mode_squash_3x = {
     800, 600,
     I_InitSquashTable,
     I_Squash3x,
@@ -1282,9 +1282,9 @@ static inline void WriteSquashedLine4x(byte *dest, byte *src)
     int c;
     byte *dest2, *dest3, *dest4;
 
-    dest2 = dest + dest_pitch;
-    dest3 = dest + dest_pitch * 2;
-    dest4 = dest + dest_pitch * 3;
+    dest2 = dest + is_.dest_pitch;
+    dest3 = dest + is_.dest_pitch * 2;
+    dest4 = dest + is_.dest_pitch * 3;
 
     for (x=0; x<SCREENWIDTH; )
     {
@@ -1299,7 +1299,7 @@ static inline void WriteSquashedLine4x(byte *dest, byte *src)
 
         // 20% pixel 0,  80% pixel 1
 
-        c = stretch_tables[0][src[0] * 256 + src[1]];
+        c = is_.stretch_tables[0][src[0] * 256 + src[1]];
         DRAW_PIXEL4;
 
         // 100% pixel 1 x2
@@ -1310,7 +1310,7 @@ static inline void WriteSquashedLine4x(byte *dest, byte *src)
 
         // 40% pixel 1, 60% pixel 2
 
-        c = stretch_tables[1][src[1] * 256 + src[2]];
+        c = is_.stretch_tables[1][src[1] * 256 + src[2]];
         DRAW_PIXEL4;
 
         // 100% pixel 2 x2
@@ -1321,7 +1321,7 @@ static inline void WriteSquashedLine4x(byte *dest, byte *src)
 
         // 60% pixel 2, 40% pixel 3
 
-        c = stretch_tables[1][src[3] * 256 + src[2]];
+        c = is_.stretch_tables[1][src[3] * 256 + src[2]];
         DRAW_PIXEL4;
 
         // 100% pixel 3 x2
@@ -1332,7 +1332,7 @@ static inline void WriteSquashedLine4x(byte *dest, byte *src)
 
         // 80% pixel 3, 20% pixel 4
 
-        c = stretch_tables[0][src[4] * 256 + src[3]];
+        c = is_.stretch_tables[0][src[4] * 256 + src[3]];
         DRAW_PIXEL4;
 
         // 100% pixel 4
@@ -1363,21 +1363,21 @@ static boolean I_Squash4x(int x1, int y1, int x2, int y2)
         return false;
     }    
 
-    bufp = src_buffer;
-    screenp = (byte *) dest_buffer;
+    bufp = is_.src_buffer;
+    screenp = (byte *) is_.dest_buffer;
 
     for (y=0; y<SCREENHEIGHT; ++y) 
     {
         WriteSquashedLine4x(screenp, bufp);
 
-        screenp += dest_pitch * 4;
+        screenp += is_.dest_pitch * 4;
         bufp += SCREENWIDTH;
     }
 
     return true;
 }
 
-screen_mode_t mode_squash_4x = {
+const screen_mode_t mode_squash_4x = {
     SCREENWIDTH_4_3 * 4, SCREENHEIGHT * 4,
     I_InitStretchTables,
     I_Squash4x,
@@ -1393,10 +1393,10 @@ static inline void WriteSquashedLine5x(byte *dest, byte *src)
     int c;
     byte *dest2, *dest3, *dest4, *dest5;
 
-    dest2 = dest + dest_pitch;
-    dest3 = dest + dest_pitch * 2;
-    dest4 = dest + dest_pitch * 3;
-    dest5 = dest + dest_pitch * 4;
+    dest2 = dest + is_.dest_pitch;
+    dest3 = dest + is_.dest_pitch * 2;
+    dest4 = dest + is_.dest_pitch * 3;
+    dest5 = dest + is_.dest_pitch * 4;
 
     for (x=0; x<SCREENWIDTH; ++x)
     {
@@ -1428,21 +1428,21 @@ static boolean I_Squash5x(int x1, int y1, int x2, int y2)
         return false;
     }    
 
-    bufp = src_buffer;
-    screenp = (byte *) dest_buffer;
+    bufp = is_.src_buffer;
+    screenp = (byte *) is_.dest_buffer;
 
     for (y=0; y<SCREENHEIGHT; ++y) 
     {
         WriteSquashedLine5x(screenp, bufp);
 
-        screenp += dest_pitch * 5;
+        screenp += is_.dest_pitch * 5;
         bufp += SCREENWIDTH;
     }
 
     return true;
 }
 
-screen_mode_t mode_squash_5x = {
+const screen_mode_t mode_squash_5x = {
     SCREENWIDTH_4_3 * 5, SCREENHEIGHT * 5,
     I_InitStretchTables,
     I_Squash5x,
@@ -1450,3 +1450,96 @@ screen_mode_t mode_squash_5x = {
 };
 
 
+//
+// 0.75x squashed (240x150)
+// 
+static inline void WriteSquashedBlendedLine075x(byte *dest, byte *src1, byte *src2, byte *line_table, boolean rev)
+{
+    int x;
+    for (x=0; x<SCREENWIDTH; x+=4) {
+        // both lines: blend first pixel 60/40 with next
+        byte p1 = is_.stretch_tables[1][*(src1+1) * 256 + *src1];
+        byte p2 = is_.stretch_tables[1][*(src2+1) * 256 + *src2];
+        // now blend a pixel across lines
+        *dest = rev ? line_table[p2 * 256 + p1] : line_table[p1 * 256 + p2];
+        src1++;
+        src2++;
+        dest++;
+        // again, but 50/50 blend in X
+        p1 = is_.half_stretch_table[*(src1+1) * 256 + *src1];
+        p2 = is_.half_stretch_table[*(src2+1) * 256 + *src2];
+        *dest = rev ? line_table[p2 * 256 + p1] : line_table[p1 * 256 + p2];
+        src1++;
+        src2++;
+        dest++;
+        // one more time, 40/60 blend in X
+        p1 = is_.stretch_tables[1][*src1 * 256 + *(src1+1)];
+        p2 = is_.stretch_tables[1][*src2 * 256 + *(src2+1)];
+        *dest = rev ? line_table[p2 * 256 + p1] : line_table[p1 * 256 + p2];
+        src1 += 2;
+        src2 += 2;
+        dest++;
+    }
+}
+
+static boolean I_Squash075x(int x1, int y1, int x2, int y2)
+{
+    int y;
+    byte *dest = is_.dest_buffer;
+    byte *src1 = is_.src_buffer;
+    byte *src2 = is_.src_buffer + SCREENWIDTH;
+    // full screen scale only
+    if (x1!=0 || y1!=0 || x2!=SCREENWIDTH || y2!=SCREENHEIGHT) {
+        return false;
+    }
+    for (y=0; y<SCREENHEIGHT; y+=4) {
+        // write three squished & blended lines for each four in source
+        // blended 60/40, then 50/50, then 40/60 between lines
+        WriteSquashedBlendedLine075x(dest, src1, src2, is_.stretch_tables[1], true);
+        src1 += SCREENWIDTH;
+        src2 += SCREENWIDTH;
+        dest += is_.dest_pitch;
+        WriteSquashedBlendedLine075x(dest, src1, src2, is_.half_stretch_table, false);
+        src1 += SCREENWIDTH;
+        src2 += SCREENWIDTH;
+        dest += is_.dest_pitch;
+        WriteSquashedBlendedLine075x(dest, src1, src2, is_.stretch_tables[1], false);
+        src1 += SCREENWIDTH*2;
+        src2 += SCREENWIDTH*2;
+        dest += is_.dest_pitch;
+    }
+    return true;
+}
+
+static void I_InitSquash075Tables(byte *palette)
+{
+    I_InitStretchTables(palette);
+    I_InitSquashTable(palette);
+}
+
+const screen_mode_t mode_squash_075x = {
+    (SCREENWIDTH * 3) / 4, (SCREENHEIGHT * 3) / 4,
+    I_InitSquash075Tables,
+    I_Squash075x,
+    true,
+};
+
+const screen_mode_t *const all_modes[] = {
+    &mode_scale_1x,
+    &mode_scale_2x,
+    &mode_scale_3x,
+    &mode_scale_4x,
+    &mode_scale_5x,
+    &mode_stretch_1x,
+    &mode_stretch_2x,
+    &mode_stretch_3x,
+    &mode_stretch_4x,
+    &mode_stretch_5x,
+    &mode_squash_1x,
+    &mode_squash_2x,
+    &mode_squash_3x,
+    &mode_squash_4x,
+    &mode_squash_5x,
+    &mode_squash_075x,
+    NULL
+};
\ No newline at end of file
diff --git a/doomgeneric/i_scale.h b/doomgeneric/i_scale.h
index 48231f5..5dc02b3 100644
--- a/doomgeneric/i_scale.h
+++ b/doomgeneric/i_scale.h
@@ -49,5 +49,10 @@ extern screen_mode_t mode_squash_3x;
 extern screen_mode_t mode_squash_4x;
 extern screen_mode_t mode_squash_5x;
 
+// Utterly squashed modes (240x150 -> x0.75)
+extern screen_mode_t mode_squash_075x;
+
+extern screen_mode_t *all_modes[];
+
 #endif /* #ifndef __I_SCALE__ */
 
diff --git a/doomgeneric/i_sound.c b/doomgeneric/i_sound.c
index 71947d2..3417f2b 100644
--- a/doomgeneric/i_sound.c
+++ b/doomgeneric/i_sound.c
@@ -36,29 +36,29 @@
 
 // Sound sample rate to use for digital output (Hz)
 
-int snd_samplerate = 44100;
+int snd_samplerate;
 
 // Maximum number of bytes to dedicate to allocated sound effects.
 // (Default: 64MB)
 
-int snd_cachesize = 64 * 1024 * 1024;
+int snd_cachesize;
 
 // Config variable that controls the sound buffer size.
 // We default to 28ms (1000 / 35fps = 1 buffer per tic).
 
-int snd_maxslicetime_ms = 28;
+int snd_maxslicetime_ms;
 
 // External command to invoke to play back music.
 
-char *snd_musiccmd = "";
+char *snd_musiccmd;
 
 // Low-level sound and music modules we are using
 
-static sound_module_t *sound_module;
-static music_module_t *music_module;
+sound_module_t *sound_module;
+music_module_t *music_module;
 
-int snd_musicdevice = SNDDEVICE_SB;
-int snd_sfxdevice = SNDDEVICE_SB;
+int snd_musicdevice;
+int snd_sfxdevice;
 
 // Sound modules
 
@@ -89,7 +89,7 @@ static int snd_mport = 0;
 
 // Compiled-in sound modules:
 
-static sound_module_t *sound_modules[] = 
+static const sound_module_t * const sound_modules[] = 
 {
 #ifdef FEATURE_SOUND
     &sound_sdl_module,
@@ -100,7 +100,7 @@ static sound_module_t *sound_modules[] =
 
 // Compiled-in music modules:
 
-static music_module_t *music_modules[] =
+static const music_module_t * const music_modules[] =
 {
 #ifdef FEATURE_SOUND
     &music_sdl_module,
@@ -149,7 +149,7 @@ static void InitSfxModule(boolean use_sfx_prefix)
 
             if (sound_modules[i]->Init(use_sfx_prefix))
             {
-                sound_module = sound_modules[i];
+                sound_module = (sound_module_t *)sound_modules[i];
                 return;
             }
         }
@@ -177,7 +177,7 @@ static void InitMusicModule(void)
 
             if (music_modules[i]->Init())
             {
-                music_module = music_modules[i];
+                music_module = (music_module_t *)music_modules[i];
                 return;
             }
         }
@@ -194,6 +194,13 @@ void I_InitSound(boolean use_sfx_prefix)
 {  
     boolean nosound, nosfx, nomusic;
 
+	snd_samplerate = 44100;
+	snd_cachesize = 64 * 1024 * 1024;
+	snd_maxslicetime_ms = 28;
+	snd_musiccmd = "";
+	snd_sfxdevice = SNDDEVICE_SB;
+	snd_musicdevice = SNDDEVICE_SB;
+
     //!
     // @vanilla
     //
diff --git a/doomgeneric/i_sound.h b/doomgeneric/i_sound.h
index e429e96..7570a28 100644
--- a/doomgeneric/i_sound.h
+++ b/doomgeneric/i_sound.h
@@ -27,6 +27,15 @@
 // SoundFX struct.
 //
 typedef struct sfxinfo_struct	sfxinfo_t;
+typedef struct sfxdata_struct	sfxdata_t;
+struct sfxdata_struct
+{
+	char name[9];
+	int priority;
+	int link_id;
+	int pitch;
+	int volume;
+};
 
 struct sfxinfo_struct
 {
@@ -42,7 +51,7 @@ struct sfxinfo_struct
     int priority;
 
     // referenced sound if a link
-    sfxinfo_t *link;
+    const sfxinfo_t *link;
 
     // pitch if a link
     int pitch;
diff --git a/doomgeneric/i_system.c b/doomgeneric/i_system.c
index 5d00091..33ff9ce 100644
--- a/doomgeneric/i_system.c
+++ b/doomgeneric/i_system.c
@@ -68,7 +68,7 @@ struct atexit_listentry_s
     atexit_listentry_t *next;
 };
 
-static atexit_listentry_t *exit_funcs = NULL;
+atexit_listentry_t *exit_funcs;
 
 void I_AtExit(atexit_func_t func, boolean run_on_error)
 {
@@ -325,7 +325,7 @@ static int ZenityErrorBox(char *message)
     int result;
     char *escaped_message;
     char *errorboxpath;
-    static size_t errorboxpath_size;
+    size_t errorboxpath_size;
 
     if (!ZenityAvailable())
     {
@@ -354,7 +354,7 @@ static int ZenityErrorBox(char *message)
 // I_Error
 //
 
-static boolean already_quitting = false;
+boolean already_quitting;
 
 void I_Error (char *error, ...)
 {
@@ -365,7 +365,6 @@ void I_Error (char *error, ...)
 
     if (already_quitting)
     {
-        fprintf(stderr, "Warning: recursive call to I_Error detected.\n");
 #if ORIGCODE
         exit(-1);
 #endif
@@ -378,10 +377,9 @@ void I_Error (char *error, ...)
     // Message first.
     va_start(argptr, error);
     //fprintf(stderr, "\nError: ");
-    vfprintf(stderr, error, argptr);
-    fprintf(stderr, "\n\n");
+    vprintf(error, argptr);
+    printf("\n\n");
     va_end(argptr);
-    fflush(stderr);
 
     // Write a copy of the message into buffer.
     va_start(argptr, error);
@@ -492,19 +490,18 @@ static const unsigned char mem_dump_win98[DOS_MEM_DUMP_SIZE] = {
   0x9E, 0x0F, 0xC9, 0x00, 0x65, 0x04, 0x70, 0x00, 0x16, 0x00};
 static const unsigned char mem_dump_dosbox[DOS_MEM_DUMP_SIZE] = {
   0x00, 0x00, 0x00, 0xF1, 0x00, 0x00, 0x00, 0x00, 0x07, 0x00};
-static unsigned char mem_dump_custom[DOS_MEM_DUMP_SIZE];
+unsigned char mem_dump_custom[DOS_MEM_DUMP_SIZE];
 
-static const unsigned char *dos_mem_dump = mem_dump_dos622;
+const unsigned char *dos_mem_dump;
+boolean sys_hasrun;
 
 boolean I_GetMemoryValue(unsigned int offset, void *value, int size)
 {
-    static boolean firsttime = true;
-
-    if (firsttime)
+    if (!sys_hasrun)
     {
         int p, i, val;
 
-        firsttime = false;
+        sys_hasrun = true;
         i = 0;
 
         //!
diff --git a/doomgeneric/i_timer.c b/doomgeneric/i_timer.c
index 2d6a7cf..1c978b0 100644
--- a/doomgeneric/i_timer.c
+++ b/doomgeneric/i_timer.c
@@ -31,7 +31,7 @@
 // returns time in 1/35th second tics
 //
 
-static uint32_t basetime = 0;
+uint32_t it_basetime = 0;
 
 
 int I_GetTicks(void)
@@ -45,10 +45,10 @@ int  I_GetTime (void)
 
     ticks = I_GetTicks();
 
-    if (basetime == 0)
-        basetime = ticks;
+    if (it_basetime == 0)
+        it_basetime = ticks;
 
-    ticks -= basetime;
+    ticks -= it_basetime;
 
     return (ticks * TICRATE) / 1000;    
 }
@@ -64,10 +64,10 @@ int I_GetTimeMS(void)
 
     ticks = I_GetTicks();
 
-    if (basetime == 0)
-        basetime = ticks;
+    if (it_basetime == 0)
+        it_basetime = ticks;
 
-    return ticks - basetime;
+    return ticks - it_basetime;
 }
 
 // Sleep for a specified number of ms
diff --git a/doomgeneric/i_video.c b/doomgeneric/i_video.c
index bf63035..78fddf2 100644
--- a/doomgeneric/i_video.c
+++ b/doomgeneric/i_video.c
@@ -22,8 +22,10 @@
 //
 //-----------------------------------------------------------------------------
 
+#if 0
 static const char
 rcsid[] = "$Id: i_x.c,v 1.6 1997/02/03 22:45:10 b1 Exp $";
+#endif
 
 #include "config.h"
 #include "v_video.h"
@@ -31,7 +33,9 @@ rcsid[] = "$Id: i_x.c,v 1.6 1997/02/03 22:45:10 b1 Exp $";
 #include "d_event.h"
 #include "d_main.h"
 #include "i_video.h"
+#include "i_scale.h"
 #include "z_zone.h"
+#include "w_wad.h"
 
 #include "tables.h"
 #include "doomkeys.h"
@@ -48,7 +52,7 @@ rcsid[] = "$Id: i_x.c,v 1.6 1997/02/03 22:45:10 b1 Exp $";
 #include <sys/types.h>
 
 //#define CMAP256
-
+#ifdef FBDOOM
 struct FB_BitField
 {
 	uint32_t offset;			/* beginning of bitfield	*/
@@ -72,27 +76,24 @@ struct FB_ScreenInfo
 };
 
 static struct FB_ScreenInfo s_Fb;
-int fb_scaling = 1;
-int usemouse = 0;
+int fb_scaling;
 
-struct color {
-    uint32_t b:8;
-    uint32_t g:8;
-    uint32_t r:8;
-    uint32_t a:8;
-};
+#else
+byte *iv_scaled_video;
+int iv_scaler_idx;
+#endif
 
-static struct color colors[256];
+int usemouse;
 
 void I_GetEvent(void);
 
-// The screen buffer; this is modified to draw things to the screen
+// The screen buffer(s); this is modified to draw things to the screen
 
-byte *I_VideoBuffer = NULL;
+byte *I_VideoBuffer;
 
 // If true, game is running as a screensaver
 
-boolean screensaver_mode = false;
+boolean screensaver_mode;
 
 // Flag indicating whether the screen is currently visible:
 // when the screen isnt visible, don't render the screen
@@ -108,12 +109,12 @@ boolean screenvisible;
 // the values exceed the value of mouse_threshold, they are multiplied
 // by mouse_acceleration to increase the speed.
 
-float mouse_acceleration = 2.0;
-int mouse_threshold = 10;
+float mouse_acceleration;
+int mouse_threshold;
 
 // Gamma correction level to use
 
-int usegamma = 0;
+int usegamma;
 
 typedef struct
 {
@@ -122,31 +123,21 @@ typedef struct
 	byte b;
 } col_t;
 
-// Palette converted to RGB565
-
-static uint16_t rgb565_palette[256];
-
-void cmap_to_rgb565(uint16_t * out, uint8_t * in, int in_pixels)
-{
-    int i, j;
-    struct color c;
-    uint16_t r, g, b;
+struct color {
+    uint32_t b:8;
+    uint32_t g:8;
+    uint32_t r:8;
+    uint32_t a:8;
+};
+// ARGB palette
+struct color iv_colors[256];
 
-    for (i = 0; i < in_pixels; i++)
-    {
-        c = colors[*in]; 
-        r = ((uint16_t)(c.r >> 3)) << 11;
-        g = ((uint16_t)(c.g >> 2)) << 5;
-        b = ((uint16_t)(c.b >> 3)) << 0;
-        *out = (r | g | b);
+// Palette converted to RGB565
 
-        in++;
-        for (j = 0; j < fb_scaling; j++) {
-            out++;
-        }
-    }
-}
+uint16_t iv_rgb565_palette[256];
 
+// framebuffer style graphics output..
+#ifdef FBDOOM
 void cmap_to_fb(uint8_t * out, uint8_t * in, int in_pixels)
 {
     int i, j, k;
@@ -177,6 +168,10 @@ void cmap_to_fb(uint8_t * out, uint8_t * in, int in_pixels)
 void I_InitGraphics (void)
 {
     int i;
+    fb_scaling = 1;
+    mouse_acceleration = 2.0;
+    mouse_threshold = 10;
+
 
 	memset(&s_Fb, 0, sizeof(struct FB_ScreenInfo));
 	s_Fb.xres = DOOMGENERIC_RESX;
@@ -196,13 +191,13 @@ void I_InitGraphics (void)
 	s_Fb.transp.offset = 24;
 	
 
-    printf("I_InitGraphics: framebuffer: x_res: %d, y_res: %d, x_virtual: %d, y_virtual: %d, bpp: %d\n",
+    printf("I_InitGraphics: framebuffer: x_res: %lu, y_res: %lu, x_virtual: %lu, y_virtual: %lu, bpp: %lu\n",
             s_Fb.xres, s_Fb.yres, s_Fb.xres_virtual, s_Fb.yres_virtual, s_Fb.bits_per_pixel);
 
-    printf("I_InitGraphics: framebuffer: RGBA: %d%d%d%d, red_off: %d, green_off: %d, blue_off: %d, transp_off: %d\n",
+    printf("I_InitGraphics: framebuffer: RGBA: %lu%lu%lu%lu, red_off: %lu, green_off: %lu, blue_off: %lu, transp_off: %lu\n",
             s_Fb.red.length, s_Fb.green.length, s_Fb.blue.length, s_Fb.transp.length, s_Fb.red.offset, s_Fb.green.offset, s_Fb.blue.offset, s_Fb.transp.offset);
 
-    printf("I_InitGraphics: DOOM screen size: w x h: %d x %d\n", SCREENWIDTH, SCREENHEIGHT);
+    printf("I_InitGraphics: DOOM screen size: w x h: %u x %u\n", SCREENWIDTH, SCREENHEIGHT);
 
 
     i = M_CheckParmWithArgs("-scaling", 1);
@@ -227,40 +222,17 @@ void I_InitGraphics (void)
     I_InitInput();
 }
 
-void I_ShutdownGraphics (void)
-{
-	Z_Free (I_VideoBuffer);
-}
-
-void I_StartFrame (void)
-{
-
-}
-
-void I_StartTic (void)
-{
-	I_GetEvent();
-}
-
-void I_UpdateNoBlit (void)
-{
-}
-
-//
-// I_FinishUpdate
-//
-
 void I_FinishUpdate (void)
 {
     int y;
-    int x_offset, y_offset, x_offset_end;
+    int x_offset, x_offset_end ;//, y_offset;
     unsigned char *line_in, *line_out;
 
     /* Offsets in case FB is bigger than DOOM */
     /* 600 = s_Fb heigt, 200 screenheight */
     /* 600 = s_Fb heigt, 200 screenheight */
     /* 2048 =s_Fb width, 320 screenwidth */
-    y_offset     = (((s_Fb.yres - (SCREENHEIGHT * fb_scaling)) * s_Fb.bits_per_pixel/8)) / 2;
+    //y_offset     = (((s_Fb.yres - (SCREENHEIGHT * fb_scaling)) * s_Fb.bits_per_pixel/8)) / 2;
     x_offset     = (((s_Fb.xres - (SCREENWIDTH  * fb_scaling)) * s_Fb.bits_per_pixel/8)) / 2; // XXX: siglent FB hack: /4 instead of /2, since it seems to handle the resolution in a funny way
     //x_offset     = 0;
     x_offset_end = ((s_Fb.xres - (SCREENWIDTH  * fb_scaling)) * s_Fb.bits_per_pixel/8) - x_offset;
@@ -294,6 +266,88 @@ void I_FinishUpdate (void)
 	DG_DrawFrame();
 }
 
+// TiDAL badge graphics
+#else
+void cmap_to_rgb565(uint16_t * out, uint8_t * in, int in_pixels)
+{
+    int i;
+
+    for (i = 0; i < in_pixels; i++)
+    {
+        *out++ = iv_rgb565_palette[*in];
+    }
+}
+
+void I_InitGraphics()
+{
+    mouse_acceleration = 2.0;
+    mouse_threshold = 10;
+    int idx;
+    // find a screen mode that matches..
+    printf("I_InitGraphics: looking for a screen mode to match %dx%d\n", DOOMGENERIC_RESX, DOOMGENERIC_RESY);
+    for (idx=0; all_modes[idx]; idx++) {
+        printf("\tmode %dx%d..\n", all_modes[idx]->width, all_modes[idx]->height);
+        if (DOOMGENERIC_RESX == all_modes[idx]->width && DOOMGENERIC_RESY == all_modes[idx]->height)
+            break;
+    }
+    if (!all_modes[idx]) {
+        printf("I_InitGraphics: FATAL - no mode found\n");
+        exit(0);
+    }
+    printf("I_InitGraphics: using %dx%d\n", all_modes[idx]->width, all_modes[idx]->height);
+    iv_scaler_idx = idx;
+
+	I_VideoBuffer = (byte*)Z_Malloc (SCREENWIDTH * SCREENHEIGHT, PU_STATIC, NULL);  // For DOOM to draw on
+    iv_scaled_video = (byte*)Z_Malloc (DOOMGENERIC_RESX * DOOMGENERIC_RESY, PU_STATIC, NULL);
+	screenvisible = true;
+
+    I_InitScale(I_VideoBuffer, iv_scaled_video, DOOMGENERIC_RESX);
+    if (all_modes[iv_scaler_idx]->InitMode)
+        all_modes[iv_scaler_idx]->InitMode(W_CacheLumpName ("PLAYPAL",PU_CACHE));
+
+    extern int I_InitInput(void);
+    I_InitInput();
+}
+
+void I_FinishUpdate(void)
+{
+    // scale, then translate to RGB565
+    int y;
+    byte *in;
+    uint16_t *out;
+    all_modes[iv_scaler_idx]->DrawScreen(0, 0, SCREENWIDTH, SCREENHEIGHT);
+    for (y=0, in=iv_scaled_video, out=(uint16_t *)DG_ScreenBuffer; y<DOOMGENERIC_RESY; y++) {
+        //cmap_to_rgb565(out, in, DOOMGENERIC_RESX);
+        int x;
+        for (x=0; x<DOOMGENERIC_RESX; x++) {
+            out[x] = iv_rgb565_palette[in[x]];
+        }
+        in += DOOMGENERIC_RESX;
+        out += DOOMGENERIC_RESX;
+    }
+    DG_DrawFrame();
+}
+#endif
+
+void I_ShutdownGraphics (void)
+{
+	Z_Free (I_VideoBuffer);
+}
+
+void I_StartFrame (void)
+{
+
+}
+
+void I_StartTic (void)
+{
+	I_GetEvent();
+}
+
+void I_UpdateNoBlit (void)
+{
+}
+
 //
 // I_ReadScreen
 //
@@ -313,29 +367,26 @@ void I_ReadScreen (byte* scr)
 void I_SetPalette (byte* palette)
 {
 	int i;
-	//col_t* c;
-
-	//for (i = 0; i < 256; i++)
-	//{
-	//	c = (col_t*)palette;
-
-	//	rgb565_palette[i] = GFX_RGB565(gammatable[usegamma][c->r],
-	//								   gammatable[usegamma][c->g],
-	//								   gammatable[usegamma][c->b]);
-
-	//	palette += 3;
-	//}
-    
-
-    /* performance boost:
-     * map to the right pixel format over here! */
-
-    for (i=0; i<256; ++i ) {
-        colors[i].a = 0;
-        colors[i].r = gammatable[usegamma][*palette++];
-        colors[i].g = gammatable[usegamma][*palette++];
-        colors[i].b = gammatable[usegamma][*palette++];
-    }
+	col_t* c;
+
+    // set both RGB565 and ARGB palettes
+    printf("I_SetPalette..\n");
+	for (i = 0; i < 256; i++)
+	{
+		c = (col_t*)palette;
+
+		iv_rgb565_palette[i] = GFX_RGB565(gammatable[usegamma][c->r],
+									   gammatable[usegamma][c->g],
+									   gammatable[usegamma][c->b]);
+
+        iv_colors[i].a = 0;
+        iv_colors[i].r = gammatable[usegamma][*palette++];
+        iv_colors[i].g = gammatable[usegamma][*palette++];
+        iv_colors[i].b = gammatable[usegamma][*palette++];
+	}
+
+    // update tables in scaler
+    I_ResetScaleTables(palette);
 }
 
 // Given an RGB value, find the closest matching palette index.
@@ -353,9 +404,9 @@ int I_GetPaletteIndex (int r, int g, int b)
 
     for (i = 0; i < 256; ++i)
     {
-    	color.r = GFX_RGB565_R(rgb565_palette[i]);
-    	color.g = GFX_RGB565_G(rgb565_palette[i]);
-    	color.b = GFX_RGB565_B(rgb565_palette[i]);
+    	color.r = GFX_RGB565_R(iv_rgb565_palette[i]);
+    	color.g = GFX_RGB565_G(iv_rgb565_palette[i]);
+    	color.b = GFX_RGB565_B(iv_rgb565_palette[i]);
 
         diff = (r - color.r) * (r - color.r)
              + (g - color.g) * (g - color.g)
diff --git a/doomgeneric/i_video.h b/doomgeneric/i_video.h
index 3c7db19..b317229 100644
--- a/doomgeneric/i_video.h
+++ b/doomgeneric/i_video.h
@@ -111,6 +111,8 @@ void I_ReadScreen (byte* scr);
 
 void I_BeginRead (void);
 
+void I_EndRead (void);
+
 void I_SetWindowTitle(char *title);
 
 void I_CheckIsScreensaver(void);
diff --git a/doomgeneric/info.c b/doomgeneric/info.c
index 9389e84..6964690 100644
--- a/doomgeneric/info.c
+++ b/doomgeneric/info.c
@@ -29,7 +29,7 @@
 
 #include "p_mobj.h"
 
-char *sprnames[] = {
+const char * const sprnames[] = {
     "TROO","SHTG","PUNG","PISG","PISF","SHTF","SHT2","CHGG","CHGF","MISG",
     "MISF","SAWG","PLSG","PLSF","BFGG","BFGF","BLUD","PUFF","BAL1","BAL2",
     "PLSS","PLSE","MISL","BFS1","BFE1","BFE2","TFOG","IFOG","PLAY","POSS",
@@ -124,7 +124,7 @@ void A_SpawnFly();
 void A_BrainExplode();
 
 
-state_t	states[NUMSTATES] = {
+const state_t	states[NUMSTATES] = {
     {SPR_TROO,0,-1,{NULL},S_NULL,0,0},	// S_NULL
     {SPR_SHTG,4,0,{A_Light0},S_NULL,0,0},	// S_LIGHTDONE
     {SPR_PUNG,0,1,{A_WeaponReady},S_PUNCH,0,0},	// S_PUNCH
@@ -1095,7 +1095,7 @@ state_t	states[NUMSTATES] = {
 };
 
 
-mobjinfo_t mobjinfo[NUMMOBJTYPES] = {
+const mobjinfo_t mobjinfo[NUMMOBJTYPES] = {
 
     {		// MT_PLAYER
 	-1,		// doomednum
diff --git a/doomgeneric/info.h b/doomgeneric/info.h
index 648b518..2981066 100644
--- a/doomgeneric/info.h
+++ b/doomgeneric/info.h
@@ -1153,8 +1153,8 @@ typedef struct
     int misc2;
 } state_t;
 
-extern state_t	states[NUMSTATES];
-extern char *sprnames[];
+extern  const state_t	states[NUMSTATES];
+extern  const char * const sprnames[];
 
 typedef enum {
     MT_PLAYER,
@@ -1326,6 +1326,6 @@ typedef struct
 
 } mobjinfo_t;
 
-extern mobjinfo_t mobjinfo[NUMMOBJTYPES];
+extern const mobjinfo_t mobjinfo[NUMMOBJTYPES];
 
 #endif
diff --git a/doomgeneric/m_cheat.c b/doomgeneric/m_cheat.c
index 1565f9e..cc445b5 100644
--- a/doomgeneric/m_cheat.c
+++ b/doomgeneric/m_cheat.c
@@ -33,9 +33,10 @@
 //
 int
 cht_CheckCheat
-( cheatseq_t*	cht,
+( const cheatseq_t*	cht,
   char		key )
 {
+#if 0	// TODO:PAA
     // if we make a short sequence on a cheat with parameters, this 
     // will not work in vanilla doom.  behave the same.
 
@@ -74,13 +75,14 @@ cht_CheckCheat
     }
     
     // cheat not matched yet
+#endif
 
     return false;
 }
 
 void
 cht_GetParam
-( cheatseq_t*	cht,
+( const cheatseq_t*	cht,
   char*		buffer )
 {
     memcpy(buffer, cht->parameter_buf, cht->parameter_chars);
diff --git a/doomgeneric/m_cheat.h b/doomgeneric/m_cheat.h
index 6775e70..e078313 100644
--- a/doomgeneric/m_cheat.h
+++ b/doomgeneric/m_cheat.h
@@ -49,13 +49,13 @@ typedef struct
 
 int
 cht_CheckCheat
-( cheatseq_t*		cht,
+( const cheatseq_t*		cht,
   char			key );
 
 
 void
 cht_GetParam
-( cheatseq_t*		cht,
+( const cheatseq_t*		cht,
   char*			buffer );
 
 
diff --git a/doomgeneric/m_config.c b/doomgeneric/m_config.c
index 865e168..89ece14 100644
--- a/doomgeneric/m_config.c
+++ b/doomgeneric/m_config.c
@@ -44,11 +44,6 @@
 
 char *configdir;
 
-// Default filenames for configuration files.
-
-static char *default_main_config;
-static char *default_extra_config;
-
 typedef enum 
 {
     DEFAULT_INT,
@@ -61,7 +56,7 @@ typedef enum
 typedef struct
 {
     // Name of the variable
-    char *name;
+    const char *name;
 
     // Pointer to the location in memory of the variable
     void *location;
@@ -108,7 +103,7 @@ typedef struct
 
 //! @begin_config_file default
 
-static default_t	doom_defaults_list[] =
+static const default_t	doom_defaults_list[] =
 {
     //!
     // Mouse sensitivity.  This value is used to multiply input mouse
@@ -672,16 +667,9 @@ static default_t	doom_defaults_list[] =
     CONFIG_VARIABLE_INT(comport),
 };
 
-static default_collection_t doom_defaults =
-{
-    doom_defaults_list,
-    arrlen(doom_defaults_list),
-    NULL,
-};
-
 //! @begin_config_file extended
 
-static default_t extra_defaults_list[] =
+static const default_t extra_defaults_list[] =
 {
     //!
     // @game heretic hexen strife
@@ -1551,12 +1539,13 @@ static default_t extra_defaults_list[] =
     CONFIG_VARIABLE_KEY(key_multi_msgplayer8),
 };
 
-static default_collection_t extra_defaults =
-{
-    extra_defaults_list,
-    arrlen(extra_defaults_list),
-    NULL,
-};
+struct {
+// Default filenames for configuration files.
+    char *default_main_config;
+    char *default_extra_config;
+    default_collection_t *doom_defaults;
+    default_collection_t *extra_defaults;
+} mc_;
 
 // Search a collection for a variable
 
@@ -1606,10 +1595,10 @@ static const int scantokey[128] =
 };
 
 
-static void SaveDefaultCollection(default_collection_t *collection)
+static void SaveDefaultCollection(const default_collection_t *collection)
 {
 #if ORIGCODE
-    default_t *defaults;
+    const default_t *defaults;
     int i, v;
     FILE *f;
 	
@@ -1835,8 +1824,8 @@ static void LoadDefaultCollection(default_collection_t *collection)
 
 void M_SetConfigFilenames(char *main_config, char *extra_config)
 {
-    default_main_config = main_config;
-    default_extra_config = extra_config;
+    mc_.default_main_config = main_config;
+    mc_.default_extra_config = extra_config;
 }
 
 //
@@ -1845,8 +1834,8 @@ void M_SetConfigFilenames(char *main_config, char *extra_config)
 
 void M_SaveDefaults (void)
 {
-    SaveDefaultCollection(&doom_defaults);
-    SaveDefaultCollection(&extra_defaults);
+    SaveDefaultCollection(mc_.doom_defaults);
+    SaveDefaultCollection(mc_.extra_defaults);
 }
 
 //
@@ -1860,18 +1849,46 @@ void M_SaveDefaultsAlternate(char *main, char *extra)
 
     // Temporarily change the filenames
 
-    orig_main = doom_defaults.filename;
-    orig_extra = extra_defaults.filename;
+    orig_main = mc_.doom_defaults->filename;
+    orig_extra = mc_.extra_defaults->filename;
 
-    doom_defaults.filename = main;
-    extra_defaults.filename = extra;
+    mc_.doom_defaults->filename = main;
+    mc_.extra_defaults->filename = extra;
 
     M_SaveDefaults();
 
     // Restore normal filenames
 
-    doom_defaults.filename = orig_main;
-    extra_defaults.filename = orig_extra;
+    mc_.doom_defaults->filename = orig_main;
+    mc_.extra_defaults->filename = orig_extra;
+}
+
+//
+// M_InitConfig
+//
+struct {
+    default_t defs_list[arrlen(doom_defaults_list)];
+    default_collection_t init_defs;
+    default_t extra_list[arrlen(extra_defaults_list)];
+    default_collection_t extra_init_defs;
+} mci_;
+void M_InitConfig(void)
+{
+	int i;
+	// inital defaults..
+    mci_.init_defs.defaults = mci_.defs_list;
+    mci_.init_defs.numdefaults = arrlen(doom_defaults_list);
+    mci_.init_defs.filename = NULL;
+    for (i=0; i<mci_.init_defs.numdefaults; i++)
+        mci_.defs_list[i] = doom_defaults_list[i];
+    mc_.doom_defaults = &mci_.init_defs;
+
+    mci_.extra_init_defs.defaults = mci_.extra_list;
+    mci_.extra_init_defs.numdefaults = arrlen(extra_defaults_list);
+    mci_.extra_init_defs.filename = NULL;
+    for (i=0; i<mci_.extra_init_defs.numdefaults; i++)
+        mci_.extra_list[i] = extra_defaults_list[i];
+    mc_.extra_defaults = &mci_.extra_init_defs;
 }
 
 //
@@ -1896,16 +1913,16 @@ void M_LoadDefaults (void)
 
     if (i)
     {
-	doom_defaults.filename = myargv[i+1];
-	printf ("	default file: %s\n",doom_defaults.filename);
+	mc_.doom_defaults->filename = myargv[i+1];
+	printf ("	default file: %s\n",mc_.doom_defaults->filename);
     }
     else
     {
-        doom_defaults.filename
-            = M_StringJoin(configdir, default_main_config, NULL);
+        mc_.doom_defaults->filename
+            = M_StringJoin(configdir, mc_.default_main_config, NULL);
     }
 
-    printf("saving config in %s\n", doom_defaults.filename);
+    printf("saving config in %s\n", mc_.doom_defaults->filename);
 
     //!
     // @arg <file>
@@ -1918,18 +1935,18 @@ void M_LoadDefaults (void)
 
     if (i)
     {
-        extra_defaults.filename = myargv[i+1];
+        mc_.extra_defaults->filename = myargv[i+1];
         printf("        extra configuration file: %s\n", 
-               extra_defaults.filename);
+               mc_.extra_defaults->filename);
     }
     else
     {
-        extra_defaults.filename
-            = M_StringJoin(configdir, default_extra_config, NULL);
+        mc_.extra_defaults->filename
+            = M_StringJoin(configdir, mc_.default_extra_config, NULL);
     }
 
-    LoadDefaultCollection(&doom_defaults);
-    LoadDefaultCollection(&extra_defaults);
+    LoadDefaultCollection(mc_.doom_defaults);
+    LoadDefaultCollection(mc_.extra_defaults);
 }
 
 // Get a configuration file variable by its name
@@ -1940,11 +1957,11 @@ static default_t *GetDefaultForName(char *name)
 
     // Try the main list and the extras
 
-    result = SearchCollection(&doom_defaults, name);
+    result = SearchCollection(mc_.doom_defaults, name);
 
     if (result == NULL)
     {
-        result = SearchCollection(&extra_defaults, name);
+        result = SearchCollection(mc_.extra_defaults, name);
     }
 
     // Not found? Internal error.
diff --git a/doomgeneric/m_config.h b/doomgeneric/m_config.h
index a17de2b..3fb37b2 100644
--- a/doomgeneric/m_config.h
+++ b/doomgeneric/m_config.h
@@ -22,6 +22,7 @@
 
 #include "doomtype.h"
 
+void M_InitConfig(void);
 void M_LoadDefaults(void);
 void M_SaveDefaults(void);
 void M_SaveDefaultsAlternate(char *main, char *extra);
diff --git a/doomgeneric/m_controls.c b/doomgeneric/m_controls.c
index f0ffa01..956a97f 100644
--- a/doomgeneric/m_controls.c
+++ b/doomgeneric/m_controls.c
@@ -26,47 +26,47 @@
 // Keyboard controls
 //
 
-int key_right = KEY_RIGHTARROW;
-int key_left = KEY_LEFTARROW;
-int key_up = KEY_UPARROW;
-int key_down = KEY_DOWNARROW; 
-int key_strafeleft = KEY_STRAFE_L;
-int key_straferight = KEY_STRAFE_R;
-int key_fire = KEY_FIRE;
-int key_use = KEY_USE;
-int key_strafe = KEY_RALT;
-int key_speed = KEY_RSHIFT; 
+int key_right;
+int key_left;
+int key_up;
+int key_down;
+int key_strafeleft;
+int key_straferight;
+int key_fire;
+int key_use;
+int key_strafe;
+int key_speed;
 
 // 
 // Heretic keyboard controls
 //
  
-int key_flyup = KEY_PGUP;
-int key_flydown = KEY_INS;
-int key_flycenter = KEY_HOME;
+int key_flyup;
+int key_flydown;
+int key_flycenter;
 
-int key_lookup = KEY_PGDN;
-int key_lookdown = KEY_DEL;
-int key_lookcenter = KEY_END;
+int key_lookup;
+int key_lookdown;
+int key_lookcenter;
 
-int key_invleft = '[';
-int key_invright = ']';
-int key_useartifact = KEY_ENTER;
+int key_invleft;
+int key_invright;
+int key_useartifact;
 
 //
 // Hexen key controls
 //
 
-int key_jump = '/';
+int key_jump;
 
-int key_arti_all             = KEY_BACKSPACE;
-int key_arti_health          = '\\';
-int key_arti_poisonbag       = '0';
-int key_arti_blastradius     = '9';
-int key_arti_teleport        = '8';
-int key_arti_teleportother   = '7';
-int key_arti_egg             = '6';
-int key_arti_invulnerability = '5';
+int key_arti_all;
+int key_arti_health;
+int key_arti_poisonbag;
+int key_arti_blastradius;
+int key_arti_teleport;
+int key_arti_teleportother;
+int key_arti_egg;
+int key_arti_invulnerability;
 
 //
 // Strife key controls
@@ -77,125 +77,125 @@ int key_arti_invulnerability = '5';
 // Note: Strife also uses key_invleft, key_invright, key_jump, key_lookup, and
 // key_lookdown, but with different default values.
 
-int key_usehealth = 'h';
-int key_invquery  = 'q';
-int key_mission   = 'w';
-int key_invpop    = 'z';
-int key_invkey    = 'k';
-int key_invhome   = KEY_HOME;
-int key_invend    = KEY_END;
-int key_invuse    = KEY_ENTER;
-int key_invdrop   = KEY_BACKSPACE;
+int key_usehealth;
+int key_invquery;
+int key_mission;
+int key_invpop;
+int key_invkey;
+int key_invhome;
+int key_invend;
+int key_invuse;
+int key_invdrop;
 
 
 //
 // Mouse controls
 //
 
-int mousebfire = 0;
-int mousebstrafe = 1;
-int mousebforward = 2;
+int mousebfire;
+int mousebstrafe;
+int mousebforward;
 
-int mousebjump = -1;
+int mousebjump;
 
-int mousebstrafeleft = -1;
-int mousebstraferight = -1;
-int mousebbackward = -1;
-int mousebuse = -1;
+int mousebstrafeleft;
+int mousebstraferight;
+int mousebbackward;
+int mousebuse;
 
-int mousebprevweapon = -1;
-int mousebnextweapon = -1;
+int mousebprevweapon;
+int mousebnextweapon;
 
 
-int key_message_refresh = KEY_ENTER;
-int key_pause = KEY_PAUSE;
-int key_demo_quit = 'q';
-int key_spy = KEY_F12;
+int key_message_refresh;
+int key_pause;
+int key_demo_quit;
+int key_spy;
 
 // Multiplayer chat keys:
 
-int key_multi_msg = 't';
+int key_multi_msg;
 int key_multi_msgplayer[8];
 
 // Weapon selection keys:
 
-int key_weapon1 = '1';
-int key_weapon2 = '2';
-int key_weapon3 = '3';
-int key_weapon4 = '4';
-int key_weapon5 = '5';
-int key_weapon6 = '6';
-int key_weapon7 = '7';
-int key_weapon8 = '8';
-int key_prevweapon = 0;
-int key_nextweapon = 0;
+int key_weapon1;
+int key_weapon2;
+int key_weapon3;
+int key_weapon4;
+int key_weapon5;
+int key_weapon6;
+int key_weapon7;
+int key_weapon8;
+int key_prevweapon;
+int key_nextweapon;
 
 // Map control keys:
 
-int key_map_north     = KEY_UPARROW;
-int key_map_south     = KEY_DOWNARROW;
-int key_map_east      = KEY_RIGHTARROW;
-int key_map_west      = KEY_LEFTARROW;
-int key_map_zoomin    = '=';
-int key_map_zoomout   = '-';
-int key_map_toggle    = KEY_TAB;
-int key_map_maxzoom   = '0';
-int key_map_follow    = 'f';
-int key_map_grid      = 'g';
-int key_map_mark      = 'm';
-int key_map_clearmark = 'c';
+int key_map_north;
+int key_map_south;
+int key_map_east;
+int key_map_west;
+int key_map_zoomin;
+int key_map_zoomout;
+int key_map_toggle;
+int key_map_maxzoom;
+int key_map_follow;
+int key_map_grid;
+int key_map_mark;
+int key_map_clearmark;
 
 // menu keys:
 
-int key_menu_activate  = KEY_ESCAPE;
-int key_menu_up        = KEY_UPARROW;
-int key_menu_down      = KEY_DOWNARROW;
-int key_menu_left      = KEY_LEFTARROW;
-int key_menu_right     = KEY_RIGHTARROW;
-int key_menu_back      = KEY_BACKSPACE;
-int key_menu_forward   = KEY_ENTER;
-int key_menu_confirm   = 'y';
-int key_menu_abort     = 'n';
-
-int key_menu_help      = KEY_F1;
-int key_menu_save      = KEY_F2;
-int key_menu_load      = KEY_F3;
-int key_menu_volume    = KEY_F4;
-int key_menu_detail    = KEY_F5;
-int key_menu_qsave     = KEY_F6;
-int key_menu_endgame   = KEY_F7;
-int key_menu_messages  = KEY_F8;
-int key_menu_qload     = KEY_F9;
-int key_menu_quit      = KEY_F10;
-int key_menu_gamma     = KEY_F11;
-
-int key_menu_incscreen = KEY_EQUALS;
-int key_menu_decscreen = KEY_MINUS;
-int key_menu_screenshot = 0;
+int key_menu_activate;
+int key_menu_up;
+int key_menu_down;
+int key_menu_left;
+int key_menu_right;
+int key_menu_back;
+int key_menu_forward;
+int key_menu_confirm;
+int key_menu_abort;
+
+int key_menu_help;
+int key_menu_save;
+int key_menu_load;
+int key_menu_volume;
+int key_menu_detail;
+int key_menu_qsave;
+int key_menu_endgame;
+int key_menu_messages;
+int key_menu_qload;
+int key_menu_quit;
+int key_menu_gamma;
+
+int key_menu_incscreen;
+int key_menu_decscreen;
+int key_menu_screenshot;
 
 //
 // Joystick controls
 //
 
-int joybfire = 0;
-int joybstrafe = 1;
-int joybuse = 3;
-int joybspeed = 2;
+int joybfire;
+int joybstrafe;
+int joybuse;
+int joybspeed;
 
-int joybstrafeleft = -1;
-int joybstraferight = -1;
+int joybstrafeleft;
+int joybstraferight;
 
-int joybjump = -1;
+int joybjump;
 
-int joybprevweapon = -1;
-int joybnextweapon = -1;
+int joybprevweapon;
+int joybnextweapon;
 
-int joybmenu = -1;
+int joybmenu;
 
 // Control whether if a mouse button is double clicked, it acts like 
 // "use" has been pressed
 
-int dclick_use = 1;
+int dclick_use;
  
 // 
 // Bind all of the common controls used by Doom and all other games.
@@ -393,6 +393,176 @@ void M_BindChatControls(unsigned int num_players)
 
 void M_ApplyPlatformDefaults(void)
 {
-    // no-op. Add your platform-specific patches here.
+    key_right = KEY_RIGHTARROW;
+    key_left = KEY_LEFTARROW;
+    key_up = KEY_UPARROW;
+    key_down = KEY_DOWNARROW; 
+    key_strafeleft = KEY_STRAFE_L;
+    key_straferight = KEY_STRAFE_R;
+    key_fire = KEY_FIRE;
+    key_use = KEY_USE;
+    key_strafe = KEY_RALT;
+    key_speed = KEY_RSHIFT; 
+
+// 
+// Heretic keyboard controls
+//
+ 
+    key_flyup = KEY_PGUP;
+    key_flydown = KEY_INS;
+    key_flycenter = KEY_HOME;
+
+    key_lookup = KEY_PGDN;
+    key_lookdown = KEY_DEL;
+    key_lookcenter = KEY_END;
+
+    key_invleft = '[';
+    key_invright = ']';
+    key_useartifact = KEY_ENTER;
+
+//
+// Hexen key controls
+//
+
+    key_jump = '/';
+
+    key_arti_all             = KEY_BACKSPACE;
+    key_arti_health          = '\\';
+    key_arti_poisonbag       = '0';
+    key_arti_blastradius     = '9';
+    key_arti_teleport        = '8';
+    key_arti_teleportother   = '7';
+    key_arti_egg             = '6';
+    key_arti_invulnerability = '5';
+
+//
+// Strife key controls
+//
+// haleyjd 09/01/10
+//
+
+// Note: Strife also uses key_invleft, key_invright, key_jump, key_lookup, and
+// key_lookdown, but with different default values.
+
+    key_usehealth = 'h';
+    key_invquery  = 'q';
+    key_mission   = 'w';
+    key_invpop    = 'z';
+    key_invkey    = 'k';
+    key_invhome   = KEY_HOME;
+    key_invend    = KEY_END;
+    key_invuse    = KEY_ENTER;
+    key_invdrop   = KEY_BACKSPACE;
+
+
+//
+// Mouse controls
+//
+
+    mousebfire = 0;
+    mousebstrafe = 1;
+    mousebforward = 2;
+
+    mousebjump = -1;
+
+    mousebstrafeleft = -1;
+    mousebstraferight = -1;
+    mousebbackward = -1;
+    mousebuse = -1;
+
+    mousebprevweapon = -1;
+    mousebnextweapon = -1;
+
+
+    key_message_refresh = KEY_ENTER;
+    key_pause = KEY_PAUSE;
+    key_demo_quit = 'q';
+    key_spy = KEY_F12;
+
+// Multiplayer chat keys:
+
+    key_multi_msg = 't';
+
+// Weapon selection keys:
+
+    key_weapon1 = '1';
+    key_weapon2 = '2';
+    key_weapon3 = '3';
+    key_weapon4 = '4';
+    key_weapon5 = '5';
+    key_weapon6 = '6';
+    key_weapon7 = '7';
+    key_weapon8 = '8';
+    key_prevweapon = 0;
+    key_nextweapon = 0;
+
+// Map control keys:
+
+    key_map_north     = KEY_UPARROW;
+    key_map_south     = KEY_DOWNARROW;
+    key_map_east      = KEY_RIGHTARROW;
+    key_map_west      = KEY_LEFTARROW;
+    key_map_zoomin    = '=';
+    key_map_zoomout   = '-';
+    key_map_toggle    = KEY_TAB;
+    key_map_maxzoom   = '0';
+    key_map_follow    = 'f';
+    key_map_grid      = 'g';
+    key_map_mark      = 'm';
+    key_map_clearmark = 'c';
+
+// menu keys:
+
+    key_menu_activate  = KEY_ESCAPE;
+    key_menu_up        = KEY_UPARROW;
+    key_menu_down      = KEY_DOWNARROW;
+    key_menu_left      = KEY_LEFTARROW;
+    key_menu_right     = KEY_RIGHTARROW;
+    key_menu_back      = KEY_BACKSPACE;
+    key_menu_forward   = KEY_ENTER;
+    key_menu_confirm   = 'y';
+    key_menu_abort     = 'n';
+
+    key_menu_help      = KEY_F1;
+    key_menu_save      = KEY_F2;
+    key_menu_load      = KEY_F3;
+    key_menu_volume    = KEY_F4;
+    key_menu_detail    = KEY_F5;
+    key_menu_qsave     = KEY_F6;
+    key_menu_endgame   = KEY_F7;
+    key_menu_messages  = KEY_F8;
+    key_menu_qload     = KEY_F9;
+    key_menu_quit      = KEY_F10;
+    key_menu_gamma     = KEY_F11;
+
+    key_menu_incscreen = KEY_EQUALS;
+    key_menu_decscreen = KEY_MINUS;
+    key_menu_screenshot = 0;
+
+//
+// Joystick controls
+//
+
+    joybfire = 0;
+    joybstrafe = 1;
+    joybuse = 3;
+    joybspeed = 2;
+
+    joybstrafeleft = -1;
+    joybstraferight = -1;
+
+    joybjump = -1;
+
+    joybprevweapon = -1;
+    joybnextweapon = -1;
+
+    joybmenu = -1;
+
+// Control whether if a mouse button is double clicked, it acts like 
+// "use" has been pressed
+
+    dclick_use = 1;
+ 
+    // Add your platform-specific patches here.
 }
 
diff --git a/doomgeneric/m_menu.c b/doomgeneric/m_menu.c
index 6df9655..47aa77a 100644
--- a/doomgeneric/m_menu.c
+++ b/doomgeneric/m_menu.c
@@ -67,15 +67,15 @@ extern boolean		chat_on;		// in heads-up code
 //
 // defaulted values
 //
-int			mouseSensitivity = 5;
+int			mouseSensitivity;
 
 // Show messages has default, 0 = off, 1 = on
-int			showMessages = 1;
+int			showMessages;
 	
 
 // Blocky mode, has default, 0 = high, 1 = normal
-int			detailLevel = 0;
-int			screenblocks = 10;
+int			detailLevel;
+int			screenblocks;
 
 // temp for screenblocks (0-9)
 int			screenSize;
@@ -98,7 +98,7 @@ boolean			messageNeedsInput;
 
 void    (*messageRoutine)(int response);
 
-char gammamsg[5][26] =
+const char gammamsg[5][26] =
 {
     GAMMALVL0,
     GAMMALVL1,
@@ -152,7 +152,7 @@ typedef struct menu_s
 {
     short		numitems;	// # of menu items
     struct menu_s*	prevMenu;	// previous menu
-    menuitem_t*		menuitems;	// menu items
+    const menuitem_t*		menuitems;	// menu items
     void		(*routine)();	// draw routine
     short		x;
     short		y;		// x,y of menu
@@ -165,11 +165,24 @@ short		whichSkull;		// which skull to draw
 
 // graphic name of skulls
 // warning: initializer-string for array of chars is too long
-char    *skullName[2] = {"M_SKULL1","M_SKULL2"};
+const char * const skullName[2] = {"M_SKULL1","M_SKULL2"};
 
 // current menudef
 menu_t*	currentMenu;                          
 
+// Mutable menus (after M_Init has run!)
+struct {
+	menu_t MainDef;
+	menu_t EpiDef;
+	menu_t NewDef;
+	menu_t OptionsDef;
+	menu_t ReadDef1;
+	menu_t ReadDef2;
+	menu_t SoundDef;
+	menu_t LoadDef;
+	menu_t SaveDef;
+} mm_;
+
 //
 // PROTOTYPES
 //
@@ -239,7 +252,7 @@ enum
     main_end
 } main_e;
 
-menuitem_t MainMenu[]=
+const menuitem_t MainMenu[]=
 {
     {1,"M_NGAME",M_NewGame,'n'},
     {1,"M_OPTION",M_Options,'o'},
@@ -250,7 +263,7 @@ menuitem_t MainMenu[]=
     {1,"M_QUITG",M_QuitDOOM,'q'}
 };
 
-menu_t  MainDef =
+const menu_t  CMainDef =
 {
     main_end,
     NULL,
@@ -273,7 +286,7 @@ enum
     ep_end
 } episodes_e;
 
-menuitem_t EpisodeMenu[]=
+const menuitem_t EpisodeMenu[]=
 {
     {1,"M_EPI1", M_Episode,'k'},
     {1,"M_EPI2", M_Episode,'t'},
@@ -281,10 +294,10 @@ menuitem_t EpisodeMenu[]=
     {1,"M_EPI4", M_Episode,'t'}
 };
 
-menu_t  EpiDef =
+const menu_t  CEpiDef =
 {
     ep_end,		// # of menu items
-    &MainDef,		// previous menu
+    &mm_.MainDef,		// previous menu
     EpisodeMenu,	// menuitem_t ->
     M_DrawEpisode,	// drawing routine ->
     48,63,              // x,y
@@ -304,7 +317,7 @@ enum
     newg_end
 } newgame_e;
 
-menuitem_t NewGameMenu[]=
+const menuitem_t NewGameMenu[]=
 {
     {1,"M_JKILL",	M_ChooseSkill, 'i'},
     {1,"M_ROUGH",	M_ChooseSkill, 'h'},
@@ -313,10 +326,10 @@ menuitem_t NewGameMenu[]=
     {1,"M_NMARE",	M_ChooseSkill, 'n'}
 };
 
-menu_t  NewDef =
+const menu_t  CNewDef =
 {
     newg_end,		// # of menu items
-    &EpiDef,		// previous menu
+    &mm_.EpiDef,		// previous menu
     NewGameMenu,	// menuitem_t ->
     M_DrawNewGame,	// drawing routine ->
     48,63,              // x,y
@@ -324,7 +337,6 @@ menu_t  NewDef =
 };
 
 
-
 //
 // OPTIONS MENU
 //
@@ -341,7 +353,7 @@ enum
     opt_end
 } options_e;
 
-menuitem_t OptionsMenu[]=
+const menuitem_t OptionsMenu[]=
 {
     {1,"M_ENDGAM",	M_EndGame,'e'},
     {1,"M_MESSG",	M_ChangeMessages,'m'},
@@ -353,10 +365,10 @@ menuitem_t OptionsMenu[]=
     {1,"M_SVOL",	M_Sound,'s'}
 };
 
-menu_t  OptionsDef =
+const menu_t  COptionsDef =
 {
     opt_end,
-    &MainDef,
+    &mm_.MainDef,
     OptionsMenu,
     M_DrawOptions,
     60,37,
@@ -372,15 +384,15 @@ enum
     read1_end
 } read_e;
 
-menuitem_t ReadMenu1[] =
+const menuitem_t ReadMenu1[] =
 {
     {1,"",M_ReadThis2,0}
 };
 
-menu_t  ReadDef1 =
+const menu_t  CReadDef1 =
 {
     read1_end,
-    &MainDef,
+    &mm_.MainDef,
     ReadMenu1,
     M_DrawReadThis1,
     280,185,
@@ -393,15 +405,15 @@ enum
     read2_end
 } read_e2;
 
-menuitem_t ReadMenu2[]=
+const menuitem_t ReadMenu2[]=
 {
     {1,"",M_FinishReadThis,0}
 };
 
-menu_t  ReadDef2 =
+const menu_t  CReadDef2 =
 {
     read2_end,
-    &ReadDef1,
+    &mm_.ReadDef1,
     ReadMenu2,
     M_DrawReadThis2,
     330,175,
@@ -420,7 +432,7 @@ enum
     sound_end
 } sound_e;
 
-menuitem_t SoundMenu[]=
+const menuitem_t SoundMenu[]=
 {
     {2,"M_SFXVOL",M_SfxVol,'s'},
     {-1,"",0,'\0'},
@@ -428,10 +440,10 @@ menuitem_t SoundMenu[]=
     {-1,"",0,'\0'}
 };
 
-menu_t  SoundDef =
+const menu_t  CSoundDef =
 {
     sound_end,
-    &OptionsDef,
+    &mm_.OptionsDef,
     SoundMenu,
     M_DrawSound,
     80,64,
@@ -452,7 +464,7 @@ enum
     load_end
 } load_e;
 
-menuitem_t LoadMenu[]=
+const menuitem_t LoadMenu[]=
 {
     {1,"", M_LoadSelect,'1'},
     {1,"", M_LoadSelect,'2'},
@@ -462,10 +474,10 @@ menuitem_t LoadMenu[]=
     {1,"", M_LoadSelect,'6'}
 };
 
-menu_t  LoadDef =
+const menu_t  CLoadDef =
 {
     load_end,
-    &MainDef,
+    &mm_.MainDef,
     LoadMenu,
     M_DrawLoad,
     80,54,
@@ -475,7 +487,7 @@ menu_t  LoadDef =
 //
 // SAVE GAME MENU
 //
-menuitem_t SaveMenu[]=
+const menuitem_t SaveMenu[]=
 {
     {1,"", M_SaveSelect,'1'},
     {1,"", M_SaveSelect,'2'},
@@ -485,23 +497,23 @@ menuitem_t SaveMenu[]=
     {1,"", M_SaveSelect,'6'}
 };
 
-menu_t  SaveDef =
+const menu_t  CSaveDef =
 {
     load_end,
-    &MainDef,
+    &mm_.MainDef,
     SaveMenu,
     M_DrawSave,
     80,54,
     0
 };
 
-
 //
 // M_ReadSaveStrings
 //  read the strings from the savegame files
 //
 void M_ReadSaveStrings(void)
 {
+/*TODO:PAA
     FILE   *handle;
     int     i;
     char    name[256];
@@ -521,6 +533,7 @@ void M_ReadSaveStrings(void)
 	fclose(handle);
 	LoadMenu[i].status = 1;
     }
+*/
 }
 
 
@@ -536,8 +549,8 @@ void M_DrawLoad(void)
 
     for (i = 0;i < load_end; i++)
     {
-	M_DrawSaveLoadBorder(LoadDef.x,LoadDef.y+LINEHEIGHT*i);
-	M_WriteText(LoadDef.x,LoadDef.y+LINEHEIGHT*i,savegamestrings[i]);
+	M_DrawSaveLoadBorder(mm_.LoadDef.x,mm_.LoadDef.y+LINEHEIGHT*i);
+	M_WriteText(mm_.LoadDef.x,mm_.LoadDef.y+LINEHEIGHT*i,savegamestrings[i]);
     }
 }
 
@@ -590,7 +603,7 @@ void M_LoadGame (int choice)
 	return;
     }
 	
-    M_SetupNextMenu(&LoadDef);
+    M_SetupNextMenu(&mm_.LoadDef);
     M_ReadSaveStrings();
 }
 
@@ -605,14 +618,14 @@ void M_DrawSave(void)
     V_DrawPatchDirect(72, 28, W_CacheLumpName(DEH_String("M_SAVEG"), PU_CACHE));
     for (i = 0;i < load_end; i++)
     {
-	M_DrawSaveLoadBorder(LoadDef.x,LoadDef.y+LINEHEIGHT*i);
-	M_WriteText(LoadDef.x,LoadDef.y+LINEHEIGHT*i,savegamestrings[i]);
+	M_DrawSaveLoadBorder(mm_.LoadDef.x,mm_.LoadDef.y+LINEHEIGHT*i);
+	M_WriteText(mm_.LoadDef.x,mm_.LoadDef.y+LINEHEIGHT*i,savegamestrings[i]);
     }
 	
     if (saveStringEnter)
     {
 	i = M_StringWidth(savegamestrings[saveSlot]);
-	M_WriteText(LoadDef.x + i,LoadDef.y+LINEHEIGHT*saveSlot,"_");
+	M_WriteText(mm_.LoadDef.x + i,mm_.LoadDef.y+LINEHEIGHT*saveSlot,"_");
     }
 }
 
@@ -658,7 +671,7 @@ void M_SaveGame (int choice)
     if (gamestate != GS_LEVEL)
 	return;
 	
-    M_SetupNextMenu(&SaveDef);
+    M_SetupNextMenu(&mm_.SaveDef);
     M_ReadSaveStrings();
 }
 
@@ -693,7 +706,7 @@ void M_QuickSave(void)
     {
 	M_StartControlPanel();
 	M_ReadSaveStrings();
-	M_SetupNextMenu(&SaveDef);
+	M_SetupNextMenu(&mm_.SaveDef);
 	quickSaveSlot = -2;	// means to pick a slot now
 	return;
     }
@@ -808,8 +821,8 @@ void M_DrawReadThis1(void)
     
     V_DrawPatchDirect (0, 0, W_CacheLumpName(lumpname, PU_CACHE));
 
-    ReadDef1.x = skullx;
-    ReadDef1.y = skully;
+    mm_.ReadDef1.x = skullx;
+    mm_.ReadDef1.y = skully;
 }
 
 
@@ -835,16 +848,16 @@ void M_DrawSound(void)
 {
     V_DrawPatchDirect (60, 38, W_CacheLumpName(DEH_String("M_SVOL"), PU_CACHE));
 
-    M_DrawThermo(SoundDef.x,SoundDef.y+LINEHEIGHT*(sfx_vol+1),
+    M_DrawThermo(mm_.SoundDef.x,mm_.SoundDef.y+LINEHEIGHT*(sfx_vol+1),
 		 16,sfxVolume);
 
-    M_DrawThermo(SoundDef.x,SoundDef.y+LINEHEIGHT*(music_vol+1),
+    M_DrawThermo(mm_.SoundDef.x,mm_.SoundDef.y+LINEHEIGHT*(music_vol+1),
 		 16,musicVolume);
 }
 
 void M_Sound(int choice)
 {
-    M_SetupNextMenu(&SoundDef);
+    M_SetupNextMenu(&mm_.SoundDef);
 }
 
 void M_SfxVol(int choice)
@@ -916,9 +929,9 @@ void M_NewGame(int choice)
     // Chex Quest disabled the episode select screen, as did Doom II.
 
     if (gamemode == commercial || gameversion == exe_chex)
-	M_SetupNextMenu(&NewDef);
+	M_SetupNextMenu(&mm_.NewDef);
     else
-	M_SetupNextMenu(&EpiDef);
+	M_SetupNextMenu(&mm_.EpiDef);
 }
 
 
@@ -959,7 +972,7 @@ void M_Episode(int choice)
 	 && choice)
     {
 	M_StartMessage(DEH_String(SWSTRING),NULL,false);
-	M_SetupNextMenu(&ReadDef1);
+	M_SetupNextMenu(&mm_.ReadDef1);
 	return;
     }
 
@@ -967,13 +980,12 @@ void M_Episode(int choice)
     if ( (gamemode == registered)
 	 && (choice > 2))
     {
-      fprintf( stderr,
-	       "M_Episode: 4th episode requires UltimateDOOM\n");
+      printf("M_Episode: 4th episode requires UltimateDOOM\n");
       choice = 0;
     }
 	 
     epi = choice;
-    M_SetupNextMenu(&NewDef);
+    M_SetupNextMenu(&mm_.NewDef);
 }
 
 
@@ -981,32 +993,32 @@ void M_Episode(int choice)
 //
 // M_Options
 //
-static char *detailNames[2] = {"M_GDHIGH","M_GDLOW"};
-static char *msgNames[2] = {"M_MSGOFF","M_MSGON"};
+static const char * const detailNames[2] = {"M_GDHIGH","M_GDLOW"};
+static const char * const msgNames[2] = {"M_MSGOFF","M_MSGON"};
 
 void M_DrawOptions(void)
 {
     V_DrawPatchDirect(108, 15, W_CacheLumpName(DEH_String("M_OPTTTL"),
                                                PU_CACHE));
 	
-    V_DrawPatchDirect(OptionsDef.x + 175, OptionsDef.y + LINEHEIGHT * detail,
-		      W_CacheLumpName(DEH_String(detailNames[detailLevel]),
+    V_DrawPatchDirect(mm_.OptionsDef.x + 175, mm_.OptionsDef.y + LINEHEIGHT * detail,
+		      W_CacheLumpName(DEH_String((char *)detailNames[detailLevel]),
 			              PU_CACHE));
 
-    V_DrawPatchDirect(OptionsDef.x + 120, OptionsDef.y + LINEHEIGHT * messages,
-                      W_CacheLumpName(DEH_String(msgNames[showMessages]),
+    V_DrawPatchDirect(mm_.OptionsDef.x + 120, mm_.OptionsDef.y + LINEHEIGHT * messages,
+                      W_CacheLumpName(DEH_String((char *)msgNames[showMessages]),
                                       PU_CACHE));
 
-    M_DrawThermo(OptionsDef.x, OptionsDef.y + LINEHEIGHT * (mousesens + 1),
+    M_DrawThermo(mm_.OptionsDef.x, mm_.OptionsDef.y + LINEHEIGHT * (mousesens + 1),
 		 10, mouseSensitivity);
 
-    M_DrawThermo(OptionsDef.x,OptionsDef.y+LINEHEIGHT*(scrnsize+1),
+    M_DrawThermo(mm_.OptionsDef.x,mm_.OptionsDef.y+LINEHEIGHT*(scrnsize+1),
 		 9,screenSize);
 }
 
 void M_Options(int choice)
 {
-    M_SetupNextMenu(&OptionsDef);
+    M_SetupNextMenu(&mm_.OptionsDef);
 }
 
 
@@ -1069,7 +1081,7 @@ void M_EndGame(int choice)
 void M_ReadThis(int choice)
 {
     choice = 0;
-    M_SetupNextMenu(&ReadDef1);
+    M_SetupNextMenu(&mm_.ReadDef1);
 }
 
 void M_ReadThis2(int choice)
@@ -1080,7 +1092,7 @@ void M_ReadThis2(int choice)
     if (gameversion <= exe_doom_1_9 && gamemode != commercial)
     {
         choice = 0;
-        M_SetupNextMenu(&ReadDef2);
+        M_SetupNextMenu(&mm_.ReadDef2);
     }
     else
     {
@@ -1093,7 +1105,7 @@ void M_ReadThis2(int choice)
 void M_FinishReadThis(int choice)
 {
     choice = 0;
-    M_SetupNextMenu(&MainDef);
+    M_SetupNextMenu(&mm_.MainDef);
 }
 
 
@@ -1102,7 +1114,7 @@ void M_FinishReadThis(int choice)
 //
 // M_QuitDOOM
 //
-int     quitsounds[8] =
+const int     quitsounds[8] =
 {
     sfx_pldeth,
     sfx_dmpain,
@@ -1114,7 +1126,7 @@ int     quitsounds[8] =
     sfx_sgtatk
 };
 
-int     quitsounds2[8] =
+const int     quitsounds2[8] =
 {
     sfx_vilact,
     sfx_getpow,
@@ -1152,13 +1164,13 @@ static char *M_SelectEndMessage(void)
     {
         // Doom 1
 
-        endmsg = doom1_endmsg;
+        endmsg = (char **)doom1_endmsg;
     }
     else
     {
         // Doom 2
         
-        endmsg = doom2_endmsg;
+        endmsg = (char **)doom2_endmsg;
     }
 
     return endmsg[gametic % NUM_QUITMESSAGES];
@@ -1413,17 +1425,19 @@ static boolean IsNullKey(int key)
 //
 // M_Responder
 //
+struct {
+    int     joywait;
+    int     mousewait;
+    int     mousey;
+    int     lasty;
+    int     mousex;
+    int     lastx;
+} mmr_;
 boolean M_Responder (event_t* ev)
 {
     int             ch;
     int             key;
     int             i;
-    static  int     joywait = 0;
-    static  int     mousewait = 0;
-    static  int     mousey = 0;
-    static  int     lasty = 0;
-    static  int     mousex = 0;
-    static  int     lastx = 0;
 
     // In testcontrols mode, none of the function keys should do anything
     // - the only key is escape to quit.
@@ -1465,88 +1479,88 @@ boolean M_Responder (event_t* ev)
     ch = 0;
     key = -1;
 	
-    if (ev->type == ev_joystick && joywait < I_GetTime())
+    if (ev->type == ev_joystick && mmr_.joywait < I_GetTime())
     {
 	if (ev->data3 < 0)
 	{
 	    key = key_menu_up;
-	    joywait = I_GetTime() + 5;
+	    mmr_.joywait = I_GetTime() + 5;
 	}
 	else if (ev->data3 > 0)
 	{
 	    key = key_menu_down;
-	    joywait = I_GetTime() + 5;
+	    mmr_.joywait = I_GetTime() + 5;
 	}
 		
 	if (ev->data2 < 0)
 	{
 	    key = key_menu_left;
-	    joywait = I_GetTime() + 2;
+	    mmr_.joywait = I_GetTime() + 2;
 	}
 	else if (ev->data2 > 0)
 	{
 	    key = key_menu_right;
-	    joywait = I_GetTime() + 2;
+	    mmr_.joywait = I_GetTime() + 2;
 	}
 		
 	if (ev->data1&1)
 	{
 	    key = key_menu_forward;
-	    joywait = I_GetTime() + 5;
+	    mmr_.joywait = I_GetTime() + 5;
 	}
 	if (ev->data1&2)
 	{
 	    key = key_menu_back;
-	    joywait = I_GetTime() + 5;
+	    mmr_.joywait = I_GetTime() + 5;
 	}
         if (joybmenu >= 0 && (ev->data1 & (1 << joybmenu)) != 0)
         {
             key = key_menu_activate;
-	    joywait = I_GetTime() + 5;
+	    mmr_.joywait = I_GetTime() + 5;
         }
     }
     else
     {
-	if (ev->type == ev_mouse && mousewait < I_GetTime())
+	if (ev->type == ev_mouse && mmr_.mousewait < I_GetTime())
 	{
-	    mousey += ev->data3;
-	    if (mousey < lasty-30)
+	    mmr_.mousey += ev->data3;
+	    if (mmr_.mousey < mmr_.lasty-30)
 	    {
 		key = key_menu_down;
-		mousewait = I_GetTime() + 5;
-		mousey = lasty -= 30;
+		mmr_.mousewait = I_GetTime() + 5;
+		mmr_.mousey = mmr_.lasty -= 30;
 	    }
-	    else if (mousey > lasty+30)
+	    else if (mmr_.mousey > mmr_.lasty+30)
 	    {
 		key = key_menu_up;
-		mousewait = I_GetTime() + 5;
-		mousey = lasty += 30;
+		mmr_.mousewait = I_GetTime() + 5;
+		mmr_.mousey = mmr_.lasty += 30;
 	    }
 		
-	    mousex += ev->data2;
-	    if (mousex < lastx-30)
+	    mmr_.mousex += ev->data2;
+	    if (mmr_.mousex < mmr_.lastx-30)
 	    {
 		key = key_menu_left;
-		mousewait = I_GetTime() + 5;
-		mousex = lastx -= 30;
+		mmr_.mousewait = I_GetTime() + 5;
+		mmr_.mousex = mmr_.lastx -= 30;
 	    }
-	    else if (mousex > lastx+30)
+	    else if (mmr_.mousex > mmr_.lastx+30)
 	    {
 		key = key_menu_right;
-		mousewait = I_GetTime() + 5;
-		mousex = lastx += 30;
+		mmr_.mousewait = I_GetTime() + 5;
+		mmr_.mousex = mmr_.lastx += 30;
 	    }
 		
 	    if (ev->data1&1)
 	    {
 		key = key_menu_forward;
-		mousewait = I_GetTime() + 15;
+		mmr_.mousewait = I_GetTime() + 15;
 	    }
 			
 	    if (ev->data1&2)
 	    {
 		key = key_menu_back;
-		mousewait = I_GetTime() + 15;
+		mmr_.mousewait = I_GetTime() + 15;
 	    }
 	}
 	else
@@ -1674,9 +1688,9 @@ boolean M_Responder (event_t* ev)
 	    M_StartControlPanel ();
 
 	    if ( gamemode == retail )
-	      currentMenu = &ReadDef2;
+	      currentMenu = &mm_.ReadDef2;
 	    else
-	      currentMenu = &ReadDef1;
+	      currentMenu = &mm_.ReadDef1;
 
 	    itemOn = 0;
 	    S_StartSound(NULL,sfx_swtchn);
@@ -1699,7 +1713,7 @@ boolean M_Responder (event_t* ev)
         else if (key == key_menu_volume)   // Sound Volume
         {
 	    M_StartControlPanel ();
-	    currentMenu = &SoundDef;
+	    currentMenu = &mm_.SoundDef;
 	    itemOn = sfx_vol;
 	    S_StartSound(NULL,sfx_swtchn);
 	    return true;
@@ -1745,7 +1759,7 @@ boolean M_Responder (event_t* ev)
 	    usegamma++;
 	    if (usegamma > 4)
 		usegamma = 0;
-	    players[consoleplayer].message = DEH_String(gammamsg[usegamma]);
+	    players[consoleplayer].message = DEH_String((char *)gammamsg[usegamma]);
             I_SetPalette (W_CacheLumpName (DEH_String("PLAYPAL"),PU_CACHE));
 	    return true;
 	}
@@ -1903,7 +1917,7 @@ void M_StartControlPanel (void)
 	return;
     
     menuactive = 1;
-    currentMenu = &MainDef;         // JDC
+    currentMenu = &mm_.MainDef;         // JDC
     itemOn = currentMenu->lastOn;   // JDC
 }
 
@@ -1948,10 +1962,12 @@ static void M_DrawOPLDev(void)
 // Called after the view has been rendered,
 // but before it has been blitted.
 //
+struct {
+    short	x;
+    short	y;
+} mmd_;
 void M_Drawer (void)
 {
-    static short	x;
-    static short	y;
     unsigned int	i;
     unsigned int	max;
     char		string[80];
@@ -1964,7 +1980,7 @@ void M_Drawer (void)
     if (messageToPrint)
     {
 	start = 0;
-	y = SCREENHEIGHT/2 - M_StringHeight(messageString) / 2;
+	mmd_.y = SCREENHEIGHT/2 - M_StringHeight(messageString) / 2;
 	while (messageString[start] != '\0')
 	{
 	    int foundnewline = 0;
@@ -1992,9 +2008,9 @@ void M_Drawer (void)
                 start += strlen(string);
             }
 
-	    x = SCREENWIDTH/2 - M_StringWidth(string) / 2;
-	    M_WriteText(x, y, string);
-	    y += SHORT(hu_font[0]->height);
+	    mmd_.x = SCREENWIDTH/2 - M_StringWidth(string) / 2;
+	    M_WriteText(mmd_.x, mmd_.y, string);
+	    mmd_.y += SHORT(hu_font[0]->height);
 	}
 
 	return;
@@ -2012,25 +2028,25 @@ void M_Drawer (void)
 	currentMenu->routine();         // call Draw routine
     
     // DRAW MENU
-    x = currentMenu->x;
-    y = currentMenu->y;
+    mmd_.x = currentMenu->x;
+    mmd_.y = currentMenu->y;
     max = currentMenu->numitems;
 
     for (i=0;i<max;i++)
     {
-        name = DEH_String(currentMenu->menuitems[i].name);
+        name = DEH_String((char *)currentMenu->menuitems[i].name);
 
 	if (name[0])
 	{
-	    V_DrawPatchDirect (x, y, W_CacheLumpName(name, PU_CACHE));
+	    V_DrawPatchDirect (mmd_.x, mmd_.y, W_CacheLumpName(name, PU_CACHE));
 	}
-	y += LINEHEIGHT;
+	mmd_.y += LINEHEIGHT;
     }
 
     
     // DRAW SKULL
-    V_DrawPatchDirect(x + SKULLXOFF, currentMenu->y - 5 + itemOn*LINEHEIGHT,
-		      W_CacheLumpName(DEH_String(skullName[whichSkull]),
+    V_DrawPatchDirect(mmd_.x + SKULLXOFF, currentMenu->y - 5 + itemOn*LINEHEIGHT,
+		      W_CacheLumpName(DEH_String((char *)skullName[whichSkull]),
 				      PU_CACHE));
 }
 
@@ -2076,7 +2092,23 @@ void M_Ticker (void)
 //
 void M_Init (void)
 {
-    currentMenu = &MainDef;
+    mouseSensitivity = 5;
+    showMessages = 1;
+    detailLevel = 0;
+    screenblocks = 10;
+
+	// copy menu defs to mutable versions
+	mm_.MainDef = CMainDef;
+	mm_.EpiDef = CEpiDef;
+	mm_.NewDef = CNewDef;
+	mm_.OptionsDef = COptionsDef;
+	mm_.ReadDef1 = CReadDef1;
+	mm_.ReadDef2 = CReadDef2;
+	mm_.SoundDef = CSoundDef;
+	mm_.LoadDef = CLoadDef;
+	mm_.SaveDef = CSaveDef;
+
+    currentMenu = &mm_.MainDef;
     menuactive = 0;
     itemOn = currentMenu->lastOn;
     whichSkull = 0;
@@ -2095,10 +2127,12 @@ void M_Init (void)
     {
       case commercial:
         // Commercial has no "read this" entry.
+	/*TODO: PAA
 	MainMenu[readthis] = MainMenu[quitdoom];
 	MainDef.numitems--;
 	MainDef.y += 8;
 	NewDef.prevMenu = &MainDef;
+	*/
 	break;
       case shareware:
 	// Episode 2 and 3 are handled,
@@ -2117,7 +2151,7 @@ void M_Init (void)
     // (should crash if missing).
     if (gameversion < exe_ultimate)
     {
-	EpiDef.numitems--;
+		mm_.EpiDef.numitems--;
     }
 
     //opldev = M_CheckParm("-opldev") > 0;
diff --git a/doomgeneric/p_doors.c b/doomgeneric/p_doors.c
index cafab0f..9b9845e 100644
--- a/doomgeneric/p_doors.c
+++ b/doomgeneric/p_doors.c
@@ -437,7 +437,7 @@ EV_VerticalDoor
                 {
                     // This isn't a door OR a plat.  Now we're in trouble.
 
-                    fprintf(stderr, "EV_VerticalDoor: Tried to close "
+                    printf("EV_VerticalDoor: Tried to close "
                                     "something that wasn't a door.\n");
 
                     // Try closing it anyway. At least it will work on 32-bit
diff --git a/doomgeneric/p_enemy.c b/doomgeneric/p_enemy.c
index f2b44d1..d39ac92 100644
--- a/doomgeneric/p_enemy.c
+++ b/doomgeneric/p_enemy.c
@@ -60,13 +60,13 @@ typedef enum
 //
 // P_NewChaseDir related LUT.
 //
-dirtype_t opposite[] =
+const dirtype_t opposite[] =
 {
   DI_WEST, DI_SOUTHWEST, DI_SOUTH, DI_SOUTHEAST,
   DI_EAST, DI_NORTHEAST, DI_NORTH, DI_NORTHWEST, DI_NODIR
 };
 
-dirtype_t diags[] =
+const dirtype_t diags[] =
 {
     DI_NORTHWEST, DI_NORTHEAST, DI_SOUTHWEST, DI_SOUTHEAST
 };
@@ -254,8 +254,8 @@ boolean P_CheckMissileRange (mobj_t* actor)
 // Move in the current direction,
 // returns false if the move is blocked.
 //
-fixed_t	xspeed[8] = {FRACUNIT,47000,0,-47000,-FRACUNIT,-47000,0,47000};
-fixed_t yspeed[8] = {0,47000,FRACUNIT,47000,0,-47000,-FRACUNIT,-47000};
+const fixed_t xspeed[8] = {FRACUNIT,47000,0,-47000,-FRACUNIT,-47000,0,47000};
+const fixed_t yspeed[8] = {0,47000,FRACUNIT,47000,0,-47000,-FRACUNIT,-47000};
 
 boolean P_Move (mobj_t*	actor)
 {
@@ -1001,7 +1001,7 @@ void A_SkelMissile (mobj_t* actor)
     mo->tracer = actor->target;
 }
 
-int	TRACEANGLE = 0xc000000;
+const int	TRACEANGLE = 0xc000000;
 
 void A_Tracer (mobj_t* actor)
 {
@@ -1896,15 +1896,14 @@ void A_BrainDie (mobj_t*	mo)
     G_ExitLevel ();
 }
 
+int peb_easy;
 void A_BrainSpit (mobj_t*	mo)
 {
     mobj_t*	targ;
     mobj_t*	newmobj;
     
-    static int	easy = 0;
-	
-    easy ^= 1;
-    if (gameskill <= sk_easy && (!easy))
+    peb_easy ^= 1;
+    if (gameskill <= sk_easy && (!peb_easy))
 	return;
 		
     // shoot a cube at current target
diff --git a/doomgeneric/p_inter.c b/doomgeneric/p_inter.c
index 1eb58cf..878a393 100644
--- a/doomgeneric/p_inter.c
+++ b/doomgeneric/p_inter.c
@@ -47,8 +47,8 @@
 
 // a weapon is found with two clip loads,
 // a big item has five clip loads
-int	maxammo[NUMAMMO] = {200, 50, 300, 50};
-int	clipammo[NUMAMMO] = {10, 4, 20, 1};
+const int	maxammo[NUMAMMO] = {200, 50, 300, 50};
+const int	clipammo[NUMAMMO] = {10, 4, 20, 1};
 
 
 //
diff --git a/doomgeneric/p_local.h b/doomgeneric/p_local.h
index 95fa405..442a3fe 100644
--- a/doomgeneric/p_local.h
+++ b/doomgeneric/p_local.h
@@ -272,8 +272,8 @@ extern mobj_t**		blocklinks;	// for thing chains
 //
 // P_INTER
 //
-extern int		maxammo[NUMAMMO];
-extern int		clipammo[NUMAMMO];
+extern const int		maxammo[NUMAMMO];
+extern const int		clipammo[NUMAMMO];
 
 void
 P_TouchSpecialThing
diff --git a/doomgeneric/p_map.c b/doomgeneric/p_map.c
index e371869..81691a8 100644
--- a/doomgeneric/p_map.c
+++ b/doomgeneric/p_map.c
@@ -1388,12 +1388,12 @@ P_ChangeSector
 // of the spechit array.  This is by Andrey Budko (e6y) and comes from his
 // PrBoom plus port.  A big thanks to Andrey for this.
 
+unsigned int pms_baseaddr;
 static void SpechitOverrun(line_t *ld)
 {
-    static unsigned int baseaddr = 0;
     unsigned int addr;
    
-    if (baseaddr == 0)
+    if (pms_baseaddr == 0)
     {
         int p;
 
@@ -1412,17 +1412,17 @@ static void SpechitOverrun(line_t *ld)
         
         if (p > 0)
         {
-            M_StrToInt(myargv[p+1], (int *) &baseaddr);
+            M_StrToInt(myargv[p+1], (int *) &pms_baseaddr);
         }
         else
         {
-            baseaddr = DEFAULT_SPECHIT_MAGIC;
+            pms_baseaddr = DEFAULT_SPECHIT_MAGIC;
         }
     }
     
     // Calculate address used in doom2.exe
 
-    addr = baseaddr + (ld - lines) * 0x3E;
+    addr = pms_baseaddr + (ld - lines) * 0x3E;
 
     switch(numspechit)
     {
@@ -1439,7 +1439,7 @@ static void SpechitOverrun(line_t *ld)
             nofit = addr; 
             break;
         default:
-            fprintf(stderr, "SpechitOverrun: Warning: unable to emulate"
+            printf("SpechitOverrun: Warning: unable to emulate"
                             "an overrun where numspechit=%i\n",
                             numspechit);
             break;
diff --git a/doomgeneric/p_maputl.c b/doomgeneric/p_maputl.c
index 916f2b6..9a68f8b 100644
--- a/doomgeneric/p_maputl.c
+++ b/doomgeneric/p_maputl.c
@@ -750,7 +750,7 @@ typedef struct
 // playerstarts, which is effectively an array of 16-bit integers and
 // must be treated differently.
 
-static intercepts_overrun_t intercepts_overrun[] =
+static const intercepts_overrun_t intercepts_overrun[] =
 {
     {4,   NULL,                          false},
     {4,   NULL, /* &earlyout, */         false},
diff --git a/doomgeneric/p_mobj.c b/doomgeneric/p_mobj.c
index a3b9c43..7242030 100644
--- a/doomgeneric/p_mobj.c
+++ b/doomgeneric/p_mobj.c
@@ -60,7 +60,7 @@ P_SetMobjState
 	    return false;
 	}
 
-	st = &states[state];
+	st = (state_t *)&states[state];
 	mobj->state = st;
 	mobj->tics = st->tics;
 	mobj->sprite = st->sprite;
@@ -515,7 +515,7 @@ P_SpawnMobj
 	
     mobj = Z_Malloc (sizeof(*mobj), PU_LEVEL, NULL);
     memset (mobj, 0, sizeof (*mobj));
-    info = &mobjinfo[type];
+    info = (mobjinfo_t *)&mobjinfo[type];
 	
     mobj->type = type;
     mobj->info = info;
@@ -532,7 +532,7 @@ P_SpawnMobj
     mobj->lastlook = P_Random () % MAXPLAYERS;
     // do not set the state with P_SetMobjState,
     // because action routines can not be called yet
-    st = &states[info->spawnstate];
+    st = (state_t *)&states[info->spawnstate];
 
     mobj->state = st;
     mobj->tics = st->tics;
@@ -925,19 +925,18 @@ void P_CheckMissileSpawn (mobj_t* th)
 // Doom did not crash because of the lack of proper memory 
 // protection. This function substitutes NULL pointers for
 // pointers to a dummy mobj, to avoid a crash.
+mobj_t pm_dummy_mobj;
 
 mobj_t *P_SubstNullMobj(mobj_t *mobj)
 {
     if (mobj == NULL)
     {
-        static mobj_t dummy_mobj;
+        pm_dummy_mobj.x = 0;
+        pm_dummy_mobj.y = 0;
+        pm_dummy_mobj.z = 0;
+        pm_dummy_mobj.flags = 0;
 
-        dummy_mobj.x = 0;
-        dummy_mobj.y = 0;
-        dummy_mobj.z = 0;
-        dummy_mobj.flags = 0;
-
-        mobj = &dummy_mobj;
+        mobj = &pm_dummy_mobj;
     }
 
     return mobj;
diff --git a/doomgeneric/p_pspr.c b/doomgeneric/p_pspr.c
index e4774c7..19b6324 100644
--- a/doomgeneric/p_pspr.c
+++ b/doomgeneric/p_pspr.c
@@ -66,7 +66,7 @@ P_SetPsprite
 	    break;	
 	}
 	
-	state = &states[stnum];
+	state = (state_t *)&states[stnum];
 	psp->state = state;
 	psp->tics = state->tics;	// could be 0
 
diff --git a/doomgeneric/p_saveg.c b/doomgeneric/p_saveg.c
index 5cb8196..fb822a1 100644
--- a/doomgeneric/p_saveg.c
+++ b/doomgeneric/p_saveg.c
@@ -44,36 +44,34 @@ boolean savegame_error;
 // the file has been successfully saved, it will be renamed to the 
 // real file.
 
+char *ps_tempfilename;
 char *P_TempSaveGameFile(void)
 {
-    static char *filename = NULL;
-
-    if (filename == NULL)
+    if (ps_tempfilename == NULL)
     {
-        filename = M_StringJoin(savegamedir, "temp.dsg", NULL);
+        ps_tempfilename = M_StringJoin(savegamedir, "temp.dsg", NULL);
     }
 
-    return filename;
+    return ps_tempfilename;
 }
 
 // Get the filename of the save game file to use for the specified slot.
-
+char *ps_savefilename;
+size_t ps_savefilename_size;
 char *P_SaveGameFile(int slot)
 {
-    static char *filename = NULL;
-    static size_t filename_size = 0;
     char basename[32];
 
-    if (filename == NULL)
+    if (ps_savefilename == NULL)
     {
-        filename_size = strlen(savegamedir) + 32;
-        filename = malloc(filename_size);
+        ps_savefilename_size = strlen(savegamedir) + 32;
+        ps_savefilename = malloc(ps_savefilename_size);
     }
 
     DEH_snprintf(basename, 32, SAVEGAMENAME "%d.dsg", slot);
-    M_snprintf(filename, filename_size, "%s%s", savegamedir, basename);
+    M_snprintf(ps_savefilename, ps_savefilename_size, "%s%s", savegamedir, basename);
 
-    return filename;
+    return ps_savefilename;
 }
 
 // Endian-safe integer read/write functions
@@ -86,7 +84,7 @@ static byte saveg_read8(void)
     {
         if (!savegame_error)
         {
-            fprintf(stderr, "saveg_read8: Unexpected end of file while "
+            printf("saveg_read8: Unexpected end of file while "
                             "reading save game\n");
 
             savegame_error = true;
@@ -102,7 +100,7 @@ static void saveg_write8(byte value)
     {
         if (!savegame_error)
         {
-            fprintf(stderr, "saveg_write8: Error while writing save game\n");
+            printf("saveg_write8: Error while writing save game\n");
 
             savegame_error = true;
         }
@@ -372,7 +370,7 @@ static void saveg_read_mobj_t(mobj_t *str)
     str->tics = saveg_read32();
 
     // state_t* state;
-    str->state = &states[saveg_read32()];
+    str->state = (state_t *)&states[saveg_read32()];
 
     // int flags;
     str->flags = saveg_read32();
@@ -595,7 +593,7 @@ static void saveg_read_pspdef_t(pspdef_t *str)
 
     if (state > 0)
     {
-        str->state = &states[state];
+        str->state = (state_t *)&states[state];
     }
     else
     {
@@ -1656,7 +1654,7 @@ void P_UnArchiveThinkers (void)
 	    mobj->target = NULL;
             mobj->tracer = NULL;
 	    P_SetThingPosition (mobj);
-	    mobj->info = &mobjinfo[mobj->type];
+	    mobj->info = (mobjinfo_t *)&mobjinfo[mobj->type];
 	    mobj->floorz = mobj->subsector->sector->floorheight;
 	    mobj->ceilingz = mobj->subsector->sector->ceilingheight;
 	    mobj->thinker.function.acp1 = (actionf_p1)P_MobjThinker;
diff --git a/doomgeneric/p_setup.c b/doomgeneric/p_setup.c
index 00306e8..3390686 100644
--- a/doomgeneric/p_setup.c
+++ b/doomgeneric/p_setup.c
@@ -69,7 +69,7 @@ line_t*		lines;
 int		numsides;
 side_t*		sides;
 
-static int      totallines;
+int      totallines;
 
 // BLOCKMAP
 // Created from axis aligned bounding box
@@ -150,11 +150,10 @@ void P_LoadVertexes (int lump)
 //
 // GetSectorAtNullAddress
 //
+boolean null_sector_is_initialized;
+sector_t null_sector;
 sector_t* GetSectorAtNullAddress(void)
 {
-    static boolean null_sector_is_initialized = false;
-    static sector_t null_sector;
-
     if (!null_sector_is_initialized)
     {
         memset(&null_sector, 0, sizeof(null_sector));
@@ -691,7 +690,7 @@ static void PadRejectArray(byte *array, unsigned int len)
 
     if (len > sizeof(rejectpad))
     {
-        fprintf(stderr, "PadRejectArray: REJECT lump too short to pad! (%i > %i)\n",
+        printf("PadRejectArray: REJECT lump too short to pad! (%i > %i)\n",
                         len, (int) sizeof(rejectpad));
 
         // Pad remaining space with 0 (or 0xff, if specified on command line).
@@ -748,7 +747,7 @@ P_SetupLevel
   skill_t	skill)
 {
     int		i;
-    char	lumpname[9];
+    char	lumpname[16];
     int		lumpnum;
 	
     totalkills = totalitems = totalsecret = wminfo.maxfrags = 0;
@@ -775,9 +774,9 @@ P_SetupLevel
     if ( gamemode == commercial)
     {
 	if (map<10)
-	    DEH_snprintf(lumpname, 9, "map0%i", map);
+	    DEH_snprintf(lumpname, 16, "map0%i", map);
 	else
-	    DEH_snprintf(lumpname, 9, "map%i", map);
+	    DEH_snprintf(lumpname, 16, "map%i", map);
     }
     else
     {
@@ -848,7 +847,7 @@ void P_Init (void)
 {
     P_InitSwitchList ();
     P_InitPicAnims ();
-    R_InitSprites (sprnames);
+    R_InitSprites ((char **)sprnames);
 }
 
 
diff --git a/doomgeneric/p_spec.c b/doomgeneric/p_spec.c
index 17446b5..756ea53 100644
--- a/doomgeneric/p_spec.c
+++ b/doomgeneric/p_spec.c
@@ -93,7 +93,7 @@ extern anim_t*	lastanim;
 //  and end entry, in the order found in
 //  the WAD file.
 //
-animdef_t		animdefs[] =
+const animdef_t		animdefs[] =
 {
     {false,	"NUKAGE3",	"NUKAGE1",	8},
     {false,	"FWATER4",	"FWATER1",	8},
@@ -151,8 +151,8 @@ void P_InitPicAnims (void)
     {
         char *startname, *endname;
 
-        startname = DEH_String(animdefs[i].startname);
-        endname = DEH_String(animdefs[i].endname);
+        startname = DEH_String((char *)animdefs[i].startname);
+        endname = DEH_String((char *)animdefs[i].endname);
 
 	if (animdefs[i].istexture)
 	{
@@ -1174,26 +1174,24 @@ void P_UpdateSpecials (void)
 
 #define DONUT_FLOORHEIGHT_DEFAULT 0x00000000
 #define DONUT_FLOORPIC_DEFAULT 0x16
-
+int ps_hasrun;
+int ps_tmp_s3_floorheight;
+int ps_tmp_s3_floorpic;
 static void DonutOverrun(fixed_t *s3_floorheight, short *s3_floorpic,
                          line_t *line, sector_t *pillar_sector)
 {
-    static int first = 1;
-    static int tmp_s3_floorheight;
-    static int tmp_s3_floorpic;
-
     extern int numflats;
 
-    if (first)
+    if (!ps_hasrun)
     {
         int p;
 
         // This is the first time we have had an overrun.
-        first = 0;
+        ps_hasrun = 1;
 
         // Default values
-        tmp_s3_floorheight = DONUT_FLOORHEIGHT_DEFAULT;
-        tmp_s3_floorpic = DONUT_FLOORPIC_DEFAULT;
+        ps_tmp_s3_floorheight = DONUT_FLOORHEIGHT_DEFAULT;
+        ps_tmp_s3_floorpic = DONUT_FLOORPIC_DEFAULT;
 
         //!
         // @category compat
@@ -1223,31 +1221,22 @@ static void DonutOverrun(fixed_t *s3_floorheight, short *s3_floorpic,
             // DOSBox under XP:
             // 0000:0000    (00 00 00 F1) ?? ?? ?? 00-(07 00)
 
-            M_StrToInt(myargv[p + 1], &tmp_s3_floorheight);
-            M_StrToInt(myargv[p + 2], &tmp_s3_floorpic);
+            M_StrToInt(myargv[p + 1], &ps_tmp_s3_floorheight);
+            M_StrToInt(myargv[p + 2], &ps_tmp_s3_floorpic);
 
-            if (tmp_s3_floorpic >= numflats)
+            if (ps_tmp_s3_floorpic >= numflats)
             {
-                fprintf(stderr,
-                        "DonutOverrun: The second parameter for \"-donut\" "
+                printf("DonutOverrun: The second parameter for \"-donut\" "
                         "switch should be greater than 0 and less than number "
                         "of flats (%d). Using default value (%d) instead. \n",
                         numflats, DONUT_FLOORPIC_DEFAULT);
-                tmp_s3_floorpic = DONUT_FLOORPIC_DEFAULT;
+                ps_tmp_s3_floorpic = DONUT_FLOORPIC_DEFAULT;
             }
         }
     }
 
-    /*
-    fprintf(stderr,
-            "Linedef: %d; Sector: %d; "
-            "New floor height: %d; New floor pic: %d\n",
-            line->iLineID, pillar_sector->iSectorID,
-            tmp_s3_floorheight >> 16, tmp_s3_floorpic);
-     */
-
-    *s3_floorheight = (fixed_t) tmp_s3_floorheight;
-    *s3_floorpic = (short) tmp_s3_floorpic;
+    *s3_floorheight = (fixed_t) ps_tmp_s3_floorheight;
+    *s3_floorpic = (short) ps_tmp_s3_floorpic;
 }
 
 
@@ -1290,8 +1279,7 @@ int EV_DoDonut(line_t*	line)
 
         if (s2 == NULL)
         {
-            fprintf(stderr,
-                    "EV_DoDonut: linedef had no second sidedef! "
+            printf( "EV_DoDonut: linedef had no second sidedef! "
                     "Unexpected behavior may occur in Vanilla Doom. \n");
 	    break;
         }
@@ -1311,8 +1299,7 @@ int EV_DoDonut(line_t*	line)
                 // s3->floorpic is a short at 0000:0008
                 // Trying to emulate
 
-                fprintf(stderr,
-                        "EV_DoDonut: WARNING: emulating buffer overrun due to "
+                printf("EV_DoDonut: WARNING: emulating buffer overrun due to "
                         "NULL back sector. "
                         "Unexpected behavior may occur in Vanilla Doom.\n");
 
diff --git a/doomgeneric/p_switch.c b/doomgeneric/p_switch.c
index ed4feec..60f5864 100644
--- a/doomgeneric/p_switch.c
+++ b/doomgeneric/p_switch.c
@@ -39,7 +39,7 @@
 //
 // CHANGE THE TEXTURE OF A WALL SWITCH TO ITS OPPOSITE
 //
-switchlist_t alphSwitchList[] =
+const switchlist_t alphSwitchList[] =
 {
     // Doom shareware episode 1 switches
     {"SW1BRCOM",	"SW2BRCOM",	1},
@@ -135,8 +135,8 @@ void P_InitSwitchList(void)
 	    
 	    value = R_TextureNumForName(alphSwitchList[i].name1);
 #endif
-	    switchlist[index++] = R_TextureNumForName(DEH_String(alphSwitchList[i].name1));
-	    switchlist[index++] = R_TextureNumForName(DEH_String(alphSwitchList[i].name2));
+	    switchlist[index++] = R_TextureNumForName(DEH_String((char *)alphSwitchList[i].name1));
+	    switchlist[index++] = R_TextureNumForName(DEH_String((char *)alphSwitchList[i].name2));
 	}
     }
 }
diff --git a/doomgeneric/r_bsp.c b/doomgeneric/r_bsp.c
index 9a78812..3ebb4e2 100644
--- a/doomgeneric/r_bsp.c
+++ b/doomgeneric/r_bsp.c
@@ -355,7 +355,7 @@ void R_AddLine (seg_t*	line)
 // Returns true
 //  if some part of the bbox might be visible.
 //
-int	checkcoord[12][4] =
+const int	checkcoord[12][4] =
 {
     {3,0,2,1},
     {3,0,2,0},
diff --git a/doomgeneric/r_draw.c b/doomgeneric/r_draw.c
index 9271bcd..1ba4905 100644
--- a/doomgeneric/r_draw.c
+++ b/doomgeneric/r_draw.c
@@ -72,7 +72,7 @@ byte		translations[3][256];
 // Backing buffer containing the bezel drawn around the screen and 
 // surrounding background.
 
-static byte *background_buffer = NULL;
+byte *rd_background_buffer = NULL;
 
 
 //
@@ -258,7 +258,7 @@ void R_DrawColumnLow (void)
 #define FUZZOFF	(SCREENWIDTH)
 
 
-int	fuzzoffset[FUZZTABLE] =
+const int	fuzzoffset[FUZZTABLE] =
 {
     FUZZOFF,-FUZZOFF,FUZZOFF,-FUZZOFF,FUZZOFF,FUZZOFF,-FUZZOFF,
     FUZZOFF,FUZZOFF,-FUZZOFF,FUZZOFF,FUZZOFF,FUZZOFF,-FUZZOFF,
@@ -830,10 +830,10 @@ void R_FillBackScreen (void)
 
     if (scaledviewwidth == SCREENWIDTH)
     {
-        if (background_buffer != NULL)
+        if (rd_background_buffer != NULL)
         {
-            Z_Free(background_buffer);
-            background_buffer = NULL;
+            Z_Free(rd_background_buffer);
+            rd_background_buffer = NULL;
         }
 
 	return;
@@ -841,9 +841,9 @@ void R_FillBackScreen (void)
 
     // Allocate the background buffer if necessary
 	
-    if (background_buffer == NULL)
+    if (rd_background_buffer == NULL)
     {
-        background_buffer = Z_Malloc(SCREENWIDTH * (SCREENHEIGHT - SBARHEIGHT),
+        rd_background_buffer = Z_Malloc(SCREENWIDTH * (SCREENHEIGHT - SBARHEIGHT),
                                      PU_STATIC, NULL);
     }
 
@@ -853,7 +853,7 @@ void R_FillBackScreen (void)
 	name = name1;
     
     src = W_CacheLumpName(name, PU_CACHE); 
-    dest = background_buffer;
+    dest = rd_background_buffer;
 	 
     for (y=0 ; y<SCREENHEIGHT-SBARHEIGHT ; y++) 
     { 
@@ -872,7 +872,7 @@ void R_FillBackScreen (void)
      
     // Draw screen and bezel; this is done to a separate screen buffer.
 
-    V_UseBuffer(background_buffer);
+    V_UseBuffer(rd_background_buffer);
 
     patch = W_CacheLumpName(DEH_String("brdr_t"),PU_CACHE);
 
@@ -926,9 +926,9 @@ R_VideoErase
   //  a 32bit CPU, as GNU GCC/Linux libc did
   //  at one point.
 
-    if (background_buffer != NULL)
+    if (rd_background_buffer != NULL)
     {
-        memcpy(I_VideoBuffer + ofs, background_buffer + ofs, count); 
+        memcpy(I_VideoBuffer + ofs, rd_background_buffer + ofs, count); 
     }
 } 
 
diff --git a/doomgeneric/r_main.c b/doomgeneric/r_main.c
index 22278fe..bb0fbbd 100644
--- a/doomgeneric/r_main.c
+++ b/doomgeneric/r_main.c
@@ -47,7 +47,7 @@
 int			viewangleoffset;
 
 // increment every time a check is made
-int			validcount = 1;		
+int			validcount;		
 
 
 lighttable_t*		fixedcolormap;
@@ -766,6 +766,7 @@ void R_ExecuteSetViewSize (void)
 
 void R_Init (void)
 {
+    validcount = 1;
     R_InitData ();
     printf (".");
     R_InitPointToAngle ();
diff --git a/doomgeneric/r_things.c b/doomgeneric/r_things.c
index 74e7369..1150e01 100644
--- a/doomgeneric/r_things.c
+++ b/doomgeneric/r_things.c
@@ -832,8 +832,8 @@ void R_SortVisSprites (void)
 //
 // R_DrawSprite
 //
-static short		clipbot[SCREENWIDTH];
-static short		cliptop[SCREENWIDTH];
+short		rt_clipbot[SCREENWIDTH];
+short		rt_cliptop[SCREENWIDTH];
 void R_DrawSprite (vissprite_t* spr)
 {
     drawseg_t*		ds;
@@ -845,7 +845,7 @@ void R_DrawSprite (vissprite_t* spr)
     int			silhouette;
 		
     for (x = spr->x1 ; x<=spr->x2 ; x++)
-	clipbot[x] = cliptop[x] = -2;
+	rt_clipbot[x] = rt_cliptop[x] = -2;
     
     // Scan drawsegs from end to start for obscuring segs.
     // The first drawseg that has a greater scale
@@ -901,25 +901,25 @@ void R_DrawSprite (vissprite_t* spr)
 	{
 	    // bottom sil
 	    for (x=r1 ; x<=r2 ; x++)
-		if (clipbot[x] == -2)
-		    clipbot[x] = ds->sprbottomclip[x];
+		if (rt_clipbot[x] == -2)
+		    rt_clipbot[x] = ds->sprbottomclip[x];
 	}
 	else if (silhouette == 2)
 	{
 	    // top sil
 	    for (x=r1 ; x<=r2 ; x++)
-		if (cliptop[x] == -2)
-		    cliptop[x] = ds->sprtopclip[x];
+		if (rt_cliptop[x] == -2)
+		    rt_cliptop[x] = ds->sprtopclip[x];
 	}
 	else if (silhouette == 3)
 	{
 	    // both
 	    for (x=r1 ; x<=r2 ; x++)
 	    {
-		if (clipbot[x] == -2)
-		    clipbot[x] = ds->sprbottomclip[x];
-		if (cliptop[x] == -2)
-		    cliptop[x] = ds->sprtopclip[x];
+		if (rt_clipbot[x] == -2)
+		    rt_clipbot[x] = ds->sprbottomclip[x];
+		if (rt_cliptop[x] == -2)
+		    rt_cliptop[x] = ds->sprtopclip[x];
 	    }
 	}
 		
@@ -930,15 +930,15 @@ void R_DrawSprite (vissprite_t* spr)
     // check for unclipped columns
     for (x = spr->x1 ; x<=spr->x2 ; x++)
     {
-	if (clipbot[x] == -2)		
-	    clipbot[x] = viewheight;
+	if (rt_clipbot[x] == -2)		
+	    rt_clipbot[x] = viewheight;
 
-	if (cliptop[x] == -2)
-	    cliptop[x] = -1;
+	if (rt_cliptop[x] == -2)
+	    rt_cliptop[x] = -1;
     }
 		
-    mfloorclip = clipbot;
-    mceilingclip = cliptop;
+    mfloorclip = rt_clipbot;
+    mceilingclip = rt_cliptop;
     R_DrawVisSprite (spr, spr->x1, spr->x2);
 }
 
diff --git a/doomgeneric/s_sound.c b/doomgeneric/s_sound.c
index f6d8be1..ba03140 100644
--- a/doomgeneric/s_sound.c
+++ b/doomgeneric/s_sound.c
@@ -76,34 +76,42 @@ typedef struct
     
 } channel_t;
 
-// The set of channels available
+// Maximum volume of music. 
 
-static channel_t *channels;
+int musicVolume;
 
 // Maximum volume of a sound effect.
 // Internal default is max out of 0-15.
 
-int sfxVolume = 8;
+int sfxVolume;
 
-// Maximum volume of music. 
+struct {
+// The set of channels available
 
-int musicVolume = 8;
+    channel_t *channels;
 
 // Internal volume level, ranging from 0-127
 
-static int snd_SfxVolume;
+    int snd_SfxVolume;
 
 // Whether songs are mus_paused
 
-static boolean mus_paused;        
+    boolean mus_paused;        
 
 // Music currently being played
 
-static musicinfo_t *mus_playing = NULL;
+    musicinfo_t *mus_playing;
+
+// PAA: local cache of lump numbers & usefulness, as sfx array is now const
+    int lumpnums[NUMSFX+1];
+    int usefulness[NUMSFX+1];
+
+    int mlumpns[NUMMUSIC];
+} ss_;
 
 // Number of channels to use
 
-int snd_channels = 8;
+int snd_channels;
 
 //
 // Initializes sound stuff, including volume
@@ -115,7 +123,11 @@ void S_Init(int sfxVolume, int musicVolume)
 {  
     int i;
 
-    I_PrecacheSounds(S_sfx, NUMSFX);
+	S_SoundsInit();
+	sfxVolume = 8;
+	musicVolume = 8;
+	snd_channels = 8;
+    I_PrecacheSounds((sfxinfo_t *)S_sfx, NUMSFX);
 
     S_SetSfxVolume(sfxVolume);
     S_SetMusicVolume(musicVolume);
@@ -123,21 +135,22 @@ void S_Init(int sfxVolume, int musicVolume)
     // Allocating the internal channels for mixing
     // (the maximum numer of sounds rendered
     // simultaneously) within zone memory.
-    channels = Z_Malloc(snd_channels*sizeof(channel_t), PU_STATIC, 0);
+    ss_.channels = Z_Malloc(snd_channels*sizeof(channel_t), PU_STATIC, 0);
 
     // Free all channels for use
     for (i=0 ; i<snd_channels ; i++)
     {
-        channels[i].sfxinfo = 0;
+        ss_.channels[i].sfxinfo = 0;
     }
 
     // no sounds are playing, and they are not mus_paused
-    mus_paused = 0;
+    ss_.mus_paused = 0;
 
     // Note that sounds have not been cached (yet).
     for (i=1 ; i<NUMSFX ; i++)
     {
-        S_sfx[i].lumpnum = S_sfx[i].usefulness = -1;
+        ss_.lumpnums[i] = -1;
+		ss_.usefulness[i] = -1;
     }
 
     I_AtExit(S_Shutdown, true);
@@ -151,10 +164,10 @@ void S_Shutdown(void)
 
 static void S_StopChannel(int cnum)
 {
-    int i;
+    int i, sfx_id;
     channel_t *c;
 
-    c = &channels[cnum];
+    c = &ss_.channels[cnum];
 
     if (c->sfxinfo)
     {
@@ -169,7 +182,7 @@ static void S_StopChannel(int cnum)
 
         for (i=0; i<snd_channels; i++)
         {
-            if (cnum != i && c->sfxinfo == channels[i].sfxinfo)
+            if (cnum != i && c->sfxinfo == ss_.channels[i].sfxinfo)
             {
                 break;
             }
@@ -177,7 +190,8 @@ static void S_StopChannel(int cnum)
         
         // degrade usefulness of sound data
 
-        c->sfxinfo->usefulness--;
+		sfx_id = (c->sfxinfo - S_sfx);	// NB: C99 says ptr diffs are in units of object size
+        ss_.usefulness[sfx_id]--;
         c->sfxinfo = NULL;
     }
 }
@@ -197,14 +211,14 @@ void S_Start(void)
     //  (trust me - a good idea)
     for (cnum=0 ; cnum<snd_channels ; cnum++)
     {
-        if (channels[cnum].sfxinfo)
+        if (ss_.channels[cnum].sfxinfo)
         {
             S_StopChannel(cnum);
         }
     }
 
     // start new music for the level
-    mus_paused = 0;
+    ss_.mus_paused = 0;
 
     if (gamemode == commercial)
     {
@@ -246,7 +260,7 @@ void S_StopSound(mobj_t *origin)
 
     for (cnum=0 ; cnum<snd_channels ; cnum++)
     {
-        if (channels[cnum].sfxinfo && channels[cnum].origin == origin)
+        if (ss_.channels[cnum].sfxinfo && ss_.channels[cnum].origin == origin)
         {
             S_StopChannel(cnum);
             break;
@@ -269,11 +283,11 @@ static int S_GetChannel(mobj_t *origin, sfxinfo_t *sfxinfo)
     // Find an open channel
     for (cnum=0 ; cnum<snd_channels ; cnum++)
     {
-        if (!channels[cnum].sfxinfo)
+        if (!ss_.channels[cnum].sfxinfo)
         {
             break;
         }
-        else if (origin && channels[cnum].origin == origin)
+        else if (origin && ss_.channels[cnum].origin == origin)
         {
             S_StopChannel(cnum);
             break;
@@ -286,7 +300,7 @@ static int S_GetChannel(mobj_t *origin, sfxinfo_t *sfxinfo)
         // Look for lower priority
         for (cnum=0 ; cnum<snd_channels ; cnum++)
         {
-            if (channels[cnum].sfxinfo->priority >= sfxinfo->priority)
+            if (ss_.channels[cnum].sfxinfo->priority >= sfxinfo->priority)
             {
                 break;
             }
@@ -304,7 +318,7 @@ static int S_GetChannel(mobj_t *origin, sfxinfo_t *sfxinfo)
         }
     }
 
-    c = &channels[cnum];
+    c = &ss_.channels[cnum];
 
     // channel is decided to be cnum.
     c->sfxinfo = sfxinfo;
@@ -364,7 +378,7 @@ static int S_AdjustSoundParams(mobj_t *listener, mobj_t *source,
     // volume calculation
     if (approx_dist < S_CLOSE_DIST)
     {
-        *vol = snd_SfxVolume;
+        *vol = ss_.snd_SfxVolume;
     }
     else if (gamemap == 8)
     {
@@ -373,14 +387,14 @@ static int S_AdjustSoundParams(mobj_t *listener, mobj_t *source,
             approx_dist = S_CLIPPING_DIST;
         }
 
-        *vol = 15+ ((snd_SfxVolume-15)
+        *vol = 15+ ((ss_.snd_SfxVolume-15)
                     *((S_CLIPPING_DIST - approx_dist)>>FRACBITS))
             / S_ATTENUATOR;
     }
     else
     {
         // distance effect
-        *vol = (snd_SfxVolume
+        *vol = (ss_.snd_SfxVolume
                 * ((S_CLIPPING_DIST - approx_dist)>>FRACBITS))
             / S_ATTENUATOR; 
     }
@@ -398,7 +412,7 @@ void S_StartSound(void *origin_p, int sfx_id)
     int volume;
 
     origin = (mobj_t *) origin_p;
-    volume = snd_SfxVolume;
+    volume = ss_.snd_SfxVolume;
 
     // check for bogus sound #
     if (sfx_id < 1 || sfx_id > NUMSFX)
@@ -406,7 +420,7 @@ void S_StartSound(void *origin_p, int sfx_id)
         I_Error("Bad sfx #: %d", sfx_id);
     }
 
-    sfx = &S_sfx[sfx_id];
+    sfx = (sfxinfo_t *)&S_sfx[sfx_id];
 
     // Initialize sound parameters
     if (sfx->link)
@@ -418,9 +432,9 @@ void S_StartSound(void *origin_p, int sfx_id)
             return;
         }
 
-        if (volume > snd_SfxVolume)
+        if (volume > ss_.snd_SfxVolume)
         {
-            volume = snd_SfxVolume;
+            volume = ss_.snd_SfxVolume;
         }
     }
 
@@ -462,17 +476,17 @@ void S_StartSound(void *origin_p, int sfx_id)
     }
 
     // increase the usefulness
-    if (sfx->usefulness++ < 0)
+    if (ss_.usefulness[sfx_id]++ < 0)
     {
-        sfx->usefulness = 1;
+        ss_.usefulness[sfx_id] = 1;
     }
 
-    if (sfx->lumpnum < 0)
+    if (ss_.lumpnums[sfx_id] <= 0)
     {
-        sfx->lumpnum = I_GetSfxLumpNum(sfx);
+        ss_.lumpnums[sfx_id] = I_GetSfxLumpNum(sfx);
     }
 
-    channels[cnum].handle = I_StartSound(sfx, cnum, volume, sep);
+    ss_.channels[cnum].handle = I_StartSound(sfx, cnum, volume, sep);
 }        
 
 //
@@ -481,19 +495,19 @@ void S_StartSound(void *origin_p, int sfx_id)
 
 void S_PauseSound(void)
 {
-    if (mus_playing && !mus_paused)
+    if (ss_.mus_playing && !ss_.mus_paused)
     {
         I_PauseSong();
-        mus_paused = true;
+        ss_.mus_paused = true;
     }
 }
 
 void S_ResumeSound(void)
 {
-    if (mus_playing && mus_paused)
+    if (ss_.mus_playing && ss_.mus_paused)
     {
         I_ResumeSong();
-        mus_paused = false;
+        ss_.mus_paused = false;
     }
 }
 
@@ -514,7 +528,7 @@ void S_UpdateSounds(mobj_t *listener)
 
     for (cnum=0; cnum<snd_channels; cnum++)
     {
-        c = &channels[cnum];
+        c = &ss_.channels[cnum];
         sfx = c->sfxinfo;
 
         if (c->sfxinfo)
@@ -522,7 +536,7 @@ void S_UpdateSounds(mobj_t *listener)
             if (I_SoundIsPlaying(c->handle))
             {
                 // initialize parameters
-                volume = snd_SfxVolume;
+                volume = ss_.snd_SfxVolume;
                 sep = NORM_SEP;
 
                 if (sfx->link)
@@ -533,9 +547,9 @@ void S_UpdateSounds(mobj_t *listener)
                         S_StopChannel(cnum);
                         continue;
                     }
-                    else if (volume > snd_SfxVolume)
+                    else if (volume > ss_.snd_SfxVolume)
                     {
-                        volume = snd_SfxVolume;
+                        volume = ss_.snd_SfxVolume;
                     }
                 }
 
@@ -586,7 +600,7 @@ void S_SetSfxVolume(int volume)
         I_Error("Attempt to set sfx volume at %d", volume);
     }
 
-    snd_SfxVolume = volume;
+    ss_.snd_SfxVolume = volume;
 }
 
 //
@@ -619,10 +633,10 @@ void S_ChangeMusic(int musicnum, int looping)
     }
     else
     {
-        music = &S_music[musicnum];
+        music = (musicinfo_t *)&S_music[musicnum];
     }
 
-    if (mus_playing == music)
+    if (ss_.mus_playing == music)
     {
         return;
     }
@@ -631,10 +645,10 @@ void S_ChangeMusic(int musicnum, int looping)
     S_StopMusic();
 
     // get lumpnum if neccessary
-    if (!music->lumpnum)
+    if (!ss_.mlumpns[musicnum])
     {
-        M_snprintf(namebuf, sizeof(namebuf), "d_%s", DEH_String(music->name));
-        music->lumpnum = W_GetNumForName(namebuf);
+        M_snprintf(namebuf, sizeof(namebuf), "d_%s", DEH_String((char *)music->name));
+        ss_.mlumpns[musicnum] = W_GetNumForName(namebuf);
     }
 
     music->data = W_CacheLumpNum(music->lumpnum, PU_STATIC);
@@ -643,7 +657,7 @@ void S_ChangeMusic(int musicnum, int looping)
     music->handle = handle;
     I_PlaySong(handle, looping);
 
-    mus_playing = music;
+    ss_.mus_playing = music;
 }
 
 boolean S_MusicPlaying(void)
@@ -653,18 +667,18 @@ boolean S_MusicPlaying(void)
 
 void S_StopMusic(void)
 {
-    if (mus_playing)
+    if (ss_.mus_playing)
     {
-        if (mus_paused)
+        if (ss_.mus_paused)
         {
             I_ResumeSong();
         }
 
         I_StopSong();
-        I_UnRegisterSong(mus_playing->handle);
-        W_ReleaseLumpNum(mus_playing->lumpnum);
-        mus_playing->data = NULL;
-        mus_playing = NULL;
+        I_UnRegisterSong(ss_.mus_playing->handle);
+        W_ReleaseLumpNum(ss_.mus_playing->lumpnum);
+        ss_.mus_playing->data = NULL;
+        ss_.mus_playing = NULL;
     }
 }
 
diff --git a/doomgeneric/sounds.c b/doomgeneric/sounds.c
index e976bc8..4fcfa4f 100644
--- a/doomgeneric/sounds.c
+++ b/doomgeneric/sounds.c
@@ -28,80 +28,77 @@
 // Information about all the music
 //
 
-#define MUSIC(name) \
-    { name, 0, NULL, NULL }
-
-musicinfo_t S_music[] =
-{
-    MUSIC(NULL),
-    MUSIC("e1m1"),
-    MUSIC("e1m2"),
-    MUSIC("e1m3"),
-    MUSIC("e1m4"),
-    MUSIC("e1m5"),
-    MUSIC("e1m6"),
-    MUSIC("e1m7"),
-    MUSIC("e1m8"),
-    MUSIC("e1m9"),
-    MUSIC("e2m1"),
-    MUSIC("e2m2"),
-    MUSIC("e2m3"),
-    MUSIC("e2m4"),
-    MUSIC("e2m5"),
-    MUSIC("e2m6"),
-    MUSIC("e2m7"),
-    MUSIC("e2m8"),
-    MUSIC("e2m9"),
-    MUSIC("e3m1"),
-    MUSIC("e3m2"),
-    MUSIC("e3m3"),
-    MUSIC("e3m4"),
-    MUSIC("e3m5"),
-    MUSIC("e3m6"),
-    MUSIC("e3m7"),
-    MUSIC("e3m8"),
-    MUSIC("e3m9"),
-    MUSIC("inter"),
-    MUSIC("intro"),
-    MUSIC("bunny"),
-    MUSIC("victor"),
-    MUSIC("introa"),
-    MUSIC("runnin"),
-    MUSIC("stalks"),
-    MUSIC("countd"),
-    MUSIC("betwee"),
-    MUSIC("doom"),
-    MUSIC("the_da"),
-    MUSIC("shawn"),
-    MUSIC("ddtblu"),
-    MUSIC("in_cit"),
-    MUSIC("dead"),
-    MUSIC("stlks2"),
-    MUSIC("theda2"),
-    MUSIC("doom2"),
-    MUSIC("ddtbl2"),
-    MUSIC("runni2"),
-    MUSIC("dead2"),
-    MUSIC("stlks3"),
-    MUSIC("romero"),
-    MUSIC("shawn2"),
-    MUSIC("messag"),
-    MUSIC("count2"),
-    MUSIC("ddtbl3"),
-    MUSIC("ampie"),
-    MUSIC("theda3"),
-    MUSIC("adrian"),
-    MUSIC("messg2"),
-    MUSIC("romer2"),
-    MUSIC("tense"),
-    MUSIC("shawn3"),
-    MUSIC("openin"),
-    MUSIC("evil"),
-    MUSIC("ultima"),
-    MUSIC("read_m"),
-    MUSIC("dm2ttl"),
-    MUSIC("dm2int") 
+static const char * const S_mnames[] = {
+    NULL,
+    "e1m1",
+    "e1m2",
+    "e1m3",
+    "e1m4",
+    "e1m5",
+    "e1m6",
+    "e1m7",
+    "e1m8",
+    "e1m9",
+    "e2m1",
+    "e2m2",
+    "e2m3",
+    "e2m4",
+    "e2m5",
+    "e2m6",
+    "e2m7",
+    "e2m8",
+    "e2m9",
+    "e3m1",
+    "e3m2",
+    "e3m3",
+    "e3m4",
+    "e3m5",
+    "e3m6",
+    "e3m7",
+    "e3m8",
+    "e3m9",
+    "inter",
+    "intro",
+    "bunny",
+    "victor",
+    "introa",
+    "runnin",
+    "stalks",
+    "countd",
+    "betwee",
+    "doom",
+    "the_da",
+    "shawn",
+    "ddtblu",
+    "in_cit",
+    "dead",
+    "stlks2",
+    "theda2",
+    "doom2",
+    "ddtbl2",
+    "runni2",
+    "dead2",
+    "stlks3",
+    "romero",
+    "shawn2",
+    "messag",
+    "count2",
+    "ddtbl3",
+    "ampie",
+    "theda3",
+    "adrian",
+    "messg2",
+    "romer2",
+    "tense",
+    "shawn3",
+    "openin",
+    "evil",
+    "ultima",
+    "read_m",
+    "dm2ttl",
+    "dm2int" 
 };
+musicinfo_t S_music[sizeof(S_mnames)/sizeof(*S_mnames)];
 
 
 //
@@ -109,11 +106,11 @@ musicinfo_t S_music[] =
 //
 
 #define SOUND(name, priority) \
-  { NULL, name, priority, NULL, -1, -1, 0, 0, -1, NULL }
+  { name, priority, 0, -1, -1 }
 #define SOUND_LINK(name, priority, link_id, pitch, volume) \
-  { NULL, name, priority, &S_sfx[link_id], pitch, volume, 0, 0, -1, NULL }
+  { name, priority, link_id, pitch, volume }
 
-sfxinfo_t S_sfx[] =
+const sfxdata_t S_sfxdata[] =
 {
   // S_sfx[0] needs to be a dummy for odd reasons.
   SOUND("none",   0),
@@ -226,4 +223,21 @@ sfxinfo_t S_sfx[] =
   SOUND("skeatk", 70),
   SOUND("radio",  60),
 };
+sfxinfo_t S_sfx[sizeof(S_sfxdata)/sizeof(*S_sfxdata)];
+
+void S_SoundsInit(void)
+{
+	int i;
+	for (i=0; i<arrlen(S_mnames); i++)
+		S_music[i].name = (char *)S_mnames[i];
+	for (i=0; i<arrlen(S_sfxdata); i++) {
+		int j;
+		for (j=0; j<sizeof(S_sfx[i].name); j++)
+			S_sfx[i].name[j] = S_sfxdata[i].name[j];
+		S_sfx[i].priority = S_sfxdata[i].priority;
+		S_sfx[i].link = &S_sfx[S_sfxdata[i].link_id];
+		S_sfx[i].pitch = S_sfxdata[i].pitch;
+		S_sfx[i].volume = S_sfxdata[i].volume;
+	}
+}
 
diff --git a/doomgeneric/sounds.h b/doomgeneric/sounds.h
index 1e8afc4..f6b8332 100644
--- a/doomgeneric/sounds.h
+++ b/doomgeneric/sounds.h
@@ -224,4 +224,6 @@ typedef enum
     NUMSFX
 } sfxenum_t;
 
+extern void S_SoundsInit(void);
+
 #endif
diff --git a/doomgeneric/st_stuff.c b/doomgeneric/st_stuff.c
index e25accc..7bd203a 100644
--- a/doomgeneric/st_stuff.c
+++ b/doomgeneric/st_stuff.c
@@ -261,138 +261,140 @@
 
 // graphics are drawn to a backing screen and blitted to the real screen
 byte                   *st_backing_screen;
-	    
-// main player in game
-static player_t*	plyr; 
 
-// ST_Start() has just been called
-static boolean		st_firsttime;
+struct {
+    // main player in game
+    player_t*	plyr; 
+
+    // ST_Start() has just been called
+    boolean		st_firsttime;
 
-// lump number for PLAYPAL
-static int		lu_palette;
+    // lump number for PLAYPAL
+    int		lu_palette;
 
-// used for timing
-static unsigned int	st_clock;
+    // used for timing
+    unsigned int	st_clock;
 
-// used for making messages go away
-static int		st_msgcounter=0;
+    // used for making messages go away
+    int		st_msgcounter;
 
-// used when in chat 
-static st_chatstateenum_t	st_chatstate;
+    // used when in chat 
+    st_chatstateenum_t	st_chatstate;
 
-// whether in automap or first-person
-static st_stateenum_t	st_gamestate;
+    // whether in automap or first-person
+    st_stateenum_t	st_gamestate;
 
-// whether left-side main status bar is active
-static boolean		st_statusbaron;
+    // whether left-side main status bar is active
+    boolean		st_statusbaron;
 
-// whether status bar chat is active
-static boolean		st_chat;
+    // whether status bar chat is active
+    boolean		st_chat;
 
-// value of st_chat before message popped up
-static boolean		st_oldchat;
+    // value of st_chat before message popped up
+    boolean		st_oldchat;
 
-// whether chat window has the cursor on
-static boolean		st_cursoron;
+    // whether chat window has the cursor on
+    boolean		st_cursoron;
 
-// !deathmatch
-static boolean		st_notdeathmatch; 
+    // !deathmatch
+    boolean		st_notdeathmatch; 
 
-// !deathmatch && st_statusbaron
-static boolean		st_armson;
+    // !deathmatch && st_statusbaron
+    boolean		st_armson;
 
-// !deathmatch
-static boolean		st_fragson; 
+    // !deathmatch
+    boolean		st_fragson; 
 
-// main bar left
-static patch_t*		sbar;
+    // main bar left
+    patch_t*		sbar;
 
-// 0-9, tall numbers
-static patch_t*		tallnum[10];
+    // 0-9, tall numbers
+    patch_t*		tallnum[10];
 
-// tall % sign
-static patch_t*		tallpercent;
+    // tall % sign
+    patch_t*		tallpercent;
 
-// 0-9, short, yellow (,different!) numbers
-static patch_t*		shortnum[10];
+    // 0-9, short, yellow (,different!) numbers
+    patch_t*		shortnum[10];
 
-// 3 key-cards, 3 skulls
-static patch_t*		keys[NUMCARDS]; 
+    // 3 key-cards, 3 skulls
+    patch_t*		keys[NUMCARDS]; 
 
-// face status patches
-static patch_t*		faces[ST_NUMFACES];
+    // face status patches
+    patch_t*		faces[ST_NUMFACES];
 
-// face background
-static patch_t*		faceback;
+    // face background
+    patch_t*		faceback;
 
- // main bar right
-static patch_t*		armsbg;
+    // main bar right
+    patch_t*		armsbg;
 
-// weapon ownership patches
-static patch_t*		arms[6][2]; 
+    // weapon ownership patches
+    patch_t*		arms[6][2]; 
 
-// ready-weapon widget
-static st_number_t	w_ready;
+    // ready-weapon widget
+    st_number_t	w_ready;
 
- // in deathmatch only, summary of frags stats
-static st_number_t	w_frags;
+    // in deathmatch only, summary of frags stats
+    st_number_t	w_frags;
 
-// health widget
-static st_percent_t	w_health;
+    // health widget
+    st_percent_t	w_health;
 
-// arms background
-static st_binicon_t	w_armsbg; 
+    // arms background
+    st_binicon_t	w_armsbg; 
 
 
-// weapon ownership widgets
-static st_multicon_t	w_arms[6];
+    // weapon ownership widgets
+    st_multicon_t	w_arms[6];
 
-// face status widget
-static st_multicon_t	w_faces; 
+    // face status widget
+    st_multicon_t	w_faces; 
 
-// keycard widgets
-static st_multicon_t	w_keyboxes[3];
+    // keycard widgets
+    st_multicon_t	w_keyboxes[3];
 
-// armor widget
-static st_percent_t	w_armor;
+    // armor widget
+    st_percent_t	w_armor;
 
-// ammo widgets
-static st_number_t	w_ammo[4];
+    // ammo widgets
+    st_number_t	w_ammo[4];
 
-// max ammo widgets
-static st_number_t	w_maxammo[4]; 
+    // max ammo widgets
+    st_number_t	w_maxammo[4]; 
 
 
 
- // number of frags so far in deathmatch
-static int	st_fragscount;
+    // number of frags so far in deathmatch
+    int	st_fragscount;
 
-// used to use appopriately pained face
-static int	st_oldhealth = -1;
+    // used to use appopriately pained face
+    int	st_oldhealth;
 
-// used for evil grin
-static boolean	oldweaponsowned[NUMWEAPONS]; 
+    // used for evil grin
+    boolean	oldweaponsowned[NUMWEAPONS]; 
 
- // count until face changes
-static int	st_facecount = 0;
+    // count until face changes
+    int	st_facecount;
 
-// current face index, used by w_faces
-static int	st_faceindex = 0;
+    // current face index, used by w_faces
+    int	st_faceindex;
 
-// holds key-type for each key box on bar
-static int	keyboxes[3]; 
+    // holds key-type for each key box on bar
+    int	keyboxes[3]; 
 
-// a random number per tick
-static int	st_randomnumber;  
+    // a random number per tick
+    int	st_randomnumber;  
+} st_;
 
-cheatseq_t cheat_mus = CHEAT("idmus", 2);
-cheatseq_t cheat_god = CHEAT("iddqd", 0);
-cheatseq_t cheat_ammo = CHEAT("idkfa", 0);
-cheatseq_t cheat_ammonokey = CHEAT("idfa", 0);
-cheatseq_t cheat_noclip = CHEAT("idspispopd", 0);
-cheatseq_t cheat_commercial_noclip = CHEAT("idclip", 0);
+const cheatseq_t cheat_mus = CHEAT("idmus", 2);
+const cheatseq_t cheat_god = CHEAT("iddqd", 0);
+const cheatseq_t cheat_ammo = CHEAT("idkfa", 0);
+const cheatseq_t cheat_ammonokey = CHEAT("idfa", 0);
+const cheatseq_t cheat_noclip = CHEAT("idspispopd", 0);
+const cheatseq_t cheat_commercial_noclip = CHEAT("idclip", 0);
 
-cheatseq_t	cheat_powerup[7] =
+const cheatseq_t	cheat_powerup[7] =
 {
     CHEAT("idbeholdv", 0),
     CHEAT("idbeholds", 0),
@@ -403,9 +405,9 @@ cheatseq_t	cheat_powerup[7] =
     CHEAT("idbehold", 0),
 };
 
-cheatseq_t cheat_choppers = CHEAT("idchoppers", 0);
-cheatseq_t cheat_clev = CHEAT("idclev", 2);
-cheatseq_t cheat_mypos = CHEAT("idmypos", 0);
+const cheatseq_t cheat_choppers = CHEAT("idchoppers", 0);
+const cheatseq_t cheat_clev = CHEAT("idclev", 2);
+const cheatseq_t cheat_mypos = CHEAT("idmypos", 0);
 
 
 //
@@ -416,14 +418,14 @@ void ST_Stop(void);
 void ST_refreshBackground(void)
 {
 
-    if (st_statusbaron)
+    if (st_.st_statusbaron)
     {
         V_UseBuffer(st_backing_screen);
 
-	V_DrawPatch(ST_X, 0, sbar);
+	V_DrawPatch(ST_X, 0, st_.sbar);
 
 	if (netgame)
-	    V_DrawPatch(ST_FX, 0, faceback);
+	    V_DrawPatch(ST_FX, 0, st_.faceback);
 
         V_RestoreBuffer();
 
@@ -435,6 +437,8 @@ void ST_refreshBackground(void)
 
 // Respond to keyboard input events,
 //  intercept cheats.
+char plyr_msg[ST_MSGWIDTH];
+
 boolean
 ST_Responder (event_t* ev)
 {
@@ -447,13 +451,12 @@ ST_Responder (event_t* ev)
     switch(ev->data1)
     {
       case AM_MSGENTERED:
-	st_gamestate = AutomapState;
-	st_firsttime = true;
+	st_.st_gamestate = AutomapState;
+	st_.st_firsttime = true;
 	break;
 	
       case AM_MSGEXITED:
-	//	fprintf(stderr, "AM exited\n");
-	st_gamestate = FirstPersonState;
+	st_.st_gamestate = FirstPersonState;
 	break;
     }
   }
@@ -466,48 +469,48 @@ ST_Responder (event_t* ev)
       // 'dqd' cheat for toggleable god mode
       if (cht_CheckCheat(&cheat_god, ev->data2))
       {
-	plyr->cheats ^= CF_GODMODE;
-	if (plyr->cheats & CF_GODMODE)
+	st_.plyr->cheats ^= CF_GODMODE;
+	if (st_.plyr->cheats & CF_GODMODE)
 	{
-	  if (plyr->mo)
-	    plyr->mo->health = 100;
+	  if (st_.plyr->mo)
+	    st_.plyr->mo->health = 100;
 	  
-	  plyr->health = deh_god_mode_health;
-	  plyr->message = DEH_String(STSTR_DQDON);
+	  st_.plyr->health = deh_god_mode_health;
+	  st_.plyr->message = DEH_String(STSTR_DQDON);
 	}
 	else 
-	  plyr->message = DEH_String(STSTR_DQDOFF);
+	  st_.plyr->message = DEH_String(STSTR_DQDOFF);
       }
       // 'fa' cheat for killer fucking arsenal
       else if (cht_CheckCheat(&cheat_ammonokey, ev->data2))
       {
-	plyr->armorpoints = deh_idfa_armor;
-	plyr->armortype = deh_idfa_armor_class;
+	st_.plyr->armorpoints = deh_idfa_armor;
+	st_.plyr->armortype = deh_idfa_armor_class;
 	
 	for (i=0;i<NUMWEAPONS;i++)
-	  plyr->weaponowned[i] = true;
+	  st_.plyr->weaponowned[i] = true;
 	
 	for (i=0;i<NUMAMMO;i++)
-	  plyr->ammo[i] = plyr->maxammo[i];
+	  st_.plyr->ammo[i] = st_.plyr->maxammo[i];
 	
-	plyr->message = DEH_String(STSTR_FAADDED);
+	st_.plyr->message = DEH_String(STSTR_FAADDED);
       }
       // 'kfa' cheat for key full ammo
       else if (cht_CheckCheat(&cheat_ammo, ev->data2))
       {
-	plyr->armorpoints = deh_idkfa_armor;
-	plyr->armortype = deh_idkfa_armor_class;
+	st_.plyr->armorpoints = deh_idkfa_armor;
+	st_.plyr->armortype = deh_idkfa_armor_class;
 	
 	for (i=0;i<NUMWEAPONS;i++)
-	  plyr->weaponowned[i] = true;
+	  st_.plyr->weaponowned[i] = true;
 	
 	for (i=0;i<NUMAMMO;i++)
-	  plyr->ammo[i] = plyr->maxammo[i];
+	  st_.plyr->ammo[i] = st_.plyr->maxammo[i];
 	
 	for (i=0;i<NUMCARDS;i++)
-	  plyr->cards[i] = true;
+	  st_.plyr->cards[i] = true;
 	
-	plyr->message = DEH_String(STSTR_KFAADDED);
+	st_.plyr->message = DEH_String(STSTR_KFAADDED);
       }
       // 'mus' cheat for changing music
       else if (cht_CheckCheat(&cheat_mus, ev->data2))
@@ -516,7 +519,7 @@ ST_Responder (event_t* ev)
 	char	buf[3];
 	int		musnum;
 	
-	plyr->message = DEH_String(STSTR_MUS);
+	st_.plyr->message = DEH_String(STSTR_MUS);
 	cht_GetParam(&cheat_mus, buf);
 
         // Note: The original v1.9 had a bug that tried to play back
@@ -529,7 +532,7 @@ ST_Responder (event_t* ev)
 	  musnum = mus_runnin + (buf[0]-'0')*10 + buf[1]-'0' - 1;
 	  
 	  if (((buf[0]-'0')*10 + buf[1]-'0') > 35)
-	    plyr->message = DEH_String(STSTR_NOMUS);
+	    st_.plyr->message = DEH_String(STSTR_NOMUS);
 	  else
 	    S_ChangeMusic(musnum, 1);
 	}
@@ -538,7 +541,7 @@ ST_Responder (event_t* ev)
 	  musnum = mus_e1m1 + (buf[0]-'1')*9 + (buf[1]-'1');
 	  
 	  if (((buf[0]-'1')*9 + buf[1]-'1') > 31)
-	    plyr->message = DEH_String(STSTR_NOMUS);
+	    st_.plyr->message = DEH_String(STSTR_NOMUS);
 	  else
 	    S_ChangeMusic(musnum, 1);
 	}
@@ -552,50 +555,49 @@ ST_Responder (event_t* ev)
         // For Doom 1, use the idspipsopd cheat; for all others, use
         // idclip
 
-	plyr->cheats ^= CF_NOCLIP;
+	st_.plyr->cheats ^= CF_NOCLIP;
 	
-	if (plyr->cheats & CF_NOCLIP)
-	  plyr->message = DEH_String(STSTR_NCON);
+	if (st_.plyr->cheats & CF_NOCLIP)
+	  st_.plyr->message = DEH_String(STSTR_NCON);
 	else
-	  plyr->message = DEH_String(STSTR_NCOFF);
+	  st_.plyr->message = DEH_String(STSTR_NCOFF);
       }
       // 'behold?' power-up cheats
       for (i=0;i<6;i++)
       {
 	if (cht_CheckCheat(&cheat_powerup[i], ev->data2))
 	{
-	  if (!plyr->powers[i])
-	    P_GivePower( plyr, i);
+	  if (!st_.plyr->powers[i])
+	    P_GivePower( st_.plyr, i);
 	  else if (i!=pw_strength)
-	    plyr->powers[i] = 1;
+	    st_.plyr->powers[i] = 1;
 	  else
-	    plyr->powers[i] = 0;
+	    st_.plyr->powers[i] = 0;
 	  
-	  plyr->message = DEH_String(STSTR_BEHOLDX);
+	  st_.plyr->message = DEH_String(STSTR_BEHOLDX);
 	}
       }
       
       // 'behold' power-up menu
       if (cht_CheckCheat(&cheat_powerup[6], ev->data2))
       {
-	plyr->message = DEH_String(STSTR_BEHOLD);
+	st_.plyr->message = DEH_String(STSTR_BEHOLD);
       }
       // 'choppers' invulnerability & chainsaw
       else if (cht_CheckCheat(&cheat_choppers, ev->data2))
       {
-	plyr->weaponowned[wp_chainsaw] = true;
-	plyr->powers[pw_invulnerability] = true;
-	plyr->message = DEH_String(STSTR_CHOPPERS);
+	st_.plyr->weaponowned[wp_chainsaw] = true;
+	st_.plyr->powers[pw_invulnerability] = true;
+	st_.plyr->message = DEH_String(STSTR_CHOPPERS);
       }
       // 'mypos' for player position
       else if (cht_CheckCheat(&cheat_mypos, ev->data2))
       {
-        static char buf[ST_MSGWIDTH];
-        M_snprintf(buf, sizeof(buf), "ang=0x%x;x,y=(0x%x,0x%x)",
+        M_snprintf(plyr_msg, sizeof(plyr_msg), "ang=0x%x;x,y=(0x%x,0x%x)",
                    players[consoleplayer].mo->angle,
                    players[consoleplayer].mo->x,
                    players[consoleplayer].mo->y);
-        plyr->message = buf;
+        st_.plyr->message = plyr_msg;
       }
     }
     
@@ -653,7 +655,7 @@ ST_Responder (event_t* ev)
 	return false;
 
       // So be it.
-      plyr->message = DEH_String(STSTR_CLEV);
+      st_.plyr->message = DEH_String(STSTR_CLEV);
       G_DeferedInitNew(gameskill, epsd, map);
     }
   }
@@ -662,20 +664,20 @@ ST_Responder (event_t* ev)
 
 
 
+int	stpain_lastcalc;
+int	stpain_oldhealth;
 int ST_calcPainOffset(void)
 {
     int		health;
-    static int	lastcalc;
-    static int	oldhealth = -1;
     
-    health = plyr->health > 100 ? 100 : plyr->health;
+    health = st_.plyr->health > 100 ? 100 : st_.plyr->health;
 
-    if (health != oldhealth)
+    if (health != stpain_oldhealth)
     {
-	lastcalc = ST_FACESTRIDE * (((100 - health) * ST_NUMPAINFACES) / 101);
-	oldhealth = health;
+	stpain_lastcalc = ST_FACESTRIDE * (((100 - health) * ST_NUMPAINFACES) / 101);
+	stpain_oldhealth = health;
     }
-    return lastcalc;
+    return stpain_lastcalc;
 }
 
 
@@ -685,190 +687,200 @@ int ST_calcPainOffset(void)
 // the precedence of expressions is:
 //  dead > evil grin > turned head > straight ahead
 //
+boolean stfw_hasrun;
+int	stfw_lastattackdown;
+int	stfw_priority;
 void ST_updateFaceWidget(void)
 {
     int		i;
     angle_t	badguyangle;
     angle_t	diffang;
-    static int	lastattackdown = -1;
-    static int	priority = 0;
     boolean	doevilgrin;
 
-    if (priority < 10)
+    if (!stfw_hasrun) {
+        stfw_hasrun = true;
+        stfw_lastattackdown = -1;
+    }
+    if (stfw_priority < 10)
     {
 	// dead
-	if (!plyr->health)
+	if (!st_.plyr->health)
 	{
-	    priority = 9;
-	    st_faceindex = ST_DEADFACE;
-	    st_facecount = 1;
+	    stfw_priority = 9;
+	    st_.st_faceindex = ST_DEADFACE;
+	    st_.st_facecount = 1;
 	}
     }
 
-    if (priority < 9)
+    if (stfw_priority < 9)
     {
-	if (plyr->bonuscount)
+	if (st_.plyr->bonuscount)
 	{
 	    // picking up bonus
 	    doevilgrin = false;
 
 	    for (i=0;i<NUMWEAPONS;i++)
 	    {
-		if (oldweaponsowned[i] != plyr->weaponowned[i])
+		if (st_.oldweaponsowned[i] != st_.plyr->weaponowned[i])
 		{
 		    doevilgrin = true;
-		    oldweaponsowned[i] = plyr->weaponowned[i];
+		    st_.oldweaponsowned[i] = st_.plyr->weaponowned[i];
 		}
 	    }
 	    if (doevilgrin) 
 	    {
 		// evil grin if just picked up weapon
-		priority = 8;
-		st_facecount = ST_EVILGRINCOUNT;
-		st_faceindex = ST_calcPainOffset() + ST_EVILGRINOFFSET;
+		stfw_priority = 8;
+		st_.st_facecount = ST_EVILGRINCOUNT;
+		st_.st_faceindex = ST_calcPainOffset() + ST_EVILGRINOFFSET;
 	    }
 	}
 
     }
   
-    if (priority < 8)
+    if (stfw_priority < 8)
     {
-	if (plyr->damagecount
-	    && plyr->attacker
-	    && plyr->attacker != plyr->mo)
+	if (st_.plyr->damagecount
+	    && st_.plyr->attacker
+	    && st_.plyr->attacker != st_.plyr->mo)
 	{
 	    // being attacked
-	    priority = 7;
+	    stfw_priority = 7;
 	    
-	    if (plyr->health - st_oldhealth > ST_MUCHPAIN)
+	    if (st_.plyr->health - st_.st_oldhealth > ST_MUCHPAIN)
 	    {
-		st_facecount = ST_TURNCOUNT;
-		st_faceindex = ST_calcPainOffset() + ST_OUCHOFFSET;
+		st_.st_facecount = ST_TURNCOUNT;
+		st_.st_faceindex = ST_calcPainOffset() + ST_OUCHOFFSET;
 	    }
 	    else
 	    {
-		badguyangle = R_PointToAngle2(plyr->mo->x,
-					      plyr->mo->y,
-					      plyr->attacker->x,
-					      plyr->attacker->y);
+		badguyangle = R_PointToAngle2(st_.plyr->mo->x,
+					      st_.plyr->mo->y,
+					      st_.plyr->attacker->x,
+					      st_.plyr->attacker->y);
 		
-		if (badguyangle > plyr->mo->angle)
+		if (badguyangle > st_.plyr->mo->angle)
 		{
 		    // whether right or left
-		    diffang = badguyangle - plyr->mo->angle;
+		    diffang = badguyangle - st_.plyr->mo->angle;
 		    i = diffang > ANG180; 
 		}
 		else
 		{
 		    // whether left or right
-		    diffang = plyr->mo->angle - badguyangle;
+		    diffang = st_.plyr->mo->angle - badguyangle;
 		    i = diffang <= ANG180; 
 		} // confusing, aint it?
 
 		
-		st_facecount = ST_TURNCOUNT;
-		st_faceindex = ST_calcPainOffset();
+		st_.st_facecount = ST_TURNCOUNT;
+		st_.st_faceindex = ST_calcPainOffset();
 		
 		if (diffang < ANG45)
 		{
 		    // head-on    
-		    st_faceindex += ST_RAMPAGEOFFSET;
+		    st_.st_faceindex += ST_RAMPAGEOFFSET;
 		}
 		else if (i)
 		{
 		    // turn face right
-		    st_faceindex += ST_TURNOFFSET;
+		    st_.st_faceindex += ST_TURNOFFSET;
 		}
 		else
 		{
 		    // turn face left
-		    st_faceindex += ST_TURNOFFSET+1;
+		    st_.st_faceindex += ST_TURNOFFSET+1;
 		}
 	    }
 	}
     }
   
-    if (priority < 7)
+    if (stfw_priority < 7)
     {
 	// getting hurt because of your own damn stupidity
-	if (plyr->damagecount)
+	if (st_.plyr->damagecount)
 	{
-	    if (plyr->health - st_oldhealth > ST_MUCHPAIN)
+	    if (st_.plyr->health - st_.st_oldhealth > ST_MUCHPAIN)
 	    {
-		priority = 7;
-		st_facecount = ST_TURNCOUNT;
-		st_faceindex = ST_calcPainOffset() + ST_OUCHOFFSET;
+		stfw_priority = 7;
+		st_.st_facecount = ST_TURNCOUNT;
+		st_.st_faceindex = ST_calcPainOffset() + ST_OUCHOFFSET;
 	    }
 	    else
 	    {
-		priority = 6;
-		st_facecount = ST_TURNCOUNT;
-		st_faceindex = ST_calcPainOffset() + ST_RAMPAGEOFFSET;
+		stfw_priority = 6;
+		st_.st_facecount = ST_TURNCOUNT;
+		st_.st_faceindex = ST_calcPainOffset() + ST_RAMPAGEOFFSET;
 	    }
 
 	}
 
     }
   
-    if (priority < 6)
+    if (stfw_priority < 6)
     {
 	// rapid firing
-	if (plyr->attackdown)
+	if (st_.plyr->attackdown)
 	{
-	    if (lastattackdown==-1)
-		lastattackdown = ST_RAMPAGEDELAY;
-	    else if (!--lastattackdown)
+	    if (stfw_lastattackdown==-1)
+		stfw_lastattackdown = ST_RAMPAGEDELAY;
+	    else if (!--stfw_lastattackdown)
 	    {
-		priority = 5;
-		st_faceindex = ST_calcPainOffset() + ST_RAMPAGEOFFSET;
-		st_facecount = 1;
-		lastattackdown = 1;
+		stfw_priority = 5;
+		st_.st_faceindex = ST_calcPainOffset() + ST_RAMPAGEOFFSET;
+		st_.st_facecount = 1;
+		stfw_lastattackdown = 1;
 	    }
 	}
 	else
-	    lastattackdown = -1;
+	    stfw_lastattackdown = -1;
 
     }
   
-    if (priority < 5)
+    if (stfw_priority < 5)
     {
 	// invulnerability
-	if ((plyr->cheats & CF_GODMODE)
-	    || plyr->powers[pw_invulnerability])
+	if ((st_.plyr->cheats & CF_GODMODE)
+	    || st_.plyr->powers[pw_invulnerability])
 	{
-	    priority = 4;
+	    stfw_priority = 4;
 
-	    st_faceindex = ST_GODFACE;
-	    st_facecount = 1;
+	    st_.st_faceindex = ST_GODFACE;
+	    st_.st_facecount = 1;
 
 	}
 
     }
 
     // look left or look right if the facecount has timed out
-    if (!st_facecount)
+    if (!st_.st_facecount)
     {
-	st_faceindex = ST_calcPainOffset() + (st_randomnumber % 3);
-	st_facecount = ST_STRAIGHTFACECOUNT;
-	priority = 0;
+	st_.st_faceindex = ST_calcPainOffset() + (st_.st_randomnumber % 3);
+	st_.st_facecount = ST_STRAIGHTFACECOUNT;
+	stfw_priority = 0;
     }
 
-    st_facecount--;
+    st_.st_facecount--;
 
 }
 
+boolean stuw_hasrun;
+int	stuw_largeammo;
 void ST_updateWidgets(void)
 {
-    static int	largeammo = 1994; // means "n/a"
     int		i;
+    if (!stuw_hasrun) {
+        stuw_hasrun = true;
+        stuw_largeammo = 1994; // means "n/a"
+    }
 
     // must redirect the pointer if the ready weapon has changed.
     //  if (w_ready.data != plyr->readyweapon)
     //  {
-    if (weaponinfo[plyr->readyweapon].ammo == am_noammo)
-	w_ready.num = &largeammo;
+    if (weaponinfo[st_.plyr->readyweapon].ammo == am_noammo)
+	st_.w_ready.num = &stuw_largeammo;
     else
-	w_ready.num = &plyr->ammo[weaponinfo[plyr->readyweapon].ammo];
+	st_.w_ready.num = &st_.plyr->ammo[weaponinfo[st_.plyr->readyweapon].ammo];
     //{
     // static int tic=0;
     // static int dir=-1;
@@ -878,7 +890,7 @@ void ST_updateWidgets(void)
     //   dir = 1;
     // tic++;
     // }
-    w_ready.data = plyr->readyweapon;
+    st_.w_ready.data = st_.plyr->readyweapon;
 
     // if (*w_ready.on)
     //  STlib_updateNum(&w_ready, true);
@@ -888,50 +900,50 @@ void ST_updateWidgets(void)
     // update keycard multiple widgets
     for (i=0;i<3;i++)
     {
-	keyboxes[i] = plyr->cards[i] ? i : -1;
+	st_.keyboxes[i] = st_.plyr->cards[i] ? i : -1;
 
-	if (plyr->cards[i+3])
-	    keyboxes[i] = i+3;
+	if (st_.plyr->cards[i+3])
+	    st_.keyboxes[i] = i+3;
     }
 
     // refresh everything if this is him coming back to life
     ST_updateFaceWidget();
 
     // used by the w_armsbg widget
-    st_notdeathmatch = !deathmatch;
+    st_.st_notdeathmatch = !deathmatch;
     
     // used by w_arms[] widgets
-    st_armson = st_statusbaron && !deathmatch; 
+    st_.st_armson = st_.st_statusbaron && !deathmatch; 
 
     // used by w_frags widget
-    st_fragson = deathmatch && st_statusbaron; 
-    st_fragscount = 0;
+    st_.st_fragson = deathmatch && st_.st_statusbaron; 
+    st_.st_fragscount = 0;
 
     for (i=0 ; i<MAXPLAYERS ; i++)
     {
 	if (i != consoleplayer)
-	    st_fragscount += plyr->frags[i];
+	    st_.st_fragscount += st_.plyr->frags[i];
 	else
-	    st_fragscount -= plyr->frags[i];
+	    st_.st_fragscount -= st_.plyr->frags[i];
     }
 
     // get rid of chat window if up because of message
-    if (!--st_msgcounter)
-	st_chat = st_oldchat;
+    if (!--st_.st_msgcounter)
+	st_.st_chat = st_.st_oldchat;
 
 }
 
 void ST_Ticker (void)
 {
 
-    st_clock++;
-    st_randomnumber = M_Random();
+    st_.st_clock++;
+    st_.st_randomnumber = M_Random();
     ST_updateWidgets();
-    st_oldhealth = plyr->health;
+    st_.st_oldhealth = st_.plyr->health;
 
 }
 
-static int st_palette = 0;
+int stdp_palette;
 
 void ST_doPaletteStuff(void)
 {
@@ -941,12 +953,12 @@ void ST_doPaletteStuff(void)
     int		cnt;
     int		bzc;
 
-    cnt = plyr->damagecount;
+    cnt = st_.plyr->damagecount;
 
-    if (plyr->powers[pw_strength])
+    if (st_.plyr->powers[pw_strength])
     {
 	// slowly fade the berzerk out
-  	bzc = 12 - (plyr->powers[pw_strength]>>6);
+  	bzc = 12 - (st_.plyr->powers[pw_strength]>>6);
 
 	if (bzc > cnt)
 	    cnt = bzc;
@@ -962,9 +974,9 @@ void ST_doPaletteStuff(void)
 	palette += STARTREDPALS;
     }
 
-    else if (plyr->bonuscount)
+    else if (st_.plyr->bonuscount)
     {
-	palette = (plyr->bonuscount+7)>>3;
+	palette = (st_.plyr->bonuscount+7)>>3;
 
 	if (palette >= NUMBONUSPALS)
 	    palette = NUMBONUSPALS-1;
@@ -972,8 +984,8 @@ void ST_doPaletteStuff(void)
 	palette += STARTBONUSPALS;
     }
 
-    else if ( plyr->powers[pw_ironfeet] > 4*32
-	      || plyr->powers[pw_ironfeet]&8)
+    else if ( st_.plyr->powers[pw_ironfeet] > 4*32
+	      || st_.plyr->powers[pw_ironfeet]&8)
 	palette = RADIATIONPAL;
     else
 	palette = 0;
@@ -989,10 +1001,10 @@ void ST_doPaletteStuff(void)
         palette = RADIATIONPAL;
     }
 
-    if (palette != st_palette)
+    if (palette != stdp_palette)
     {
-	st_palette = palette;
-	pal = (byte *) W_CacheLumpNum (lu_palette, PU_CACHE)+palette*768;
+	stdp_palette = palette;
+	pal = (byte *) W_CacheLumpNum (st_.lu_palette, PU_CACHE)+palette*768;
 	I_SetPalette (pal);
     }
 
@@ -1003,40 +1015,40 @@ void ST_drawWidgets(boolean refresh)
     int		i;
 
     // used by w_arms[] widgets
-    st_armson = st_statusbaron && !deathmatch;
+    st_.st_armson = st_.st_statusbaron && !deathmatch;
 
     // used by w_frags widget
-    st_fragson = deathmatch && st_statusbaron; 
+    st_.st_fragson = deathmatch && st_.st_statusbaron; 
 
-    STlib_updateNum(&w_ready, refresh);
+    STlib_updateNum(&st_.w_ready, refresh);
 
     for (i=0;i<4;i++)
     {
-	STlib_updateNum(&w_ammo[i], refresh);
-	STlib_updateNum(&w_maxammo[i], refresh);
+	STlib_updateNum(&st_.w_ammo[i], refresh);
+	STlib_updateNum(&st_.w_maxammo[i], refresh);
     }
 
-    STlib_updatePercent(&w_health, refresh);
-    STlib_updatePercent(&w_armor, refresh);
+    STlib_updatePercent(&st_.w_health, refresh);
+    STlib_updatePercent(&st_.w_armor, refresh);
 
-    STlib_updateBinIcon(&w_armsbg, refresh);
+    STlib_updateBinIcon(&st_.w_armsbg, refresh);
 
     for (i=0;i<6;i++)
-	STlib_updateMultIcon(&w_arms[i], refresh);
+	STlib_updateMultIcon(&st_.w_arms[i], refresh);
 
-    STlib_updateMultIcon(&w_faces, refresh);
+    STlib_updateMultIcon(&st_.w_faces, refresh);
 
     for (i=0;i<3;i++)
-	STlib_updateMultIcon(&w_keyboxes[i], refresh);
+	STlib_updateMultIcon(&st_.w_keyboxes[i], refresh);
 
-    STlib_updateNum(&w_frags, refresh);
+    STlib_updateNum(&st_.w_frags, refresh);
 
 }
 
 void ST_doRefresh(void)
 {
 
-    st_firsttime = false;
+    st_.st_firsttime = false;
 
     // draw status bar background to off-screen buff
     ST_refreshBackground();
@@ -1055,14 +1067,14 @@ void ST_diffDraw(void)
 void ST_Drawer (boolean fullscreen, boolean refresh)
 {
   
-    st_statusbaron = (!fullscreen) || automapactive;
-    st_firsttime = st_firsttime || refresh;
+    st_.st_statusbaron = (!fullscreen) || automapactive;
+    st_.st_firsttime = st_.st_firsttime || refresh;
 
     // Do red-/gold-shifts from damage/items
     ST_doPaletteStuff();
 
     // If just after ST_Start(), refresh all
-    if (st_firsttime) ST_doRefresh();
+    if (st_.st_firsttime) ST_doRefresh();
     // Otherwise, update as little as possible
     else ST_diffDraw();
 
@@ -1086,26 +1098,26 @@ static void ST_loadUnloadGraphics(load_callback_t callback)
     for (i=0;i<10;i++)
     {
 	DEH_snprintf(namebuf, 9, "STTNUM%d", i);
-        callback(namebuf, &tallnum[i]);
+        callback(namebuf, &st_.tallnum[i]);
 
 	DEH_snprintf(namebuf, 9, "STYSNUM%d", i);
-        callback(namebuf, &shortnum[i]);
+        callback(namebuf, &st_.shortnum[i]);
     }
 
     // Load percent key.
     //Note: why not load STMINUS here, too?
 
-    callback(DEH_String("STTPRCNT"), &tallpercent);
+    callback(DEH_String("STTPRCNT"), &st_.tallpercent);
 
     // key cards
     for (i=0;i<NUMCARDS;i++)
     {
     	DEH_snprintf(namebuf, 9, "STKEYS%d", i);
-        callback(namebuf, &keys[i]);
+        callback(namebuf, &st_.keys[i]);
     }
 
     // arms background
-    callback(DEH_String("STARMS"), &armsbg);
+    callback(DEH_String("STARMS"), &st_.armsbg);
 
     // arms ownership widgets
     for (i=0; i<6; i++)
@@ -1113,18 +1125,18 @@ static void ST_loadUnloadGraphics(load_callback_t callback)
     	DEH_snprintf(namebuf, 9, "STGNUM%d", i+2);
 
     	// gray #
-        callback(namebuf, &arms[i][0]);
+        callback(namebuf, &st_.arms[i][0]);
 
         // yellow #
-        arms[i][1] = shortnum[i+2];
+        st_.arms[i][1] = st_.shortnum[i+2];
     }
 
     // face backgrounds for different color players
     DEH_snprintf(namebuf, 9, "STFB%d", consoleplayer);
-    callback(namebuf, &faceback);
+    callback(namebuf, &st_.faceback);
 
     // status bar background bits
-    callback(DEH_String("STBAR"), &sbar);
+    callback(DEH_String("STBAR"), &st_.sbar);
 
     // face states
     facenum = 0;
@@ -1133,29 +1145,29 @@ static void ST_loadUnloadGraphics(load_callback_t callback)
 	for (j=0; j<ST_NUMSTRAIGHTFACES; j++)
 	{
 	    DEH_snprintf(namebuf, 9, "STFST%d%d", i, j);
-            callback(namebuf, &faces[facenum]);
+            callback(namebuf, &st_.faces[facenum]);
             ++facenum;
 	}
 	DEH_snprintf(namebuf, 9, "STFTR%d0", i);	// turn right
-        callback(namebuf, &faces[facenum]);
+        callback(namebuf, &st_.faces[facenum]);
         ++facenum;
 	DEH_snprintf(namebuf, 9, "STFTL%d0", i);	// turn left
-        callback(namebuf, &faces[facenum]);
+        callback(namebuf, &st_.faces[facenum]);
         ++facenum;
 	DEH_snprintf(namebuf, 9, "STFOUCH%d", i);	// ouch!
-        callback(namebuf, &faces[facenum]);
+        callback(namebuf, &st_.faces[facenum]);
         ++facenum;
 	DEH_snprintf(namebuf, 9, "STFEVL%d", i);	// evil grin ;)
-        callback(namebuf, &faces[facenum]);
+        callback(namebuf, &st_.faces[facenum]);
         ++facenum;
 	DEH_snprintf(namebuf, 9, "STFKILL%d", i);	// pissed off
-        callback(namebuf, &faces[facenum]);
+        callback(namebuf, &st_.faces[facenum]);
         ++facenum;
     }
 
-    callback(DEH_String("STFGOD0"), &faces[facenum]);
+    callback(DEH_String("STFGOD0"), &st_.faces[facenum]);
     ++facenum;
-    callback(DEH_String("STFDEAD0"), &faces[facenum]);
+    callback(DEH_String("STFDEAD0"), &st_.faces[facenum]);
     ++facenum;
 }
 
@@ -1171,7 +1183,7 @@ void ST_loadGraphics(void)
 
 void ST_loadData(void)
 {
-    lu_palette = W_GetNumForName (DEH_String("PLAYPAL"));
+    st_.lu_palette = W_GetNumForName (DEH_String("PLAYPAL"));
     ST_loadGraphics();
 }
 
@@ -1196,27 +1208,27 @@ void ST_initData(void)
 
     int		i;
 
-    st_firsttime = true;
-    plyr = &players[consoleplayer];
+    st_.st_firsttime = true;
+    st_.plyr = &players[consoleplayer];
 
-    st_clock = 0;
-    st_chatstate = StartChatState;
-    st_gamestate = FirstPersonState;
+    st_.st_clock = 0;
+    st_.st_chatstate = StartChatState;
+    st_.st_gamestate = FirstPersonState;
 
-    st_statusbaron = true;
-    st_oldchat = st_chat = false;
-    st_cursoron = false;
+    st_.st_statusbaron = true;
+    st_.st_oldchat = st_.st_chat = false;
+    st_.st_cursoron = false;
 
-    st_faceindex = 0;
-    st_palette = -1;
+    st_.st_faceindex = 0;
+    stdp_palette = -1;
 
-    st_oldhealth = -1;
+    st_.st_oldhealth = -1;
 
     for (i=0;i<NUMWEAPONS;i++)
-	oldweaponsowned[i] = plyr->weaponowned[i];
+	st_.oldweaponsowned[i] = st_.plyr->weaponowned[i];
 
     for (i=0;i<3;i++)
-	keyboxes[i] = -1;
+	st_.keyboxes[i] = -1;
 
     STlib_init();
 
@@ -1230,186 +1242,185 @@ void ST_createWidgets(void)
     int i;
 
     // ready weapon ammo
-    STlib_initNum(&w_ready,
+    STlib_initNum(&st_.w_ready,
 		  ST_AMMOX,
 		  ST_AMMOY,
-		  tallnum,
-		  &plyr->ammo[weaponinfo[plyr->readyweapon].ammo],
-		  &st_statusbaron,
+		  st_.tallnum,
+		  &st_.plyr->ammo[weaponinfo[st_.plyr->readyweapon].ammo],
+		  &st_.st_statusbaron,
 		  ST_AMMOWIDTH );
 
     // the last weapon type
-    w_ready.data = plyr->readyweapon; 
+    st_.w_ready.data = st_.plyr->readyweapon; 
 
     // health percentage
-    STlib_initPercent(&w_health,
+    STlib_initPercent(&st_.w_health,
 		      ST_HEALTHX,
 		      ST_HEALTHY,
-		      tallnum,
-		      &plyr->health,
-		      &st_statusbaron,
-		      tallpercent);
+		      st_.tallnum,
+		      &st_.plyr->health,
+		      &st_.st_statusbaron,
+		      st_.tallpercent);
 
     // arms background
-    STlib_initBinIcon(&w_armsbg,
+    STlib_initBinIcon(&st_.w_armsbg,
 		      ST_ARMSBGX,
 		      ST_ARMSBGY,
-		      armsbg,
-		      &st_notdeathmatch,
-		      &st_statusbaron);
+		      st_.armsbg,
+		      &st_.st_notdeathmatch,
+		      &st_.st_statusbaron);
 
     // weapons owned
     for(i=0;i<6;i++)
     {
-	STlib_initMultIcon(&w_arms[i],
+	STlib_initMultIcon(&st_.w_arms[i],
 			   ST_ARMSX+(i%3)*ST_ARMSXSPACE,
 			   ST_ARMSY+(i/3)*ST_ARMSYSPACE,
-			   arms[i], (int *) &plyr->weaponowned[i+1],
-			   &st_armson);
+			   st_.arms[i], (int *) &st_.plyr->weaponowned[i+1],
+			   &st_.st_armson);
     }
 
     // frags sum
-    STlib_initNum(&w_frags,
+    STlib_initNum(&st_.w_frags,
 		  ST_FRAGSX,
 		  ST_FRAGSY,
-		  tallnum,
-		  &st_fragscount,
-		  &st_fragson,
+		  st_.tallnum,
+		  &st_.st_fragscount,
+		  &st_.st_fragson,
 		  ST_FRAGSWIDTH);
 
     // faces
-    STlib_initMultIcon(&w_faces,
+    STlib_initMultIcon(&st_.w_faces,
 		       ST_FACESX,
 		       ST_FACESY,
-		       faces,
-		       &st_faceindex,
-		       &st_statusbaron);
+		       st_.faces,
+		       &st_.st_faceindex,
+		       &st_.st_statusbaron);
 
     // armor percentage - should be colored later
-    STlib_initPercent(&w_armor,
+    STlib_initPercent(&st_.w_armor,
 		      ST_ARMORX,
 		      ST_ARMORY,
-		      tallnum,
-		      &plyr->armorpoints,
-		      &st_statusbaron, tallpercent);
+		      st_.tallnum,
+		      &st_.plyr->armorpoints,
+		      &st_.st_statusbaron, st_.tallpercent);
 
     // keyboxes 0-2
-    STlib_initMultIcon(&w_keyboxes[0],
+    STlib_initMultIcon(&st_.w_keyboxes[0],
 		       ST_KEY0X,
 		       ST_KEY0Y,
-		       keys,
-		       &keyboxes[0],
-		       &st_statusbaron);
+		       st_.keys,
+		       &st_.keyboxes[0],
+		       &st_.st_statusbaron);
     
-    STlib_initMultIcon(&w_keyboxes[1],
+    STlib_initMultIcon(&st_.w_keyboxes[1],
 		       ST_KEY1X,
 		       ST_KEY1Y,
-		       keys,
-		       &keyboxes[1],
-		       &st_statusbaron);
+		       st_.keys,
+		       &st_.keyboxes[1],
+		       &st_.st_statusbaron);
 
-    STlib_initMultIcon(&w_keyboxes[2],
+    STlib_initMultIcon(&st_.w_keyboxes[2],
 		       ST_KEY2X,
 		       ST_KEY2Y,
-		       keys,
-		       &keyboxes[2],
-		       &st_statusbaron);
+		       st_.keys,
+		       &st_.keyboxes[2],
+		       &st_.st_statusbaron);
 
     // ammo count (all four kinds)
-    STlib_initNum(&w_ammo[0],
+    STlib_initNum(&st_.w_ammo[0],
 		  ST_AMMO0X,
 		  ST_AMMO0Y,
-		  shortnum,
-		  &plyr->ammo[0],
-		  &st_statusbaron,
+		  st_.shortnum,
+		  &st_.plyr->ammo[0],
+		  &st_.st_statusbaron,
 		  ST_AMMO0WIDTH);
 
-    STlib_initNum(&w_ammo[1],
+    STlib_initNum(&st_.w_ammo[1],
 		  ST_AMMO1X,
 		  ST_AMMO1Y,
-		  shortnum,
-		  &plyr->ammo[1],
-		  &st_statusbaron,
+		  st_.shortnum,
+		  &st_.plyr->ammo[1],
+		  &st_.st_statusbaron,
 		  ST_AMMO1WIDTH);
 
-    STlib_initNum(&w_ammo[2],
+    STlib_initNum(&st_.w_ammo[2],
 		  ST_AMMO2X,
 		  ST_AMMO2Y,
-		  shortnum,
-		  &plyr->ammo[2],
-		  &st_statusbaron,
+		  st_.shortnum,
+		  &st_.plyr->ammo[2],
+		  &st_.st_statusbaron,
 		  ST_AMMO2WIDTH);
     
-    STlib_initNum(&w_ammo[3],
+    STlib_initNum(&st_.w_ammo[3],
 		  ST_AMMO3X,
 		  ST_AMMO3Y,
-		  shortnum,
-		  &plyr->ammo[3],
-		  &st_statusbaron,
+		  st_.shortnum,
+		  &st_.plyr->ammo[3],
+		  &st_.st_statusbaron,
 		  ST_AMMO3WIDTH);
 
     // max ammo count (all four kinds)
-    STlib_initNum(&w_maxammo[0],
+    STlib_initNum(&st_.w_maxammo[0],
 		  ST_MAXAMMO0X,
 		  ST_MAXAMMO0Y,
-		  shortnum,
-		  &plyr->maxammo[0],
-		  &st_statusbaron,
+		  st_.shortnum,
+		  &st_.plyr->maxammo[0],
+		  &st_.st_statusbaron,
 		  ST_MAXAMMO0WIDTH);
 
-    STlib_initNum(&w_maxammo[1],
+    STlib_initNum(&st_.w_maxammo[1],
 		  ST_MAXAMMO1X,
 		  ST_MAXAMMO1Y,
-		  shortnum,
-		  &plyr->maxammo[1],
-		  &st_statusbaron,
+		  st_.shortnum,
+		  &st_.plyr->maxammo[1],
+		  &st_.st_statusbaron,
 		  ST_MAXAMMO1WIDTH);
 
-    STlib_initNum(&w_maxammo[2],
+    STlib_initNum(&st_.w_maxammo[2],
 		  ST_MAXAMMO2X,
 		  ST_MAXAMMO2Y,
-		  shortnum,
-		  &plyr->maxammo[2],
-		  &st_statusbaron,
+		  st_.shortnum,
+		  &st_.plyr->maxammo[2],
+		  &st_.st_statusbaron,
 		  ST_MAXAMMO2WIDTH);
     
-    STlib_initNum(&w_maxammo[3],
+    STlib_initNum(&st_.w_maxammo[3],
 		  ST_MAXAMMO3X,
 		  ST_MAXAMMO3Y,
-		  shortnum,
-		  &plyr->maxammo[3],
-		  &st_statusbaron,
+		  st_.shortnum,
+		  &st_.plyr->maxammo[3],
+		  &st_.st_statusbaron,
 		  ST_MAXAMMO3WIDTH);
 
 }
 
-static boolean	st_stopped = true;
-
-
+boolean st_startrun;
 void ST_Start (void)
 {
 
-    if (!st_stopped)
+    if (st_startrun)
 	ST_Stop();
 
     ST_initData();
     ST_createWidgets();
-    st_stopped = false;
+    st_startrun = true;
 
 }
 
 void ST_Stop (void)
 {
-    if (st_stopped)
+    if (!st_startrun)
 	return;
 
-    I_SetPalette (W_CacheLumpNum (lu_palette, PU_CACHE));
+    I_SetPalette (W_CacheLumpNum (st_.lu_palette, PU_CACHE));
 
-    st_stopped = true;
+    st_startrun = false;
 }
 
 void ST_Init (void)
 {
+    st_.st_oldhealth = -1;
     ST_loadData();
     st_backing_screen = (byte *) Z_Malloc(ST_WIDTH * ST_HEIGHT, PU_STATIC, 0);
 }
diff --git a/doomgeneric/st_stuff.h b/doomgeneric/st_stuff.h
index 8ed53e4..3a857e1 100644
--- a/doomgeneric/st_stuff.h
+++ b/doomgeneric/st_stuff.h
@@ -74,16 +74,16 @@ typedef enum
 
 
 extern byte *st_backing_screen;
-extern cheatseq_t cheat_mus;
-extern cheatseq_t cheat_god;
-extern cheatseq_t cheat_ammo;
-extern cheatseq_t cheat_ammonokey;
-extern cheatseq_t cheat_noclip;
-extern cheatseq_t cheat_commercial_noclip;
-extern cheatseq_t cheat_powerup[7];
-extern cheatseq_t cheat_choppers;
-extern cheatseq_t cheat_clev;
-extern cheatseq_t cheat_mypos;
+extern const cheatseq_t cheat_mus;
+extern const cheatseq_t cheat_god;
+extern const cheatseq_t cheat_ammo;
+extern const cheatseq_t cheat_ammonokey;
+extern const cheatseq_t cheat_noclip;
+extern const cheatseq_t cheat_commercial_noclip;
+extern const cheatseq_t cheat_powerup[7];
+extern const cheatseq_t cheat_choppers;
+extern const cheatseq_t cheat_clev;
+extern const cheatseq_t cheat_mypos;
 
 
 #endif
diff --git a/doomgeneric/statdump.c b/doomgeneric/statdump.c
index 7afe3f3..27a5adb 100644
--- a/doomgeneric/statdump.c
+++ b/doomgeneric/statdump.c
@@ -29,6 +29,7 @@
 
 #include "statdump.h"
 
+#if ORIGCODE
 /* Par times for E1M1-E1M9. */
 static const int doom1_par_times[] =
 {
@@ -41,8 +42,6 @@ static const int doom2_par_times[] =
     30, 90, 120, 120, 90, 150, 120, 120, 270,
 };
 
-#if ORIGCODE
-
 /* Player colors. */
 static const char *player_colors[] =
 {
@@ -54,8 +53,8 @@ static const char *player_colors[] =
 // Array of end-of-level statistics that have been captured.
 
 #define MAX_CAPTURES 32
-static wbstartstruct_t captured_stats[MAX_CAPTURES];
-static int num_captured_stats = 0;
+wbstartstruct_t sdmp_captured_stats[MAX_CAPTURES];
+int sdmp_num_sdmp_captured_stats = 0;
 
 #if ORIGCODE
 static GameMission_t discovered_gamemission = none;
@@ -332,11 +331,11 @@ static void PrintStats(FILE *stream, wbstartstruct_t *stats)
 
 void StatCopy(wbstartstruct_t *stats)
 {
-    if (M_ParmExists("-statdump") && num_captured_stats < MAX_CAPTURES)
+    if (M_ParmExists("-statdump") && sdmp_num_sdmp_captured_stats < MAX_CAPTURES)
     {
-        memcpy(&captured_stats[num_captured_stats], stats,
+        memcpy(&sdmp_captured_stats[sdmp_num_sdmp_captured_stats], stats,
                sizeof(wbstartstruct_t));
-        ++num_captured_stats;
+        ++sdmp_num_sdmp_captured_stats;
     }
 }
 
@@ -359,12 +358,12 @@ void StatDump(void)
 
     if (i > 0)
     {
-        printf("Statistics captured for %i level(s)\n", num_captured_stats);
+        printf("Statistics captured for %i level(s)\n", sdmp_num_sdmp_captured_stats);
 
         // We actually know what the real gamemission is, but this has
         // to match the output from statdump.exe.
 
-        DiscoverGamemode(captured_stats, num_captured_stats);
+        DiscoverGamemode(sdmp_captured_stats, sdmp_num_sdmp_captured_stats);
 
         // Allow "-" as output file, for stdout.
 
@@ -377,9 +376,9 @@ void StatDump(void)
             dumpfile = NULL;
         }
 
-        for (i = 0; i < num_captured_stats; ++i)
+        for (i = 0; i < sdmp_num_sdmp_captured_stats; ++i)
         {
-            PrintStats(dumpfile, &captured_stats[i]);
+            PrintStats(dumpfile, &sdmp_captured_stats[i]);
         }
 
         if (dumpfile != NULL)
diff --git a/doomgeneric/tables.c b/doomgeneric/tables.c
index c221e9a..dd8537d 100644
--- a/doomgeneric/tables.c
+++ b/doomgeneric/tables.c
@@ -1862,7 +1862,7 @@ const int finesine[10240] =
     65534,65535,65535,65535,65535,65535,65535,65535
 };
 
-const fixed_t *finecosine = &finesine[FINEANGLES/4];
+const fixed_t * const finecosine = &finesine[FINEANGLES/4];
 
 const angle_t tantoangle[2049] =
 {
diff --git a/doomgeneric/tables.h b/doomgeneric/tables.h
index 495fd53..cde0ee0 100644
--- a/doomgeneric/tables.h
+++ b/doomgeneric/tables.h
@@ -49,7 +49,7 @@
 extern const fixed_t finesine[5*FINEANGLES/4];
 
 // Re-use data, is just PI/2 pahse shift.
-extern const fixed_t *finecosine;
+extern const fixed_t * const finecosine;
 
 
 // Effective size is 4096.
diff --git a/doomgeneric/v_video.c b/doomgeneric/v_video.c
index 6db28aa..c6218fe 100644
--- a/doomgeneric/v_video.c
+++ b/doomgeneric/v_video.c
@@ -55,13 +55,13 @@ byte *xlatab = NULL;
 
 // The screen buffer that the v_video.c code draws to.
 
-static byte *dest_screen = NULL;
+byte *vv_dest_screen = NULL;
 
 int dirtybox[4]; 
 
 // haleyjd 08/28/10: clipping callback function for patches.
 // This is needed for Chocolate Strife, which clips patches to the screen.
-static vpatchclipfunc_t patchclip_callback = NULL;
+vpatchclipfunc_t vv_patchclip_callback = NULL;
 
 //
 // V_MarkRect 
@@ -71,7 +71,7 @@ void V_MarkRect(int x, int y, int width, int height)
     // If we are temporarily using an alternate screen, do not 
     // affect the update box.
 
-    if (dest_screen == I_VideoBuffer)
+    if (vv_dest_screen == I_VideoBuffer)
     {
         M_AddToBox (dirtybox, x, y); 
         M_AddToBox (dirtybox, x + width-1, y + height-1); 
@@ -106,7 +106,7 @@ void V_CopyRect(int srcx, int srcy, byte *source,
     V_MarkRect(destx, desty, width, height); 
  
     src = source + SCREENWIDTH * srcy + srcx; 
-    dest = dest_screen + SCREENWIDTH * desty + destx; 
+    dest = vv_dest_screen + SCREENWIDTH * desty + destx; 
 
     for ( ; height>0 ; height--) 
     { 
@@ -128,7 +128,7 @@ void V_CopyRect(int srcx, int srcy, byte *source,
 //
 void V_SetPatchClipCallback(vpatchclipfunc_t func)
 {
-    patchclip_callback = func;
+    vv_patchclip_callback = func;
 }
 
 //
@@ -150,9 +150,9 @@ void V_DrawPatch(int x, int y, patch_t *patch)
     x -= SHORT(patch->leftoffset);
 
     // haleyjd 08/28/10: Strife needs silent error checking here.
-    if(patchclip_callback)
+    if(vv_patchclip_callback)
     {
-        if(!patchclip_callback(patch, x, y))
+        if(!vv_patchclip_callback(patch, x, y))
             return;
     }
 
@@ -169,7 +169,7 @@ void V_DrawPatch(int x, int y, patch_t *patch)
     V_MarkRect(x, y, SHORT(patch->width), SHORT(patch->height));
 
     col = 0;
-    desttop = dest_screen + y * SCREENWIDTH + x;
+    desttop = vv_dest_screen + y * SCREENWIDTH + x;
 
     w = SHORT(patch->width);
 
@@ -214,9 +214,9 @@ void V_DrawPatchFlipped(int x, int y, patch_t *patch)
     x -= SHORT(patch->leftoffset); 
 
     // haleyjd 08/28/10: Strife needs silent error checking here.
-    if(patchclip_callback)
+    if(vv_patchclip_callback)
     {
-        if(!patchclip_callback(patch, x, y))
+        if(!vv_patchclip_callback(patch, x, y))
             return;
     }
 
@@ -233,7 +233,7 @@ void V_DrawPatchFlipped(int x, int y, patch_t *patch)
     V_MarkRect (x, y, SHORT(patch->width), SHORT(patch->height));
 
     col = 0;
-    desttop = dest_screen + y * SCREENWIDTH + x;
+    desttop = vv_dest_screen + y * SCREENWIDTH + x;
 
     w = SHORT(patch->width);
 
@@ -295,7 +295,7 @@ void V_DrawTLPatch(int x, int y, patch_t * patch)
     }
 
     col = 0;
-    desttop = dest_screen + y * SCREENWIDTH + x;
+    desttop = vv_dest_screen + y * SCREENWIDTH + x;
 
     w = SHORT(patch->width);
     for (; col < w; x++, col++, desttop++)
@@ -336,14 +336,14 @@ void V_DrawXlaPatch(int x, int y, patch_t * patch)
     y -= SHORT(patch->topoffset);
     x -= SHORT(patch->leftoffset);
 
-    if(patchclip_callback)
+    if(vv_patchclip_callback)
     {
-        if(!patchclip_callback(patch, x, y))
+        if(!vv_patchclip_callback(patch, x, y))
             return;
     }
 
     col = 0;
-    desttop = dest_screen + y * SCREENWIDTH + x;
+    desttop = vv_dest_screen + y * SCREENWIDTH + x;
 
     w = SHORT(patch->width);
     for(; col < w; x++, col++, desttop++)
@@ -394,7 +394,7 @@ void V_DrawAltTLPatch(int x, int y, patch_t * patch)
     }
 
     col = 0;
-    desttop = dest_screen + y * SCREENWIDTH + x;
+    desttop = vv_dest_screen + y * SCREENWIDTH + x;
 
     w = SHORT(patch->width);
     for (; col < w; x++, col++, desttop++)
@@ -445,8 +445,8 @@ void V_DrawShadowedPatch(int x, int y, patch_t *patch)
     }
 
     col = 0;
-    desttop = dest_screen + y * SCREENWIDTH + x;
-    desttop2 = dest_screen + (y + 2) * SCREENWIDTH + x + 2;
+    desttop = vv_dest_screen + y * SCREENWIDTH + x;
+    desttop2 = vv_dest_screen + (y + 2) * SCREENWIDTH + x + 2;
 
     w = SHORT(patch->width);
     for (; col < w; x++, col++, desttop++, desttop2++)
@@ -516,7 +516,7 @@ void V_DrawBlock(int x, int y, int width, int height, byte *src)
  
     V_MarkRect (x, y, width, height); 
  
-    dest = dest_screen + y * SCREENWIDTH + x; 
+    dest = vv_dest_screen + y * SCREENWIDTH + x; 
 
     while (height--) 
     { 
@@ -588,7 +588,7 @@ void V_DrawBox(int x, int y, int w, int h, int c)
  
 void V_DrawRawScreen(byte *raw)
 {
-    memcpy(dest_screen, raw, SCREENWIDTH * SCREENHEIGHT);
+    memcpy(vv_dest_screen, raw, SCREENWIDTH * SCREENHEIGHT);
 }
 
 //
@@ -605,14 +605,14 @@ void V_Init (void)
 
 void V_UseBuffer(byte *buffer)
 {
-    dest_screen = buffer;
+    vv_dest_screen = buffer;
 }
 
 // Restore screen buffer to the i_video screen buffer.
 
 void V_RestoreBuffer(void)
 {
-    dest_screen = I_VideoBuffer;
+    vv_dest_screen = I_VideoBuffer;
 }
 
 //
diff --git a/doomgeneric/w_checksum.c b/doomgeneric/w_checksum.c
index 5933fdf..b6dfad0 100644
--- a/doomgeneric/w_checksum.c
+++ b/doomgeneric/w_checksum.c
@@ -25,17 +25,17 @@
 #include "w_checksum.h"
 #include "w_wad.h"
 
-static wad_file_t **open_wadfiles = NULL;
-static int num_open_wadfiles = 0;
+wad_file_t **wc_open_wadfiles = NULL;
+int wc_num_open_wadfiles = 0;
 
 static int GetFileNumber(wad_file_t *handle)
 {
     int i;
     int result;
 
-    for (i=0; i<num_open_wadfiles; ++i)
+    for (i=0; i<wc_num_open_wadfiles; ++i)
     {
-        if (open_wadfiles[i] == handle)
+        if (wc_open_wadfiles[i] == handle)
         {
             return i;
         }
@@ -44,12 +44,12 @@ static int GetFileNumber(wad_file_t *handle)
     // Not found in list.  This is a new file we haven't seen yet.
     // Allocate another slot for this file.
 
-    open_wadfiles = realloc(open_wadfiles,
-                            sizeof(wad_file_t *) * (num_open_wadfiles + 1));
-    open_wadfiles[num_open_wadfiles] = handle;
+    wc_open_wadfiles = realloc(wc_open_wadfiles,
+                            sizeof(wad_file_t *) * (wc_num_open_wadfiles + 1));
+    wc_open_wadfiles[wc_num_open_wadfiles] = handle;
 
-    result = num_open_wadfiles;
-    ++num_open_wadfiles;
+    result = wc_num_open_wadfiles;
+    ++wc_num_open_wadfiles;
 
     return result;
 }
@@ -72,7 +72,7 @@ void W_Checksum(sha1_digest_t digest)
 
     SHA1_Init(&sha1_context);
 
-    num_open_wadfiles = 0;
+    wc_num_open_wadfiles = 0;
 
     // Go through each entry in the WAD directory, adding information
     // about each entry to the SHA1 hash.
diff --git a/doomgeneric/w_file.c b/doomgeneric/w_file.c
index cce3737..ea93153 100644
--- a/doomgeneric/w_file.c
+++ b/doomgeneric/w_file.c
@@ -37,7 +37,7 @@ extern wad_file_class_t win32_wad_file;
 extern wad_file_class_t posix_wad_file;
 #endif 
 
-static wad_file_class_t *wad_file_classes[] = 
+static const wad_file_class_t *const wad_file_classes[] = 
 {
 /*
 #ifdef _WIN32
diff --git a/doomgeneric/w_file_stdc.c b/doomgeneric/w_file_stdc.c
index 829e960..9385590 100644
--- a/doomgeneric/w_file_stdc.c
+++ b/doomgeneric/w_file_stdc.c
@@ -28,7 +28,7 @@ typedef struct
     FILE *fstream;
 } stdc_wad_file_t;
 
-extern wad_file_class_t stdc_wad_file;
+extern const wad_file_class_t stdc_wad_file;
 
 static wad_file_t *W_StdC_OpenFile(char *path)
 {
@@ -45,7 +45,7 @@ static wad_file_t *W_StdC_OpenFile(char *path)
     // Create a new stdc_wad_file_t to hold the file handle.
 
     result = Z_Malloc(sizeof(stdc_wad_file_t), PU_STATIC, 0);
-    result->wad.file_class = &stdc_wad_file;
+    result->wad.file_class = (wad_file_class_t *)&stdc_wad_file;
     result->wad.mapped = NULL;
     result->wad.length = M_FileLength(fstream);
     result->fstream = fstream;
@@ -66,7 +66,7 @@ static void W_StdC_CloseFile(wad_file_t *wad)
 // Read data from the specified position in the file into the 
 // provided buffer.  Returns the number of bytes read.
 
-size_t W_StdC_Read(wad_file_t *wad, unsigned int offset,
+static size_t W_StdC_Read(wad_file_t *wad, unsigned int offset,
                    void *buffer, size_t buffer_len)
 {
     stdc_wad_file_t *stdc_wad;
@@ -86,7 +86,7 @@ size_t W_StdC_Read(wad_file_t *wad, unsigned int offset,
 }
 
 
-wad_file_class_t stdc_wad_file = 
+const wad_file_class_t stdc_wad_file = 
 {
     W_StdC_OpenFile,
     W_StdC_CloseFile,
diff --git a/doomgeneric/w_wad.c b/doomgeneric/w_wad.c
index 1248046..ae9cd99 100644
--- a/doomgeneric/w_wad.c
+++ b/doomgeneric/w_wad.c
@@ -63,7 +63,7 @@ unsigned int numlumps = 0;
 
 // Hash table for fast lookups
 
-static lumpinfo_t **lumphash;
+lumpinfo_t **ww_lumphash;
 
 // Hash function used for lump names.
 
@@ -227,10 +227,10 @@ wad_file_t *W_AddFile (char *filename)
 
     Z_Free(fileinfo);
 
-    if (lumphash != NULL)
+    if (ww_lumphash != NULL)
     {
-        Z_Free(lumphash);
-        lumphash = NULL;
+        Z_Free(ww_lumphash);
+        ww_lumphash = NULL;
     }
 
     return wad_file;
@@ -260,7 +260,7 @@ int W_CheckNumForName (char* name)
 
     // Do we have a hash table yet?
 
-    if (lumphash != NULL)
+    if (ww_lumphash != NULL)
     {
         int hash;
         
@@ -268,7 +268,7 @@ int W_CheckNumForName (char* name)
 
         hash = W_LumpNameHash(name) % numlumps;
         
-        for (lump_p = lumphash[hash]; lump_p != NULL; lump_p = lump_p->next)
+        for (lump_p = ww_lumphash[hash]; lump_p != NULL; lump_p = lump_p->next)
         {
             if (!strncasecmp(lump_p->name, name, 8))
             {
@@ -542,16 +542,16 @@ void W_GenerateHashTable(void)
 
     // Free the old hash table, if there is one
 
-    if (lumphash != NULL)
+    if (ww_lumphash != NULL)
     {
-        Z_Free(lumphash);
+        Z_Free(ww_lumphash);
     }
 
     // Generate hash table
     if (numlumps > 0)
     {
-        lumphash = Z_Malloc(sizeof(lumpinfo_t *) * numlumps, PU_STATIC, NULL);
-        memset(lumphash, 0, sizeof(lumpinfo_t *) * numlumps);
+        ww_lumphash = Z_Malloc(sizeof(lumpinfo_t *) * numlumps, PU_STATIC, NULL);
+        memset(ww_lumphash, 0, sizeof(lumpinfo_t *) * numlumps);
 
         for (i=0; i<numlumps; ++i)
         {
@@ -561,8 +561,8 @@ void W_GenerateHashTable(void)
 
             // Hook into the hash table
 
-            lumpinfo[i].next = lumphash[hash];
-            lumphash[hash] = &lumpinfo[i];
+            lumpinfo[i].next = ww_lumphash[hash];
+            ww_lumphash[hash] = &lumpinfo[i];
         }
     }
 
diff --git a/doomgeneric/wi_stuff.c b/doomgeneric/wi_stuff.c
index ddb9a66..e52a37e 100644
--- a/doomgeneric/wi_stuff.c
+++ b/doomgeneric/wi_stuff.c
@@ -85,7 +85,7 @@
 
 // NET GAME STUFF
 #define NG_STATSY		50
-#define NG_STATSX		(32 + SHORT(star->width)/2 + 32*!dofrags)
+#define NG_STATSX		(32 + SHORT(wi_.star->width)/2 + 32*!wi_dofrags)
 
 #define NG_SPACINGX    		64
 
@@ -96,7 +96,7 @@
 
 #define DM_SPACINGX		40
 
-#define DM_TOTALSX		269
+#define widm_totalsX		269
 
 #define DM_KILLERSX		10
 #define DM_KILLERSY		100
@@ -149,6 +149,10 @@ typedef struct
     // LEVEL: n/a
     int		data2; 
 
+} anim_t;
+
+typedef struct
+{
     // actual graphics for frames of animations
     patch_t*	p[3]; 
 
@@ -166,10 +170,10 @@ typedef struct
     // used by RANDOM and LEVEL when animating
     int		state;  
 
-} anim_t;
+} anim_state_t;
 
 
-static point_t lnodes[NUMEPISODES][NUMMAPS] =
+static const point_t lnodes[NUMEPISODES][NUMMAPS] =
 {
     // Episode 0 World Map
     {
@@ -219,56 +223,56 @@ static point_t lnodes[NUMEPISODES][NUMMAPS] =
 //  as they replace 320x200 full screen frames.
 //
 
-#define ANIM(type, period, nanims, x, y, nexttic)            \
-   { (type), (period), (nanims), { (x), (y) }, (nexttic),    \
-     0, { NULL, NULL, NULL }, 0, 0, 0, 0 }
+#define ANIM(type, period, nanims, x, y)            \
+   { (type), (period), (nanims), { (x), (y) } }
 
 
-static anim_t epsd0animinfo[] =
+static const anim_t epsd0animinfo[] =
 {
-    ANIM(ANIM_ALWAYS, TICRATE/3, 3, 224, 104, 0),
-    ANIM(ANIM_ALWAYS, TICRATE/3, 3, 184, 160, 0),
-    ANIM(ANIM_ALWAYS, TICRATE/3, 3, 112, 136, 0),
-    ANIM(ANIM_ALWAYS, TICRATE/3, 3, 72, 112, 0),
-    ANIM(ANIM_ALWAYS, TICRATE/3, 3, 88, 96, 0),
-    ANIM(ANIM_ALWAYS, TICRATE/3, 3, 64, 48, 0),
-    ANIM(ANIM_ALWAYS, TICRATE/3, 3, 192, 40, 0),
-    ANIM(ANIM_ALWAYS, TICRATE/3, 3, 136, 16, 0),
-    ANIM(ANIM_ALWAYS, TICRATE/3, 3, 80, 16, 0),
-    ANIM(ANIM_ALWAYS, TICRATE/3, 3, 64, 24, 0),
+    ANIM(ANIM_ALWAYS, TICRATE/3, 3, 224, 104),
+    ANIM(ANIM_ALWAYS, TICRATE/3, 3, 184, 160),
+    ANIM(ANIM_ALWAYS, TICRATE/3, 3, 112, 136),
+    ANIM(ANIM_ALWAYS, TICRATE/3, 3, 72, 112),
+    ANIM(ANIM_ALWAYS, TICRATE/3, 3, 88, 96),
+    ANIM(ANIM_ALWAYS, TICRATE/3, 3, 64, 48),
+    ANIM(ANIM_ALWAYS, TICRATE/3, 3, 192, 40),
+    ANIM(ANIM_ALWAYS, TICRATE/3, 3, 136, 16),
+    ANIM(ANIM_ALWAYS, TICRATE/3, 3, 80, 16),
+    ANIM(ANIM_ALWAYS, TICRATE/3, 3, 64, 24),
 };
 
-static anim_t epsd1animinfo[] =
+static const anim_t epsd1animinfo[] =
 {
-    ANIM(ANIM_LEVEL, TICRATE/3, 1, 128, 136, 1),
-    ANIM(ANIM_LEVEL, TICRATE/3, 1, 128, 136, 2),
-    ANIM(ANIM_LEVEL, TICRATE/3, 1, 128, 136, 3),
-    ANIM(ANIM_LEVEL, TICRATE/3, 1, 128, 136, 4),
-    ANIM(ANIM_LEVEL, TICRATE/3, 1, 128, 136, 5),
-    ANIM(ANIM_LEVEL, TICRATE/3, 1, 128, 136, 6),
-    ANIM(ANIM_LEVEL, TICRATE/3, 1, 128, 136, 7),
-    ANIM(ANIM_LEVEL, TICRATE/3, 3, 192, 144, 8),
-    ANIM(ANIM_LEVEL, TICRATE/3, 1, 128, 136, 8),
+    ANIM(ANIM_LEVEL, TICRATE/3, 1, 128, 136),
+    ANIM(ANIM_LEVEL, TICRATE/3, 1, 128, 136),
+    ANIM(ANIM_LEVEL, TICRATE/3, 1, 128, 136),
+    ANIM(ANIM_LEVEL, TICRATE/3, 1, 128, 136),
+    ANIM(ANIM_LEVEL, TICRATE/3, 1, 128, 136),
+    ANIM(ANIM_LEVEL, TICRATE/3, 1, 128, 136),
+    ANIM(ANIM_LEVEL, TICRATE/3, 1, 128, 136),
+    ANIM(ANIM_LEVEL, TICRATE/3, 3, 192, 144),
+    ANIM(ANIM_LEVEL, TICRATE/3, 1, 128, 136),
 };
 
-static anim_t epsd2animinfo[] =
+static const anim_t epsd2animinfo[] =
 {
-    ANIM(ANIM_ALWAYS, TICRATE/3, 3, 104, 168, 0),
-    ANIM(ANIM_ALWAYS, TICRATE/3, 3, 40, 136, 0),
-    ANIM(ANIM_ALWAYS, TICRATE/3, 3, 160, 96, 0),
-    ANIM(ANIM_ALWAYS, TICRATE/3, 3, 104, 80, 0),
-    ANIM(ANIM_ALWAYS, TICRATE/3, 3, 120, 32, 0),
-    ANIM(ANIM_ALWAYS, TICRATE/4, 3, 40, 0, 0),
+    ANIM(ANIM_ALWAYS, TICRATE/3, 3, 104, 168),
+    ANIM(ANIM_ALWAYS, TICRATE/3, 3, 40, 136),
+    ANIM(ANIM_ALWAYS, TICRATE/3, 3, 160, 96),
+    ANIM(ANIM_ALWAYS, TICRATE/3, 3, 104, 80),
+    ANIM(ANIM_ALWAYS, TICRATE/3, 3, 120, 32),
+    ANIM(ANIM_ALWAYS, TICRATE/4, 3, 40, 0),
 };
 
-static int NUMANIMS[NUMEPISODES] =
+static const int NUMANIMS[NUMEPISODES] =
 {
     arrlen(epsd0animinfo),
     arrlen(epsd1animinfo),
     arrlen(epsd2animinfo),
 };
+#define MAXANIMS	10
 
-static anim_t *anims[NUMEPISODES] =
+static const anim_t * const anims[NUMEPISODES] =
 {
     epsd0animinfo,
     epsd1animinfo,
@@ -298,101 +302,105 @@ static anim_t *anims[NUMEPISODES] =
 #define SHOWNEXTLOCDELAY	4
 //#define SHOWLASTLOCDELAY	SHOWNEXTLOCDELAY
 
+struct {
+	// used to accelerate or skip a stage
+	int		acceleratestage;
 
-// used to accelerate or skip a stage
-static int		acceleratestage;
+	// wbs->pnum
+	int		me;
 
-// wbs->pnum
-static int		me;
+	// specifies current state
+	stateenum_t	state;
 
- // specifies current state
-static stateenum_t	state;
+	// contains information passed into intermission
+	wbstartstruct_t*	wbs;
 
-// contains information passed into intermission
-static wbstartstruct_t*	wbs;
+	wbplayerstruct_t* plrs;  // wbs->plyr[]
 
-static wbplayerstruct_t* plrs;  // wbs->plyr[]
+	// used for general timing
+	int 		cnt;  
 
-// used for general timing
-static int 		cnt;  
+	// used for timing of background animation
+	int 		bcnt;
 
-// used for timing of background animation
-static int 		bcnt;
+	// signals to refresh everything for one frame
+	int 		firstrefresh; 
 
-// signals to refresh everything for one frame
-static int 		firstrefresh; 
+	int		cnt_kills[MAXPLAYERS];
+	int		cnt_items[MAXPLAYERS];
+	int		cnt_secret[MAXPLAYERS];
+	int		cnt_time;
+	int		cnt_par;
+	int		cnt_pause;
 
-static int		cnt_kills[MAXPLAYERS];
-static int		cnt_items[MAXPLAYERS];
-static int		cnt_secret[MAXPLAYERS];
-static int		cnt_time;
-static int		cnt_par;
-static int		cnt_pause;
+	// # of commercial levels
+	int		NUMCMAPS; 
 
-// # of commercial levels
-static int		NUMCMAPS; 
 
+	//
+	//	GRAPHICS
+	//
 
-//
-//	GRAPHICS
-//
+	// You Are Here graphic
+	patch_t*		yah[3];
 
-// You Are Here graphic
-static patch_t*		yah[3] = { NULL, NULL, NULL }; 
+	// splat
+	patch_t*		splat[2];
 
-// splat
-static patch_t*		splat[2] = { NULL, NULL };
+	// %, : graphics
+	patch_t*		percent;
+	patch_t*		colon;
 
-// %, : graphics
-static patch_t*		percent;
-static patch_t*		colon;
+	// 0-9 graphic
+	patch_t*		num[10];
 
-// 0-9 graphic
-static patch_t*		num[10];
+	// minus sign
+	patch_t*		wiminus;
 
-// minus sign
-static patch_t*		wiminus;
+	// "Finished!" graphics
+	patch_t*		finished;
 
-// "Finished!" graphics
-static patch_t*		finished;
+	// "Entering" graphic
+	patch_t*		entering; 
 
-// "Entering" graphic
-static patch_t*		entering; 
+	// "secret"
+	patch_t*		sp_secret;
 
-// "secret"
-static patch_t*		sp_secret;
+	// "Kills", "Scrt", "Items", "Frags"
+	patch_t*		kills;
+	patch_t*		secret;
+	patch_t*		items;
+	patch_t*		frags;
 
- // "Kills", "Scrt", "Items", "Frags"
-static patch_t*		kills;
-static patch_t*		secret;
-static patch_t*		items;
-static patch_t*		frags;
+	// Time sucks.
+	patch_t*		timepatch;
+	patch_t*		par;
+	patch_t*		sucks;
 
-// Time sucks.
-static patch_t*		timepatch;
-static patch_t*		par;
-static patch_t*		sucks;
+	// "killers", "victims"
+	patch_t*		killers;
+	patch_t*		victims; 
 
-// "killers", "victims"
-static patch_t*		killers;
-static patch_t*		victims; 
+	// "Total", your face, your dead face
+	patch_t*		total;
+	patch_t*		star;
+	patch_t*		bstar;
 
-// "Total", your face, your dead face
-static patch_t*		total;
-static patch_t*		star;
-static patch_t*		bstar;
+	// "red P[1..MAXPLAYERS]"
+	patch_t*		p[MAXPLAYERS];
 
-// "red P[1..MAXPLAYERS]"
-static patch_t*		p[MAXPLAYERS];
+	// "gray P[1..MAXPLAYERS]"
+	patch_t*		bp[MAXPLAYERS];
 
-// "gray P[1..MAXPLAYERS]"
-static patch_t*		bp[MAXPLAYERS];
+	// Name graphics of each level (centered)
+	patch_t**	lnames;
 
- // Name graphics of each level (centered)
-static patch_t**	lnames;
+	// Buffer storing the backdrop
+	patch_t *background;
 
-// Buffer storing the backdrop
-static patch_t *background;
+	// local animation state, now structures are const
+	anim_state_t an_state[NUMEPISODES][MAXANIMS];
+} wi_;
 
 //
 // CODE
@@ -401,7 +409,7 @@ static patch_t *background;
 // slam background
 void WI_slamBackground(void)
 {
-    V_DrawPatch(0, 0, background);
+    V_DrawPatch(0, 0, wi_.background);
 }
 
 // The ticker is used to detect keys
@@ -417,22 +425,22 @@ void WI_drawLF(void)
 {
     int y = WI_TITLEY;
 
-    if (gamemode != commercial || wbs->last < NUMCMAPS)
+    if (gamemode != commercial || wi_.wbs->last < wi_.NUMCMAPS)
     {
         // draw <LevelName> 
-        V_DrawPatch((SCREENWIDTH - SHORT(lnames[wbs->last]->width))/2,
-                    y, lnames[wbs->last]);
+        V_DrawPatch((SCREENWIDTH - SHORT(wi_.lnames[wi_.wbs->last]->width))/2,
+                    y, wi_.lnames[wi_.wbs->last]);
 
         // draw "Finished!"
-        y += (5*SHORT(lnames[wbs->last]->height))/4;
+        y += (5*SHORT(wi_.lnames[wi_.wbs->last]->height))/4;
 
-        V_DrawPatch((SCREENWIDTH - SHORT(finished->width)) / 2, y, finished);
+        V_DrawPatch((SCREENWIDTH - SHORT(wi_.finished->width)) / 2, y, wi_.finished);
     }
-    else if (wbs->last == NUMCMAPS)
+    else if (wi_.wbs->last == wi_.NUMCMAPS)
     {
         // MAP33 - nothing is displayed!
     }
-    else if (wbs->last > NUMCMAPS)
+    else if (wi_.wbs->last > wi_.NUMCMAPS)
     {
         // > MAP33.  Doom bombs out here with a Bad V_DrawPatch error.
         // I'm pretty sure that doom2.exe is just reading into random
@@ -454,16 +462,16 @@ void WI_drawEL(void)
     int y = WI_TITLEY;
 
     // draw "Entering"
-    V_DrawPatch((SCREENWIDTH - SHORT(entering->width))/2,
+    V_DrawPatch((SCREENWIDTH - SHORT(wi_.entering->width))/2,
 		y,
-                entering);
+                wi_.entering);
 
     // draw level
-    y += (5*SHORT(lnames[wbs->next]->height))/4;
+    y += (5*SHORT(wi_.lnames[wi_.wbs->next]->height))/4;
 
-    V_DrawPatch((SCREENWIDTH - SHORT(lnames[wbs->next]->width))/2,
+    V_DrawPatch((SCREENWIDTH - SHORT(wi_.lnames[wi_.wbs->next]->width))/2,
 		y, 
-                lnames[wbs->next]);
+                wi_.lnames[wi_.wbs->next]);
 
 }
 
@@ -483,8 +491,8 @@ WI_drawOnLnode
     i = 0;
     do
     {
-	left = lnodes[wbs->epsd][n].x - SHORT(c[i]->leftoffset);
-	top = lnodes[wbs->epsd][n].y - SHORT(c[i]->topoffset);
+	left = lnodes[wi_.wbs->epsd][n].x - SHORT(c[i]->leftoffset);
+	top = lnodes[wi_.wbs->epsd][n].y - SHORT(c[i]->topoffset);
 	right = left + SHORT(c[i]->width);
 	bottom = top + SHORT(c[i]->height);
 
@@ -503,8 +511,8 @@ WI_drawOnLnode
 
     if (fits && i<2)
     {
-	V_DrawPatch(lnodes[wbs->epsd][n].x,
-                    lnodes[wbs->epsd][n].y,
+	V_DrawPatch(lnodes[wi_.wbs->epsd][n].x,
+                    lnodes[wi_.wbs->epsd][n].y,
 		    c[i]);
     }
     else
@@ -515,32 +523,33 @@ WI_drawOnLnode
 }
 
 
-
 void WI_initAnimatedBack(void)
 {
     int		i;
-    anim_t*	a;
+    const anim_t*	a;
+    anim_state_t*	s;
 
     if (gamemode == commercial)
 	return;
 
-    if (wbs->epsd > 2)
+    if (wi_.wbs->epsd > 2)
 	return;
 
-    for (i=0;i<NUMANIMS[wbs->epsd];i++)
+    for (i=0;i<NUMANIMS[wi_.wbs->epsd];i++)
     {
-	a = &anims[wbs->epsd][i];
+	a = &anims[wi_.wbs->epsd][i];
+    s = &wi_.an_state[wi_.wbs->epsd][i];
 
 	// init variables
-	a->ctr = -1;
+	s->ctr = -1;
 
 	// specify the next time to draw it
 	if (a->type == ANIM_ALWAYS)
-	    a->nexttic = bcnt + 1 + (M_Random()%a->period);
+	    s->nexttic = wi_.bcnt + 1 + (M_Random()%a->period);
 	else if (a->type == ANIM_RANDOM)
-	    a->nexttic = bcnt + 1 + a->data2+(M_Random()%a->data1);
+	    s->nexttic = wi_.bcnt + 1 + a->data2+(M_Random()%a->data1);
 	else if (a->type == ANIM_LEVEL)
-	    a->nexttic = bcnt + 1;
+	    s->nexttic = wi_.bcnt + 1;
     }
 
 }
@@ -548,45 +557,47 @@ void WI_initAnimatedBack(void)
 void WI_updateAnimatedBack(void)
 {
     int		i;
-    anim_t*	a;
+    const anim_t*	a;
+    anim_state_t*       s;
 
     if (gamemode == commercial)
 	return;
 
-    if (wbs->epsd > 2)
+    if (wi_.wbs->epsd > 2)
 	return;
 
-    for (i=0;i<NUMANIMS[wbs->epsd];i++)
+    for (i=0;i<NUMANIMS[wi_.wbs->epsd];i++)
     {
-	a = &anims[wbs->epsd][i];
+	a = &anims[wi_.wbs->epsd][i];
+        s = &wi_.an_state[wi_.wbs->epsd][i];
 
-	if (bcnt == a->nexttic)
+	if (wi_.bcnt == s->nexttic)
 	{
 	    switch (a->type)
 	    {
 	      case ANIM_ALWAYS:
-		if (++a->ctr >= a->nanims) a->ctr = 0;
-		a->nexttic = bcnt + a->period;
+		if (++s->ctr >= a->nanims) s->ctr = 0;
+		s->nexttic = wi_.bcnt + a->period;
 		break;
 
 	      case ANIM_RANDOM:
-		a->ctr++;
-		if (a->ctr == a->nanims)
+		s->ctr++;
+		if (s->ctr == a->nanims)
 		{
-		    a->ctr = -1;
-		    a->nexttic = bcnt+a->data2+(M_Random()%a->data1);
+		    s->ctr = -1;
+		    s->nexttic = wi_.bcnt+a->data2+(M_Random()%a->data1);
 		}
-		else a->nexttic = bcnt + a->period;
+		else s->nexttic = wi_.bcnt + a->period;
 		break;
 		
 	      case ANIM_LEVEL:
 		// gawd-awful hack for level anims
-		if (!(state == StatCount && i == 7)
-		    && wbs->next == a->data1)
+		if (!(wi_.state == StatCount && i == 7)
+		    && wi_.wbs->next == a->data1)
 		{
-		    a->ctr++;
-		    if (a->ctr == a->nanims) a->ctr--;
-		    a->nexttic = bcnt + a->period;
+		    s->ctr++;
+		    if (s->ctr == a->nanims) s->ctr--;
+		    s->nexttic = wi_.bcnt + a->period;
 		}
 		break;
 	    }
@@ -599,20 +610,23 @@ void WI_updateAnimatedBack(void)
 void WI_drawAnimatedBack(void)
 {
     int			i;
-    anim_t*		a;
+    const anim_t*	a;
+    anim_state_t*       s;
 
     if (gamemode == commercial)
 	return;
 
-    if (wbs->epsd > 2)
+    if (wi_.wbs->epsd > 2)
 	return;
 
-    for (i=0 ; i<NUMANIMS[wbs->epsd] ; i++)
+    for (i=0 ; i<NUMANIMS[wi_.wbs->epsd] ; i++)
     {
-	a = &anims[wbs->epsd][i];
+	a = &anims[wi_.wbs->epsd][i];
+	s = &wi_.an_state[wi_.wbs->epsd][i];
 
-	if (a->ctr >= 0)
-	    V_DrawPatch(a->loc.x, a->loc.y, a->p[a->ctr]);
+	if (s->ctr >= 0) {
+	    V_DrawPatch(a->loc.x, a->loc.y, s->p[s->ctr]);
+	}
     }
 
 }
@@ -632,7 +646,7 @@ WI_drawNum
   int		digits )
 {
 
-    int		fontwidth = SHORT(num[0]->width);
+    int		fontwidth = SHORT(wi_.num[0]->width);
     int		neg;
     int		temp;
 
@@ -669,13 +683,13 @@ WI_drawNum
     while (digits--)
     {
 	x -= fontwidth;
-	V_DrawPatch(x, y, num[ n % 10 ]);
+	V_DrawPatch(x, y, wi_.num[ n % 10 ]);
 	n /= 10;
     }
 
     // draw a minus sign if necessary
     if (neg)
-	V_DrawPatch(x-=8, y, wiminus);
+	V_DrawPatch(x-=8, y, wi_.wiminus);
 
     return x;
 
@@ -690,7 +704,7 @@ WI_drawPercent
     if (p < 0)
 	return;
 
-    V_DrawPatch(x, y, percent);
+    V_DrawPatch(x, y, wi_.percent);
     WI_drawNum(x, y, p, -1);
 }
 
@@ -720,19 +734,19 @@ WI_drawTime
 	do
 	{
 	    n = (t / div) % 60;
-	    x = WI_drawNum(x, y, n, 2) - SHORT(colon->width);
+	    x = WI_drawNum(x, y, n, 2) - SHORT(wi_.colon->width);
 	    div *= 60;
 
 	    // draw
 	    if (div==60 || t / div)
-		V_DrawPatch(x, y, colon);
+		V_DrawPatch(x, y, wi_.colon);
 	    
 	} while (t / div);
     }
     else
     {
 	// "sucks"
-	V_DrawPatch(x - SHORT(sucks->width), y, sucks); 
+	V_DrawPatch(x - SHORT(wi_.sucks->width), y, wi_.sucks); 
     }
 }
 
@@ -745,16 +759,16 @@ void WI_End(void)
 
 void WI_initNoState(void)
 {
-    state = NoState;
-    acceleratestage = 0;
-    cnt = 10;
+    wi_.state = NoState;
+    wi_.acceleratestage = 0;
+    wi_.cnt = 10;
 }
 
 void WI_updateNoState(void) {
 
     WI_updateAnimatedBack();
 
-    if (!--cnt)
+    if (!--wi_.cnt)
     {
         // Don't call WI_End yet.  G_WorldDone doesnt immediately 
         // change gamestate, so WI_Drawer is still going to get
@@ -766,14 +780,14 @@ void WI_updateNoState(void) {
 
 }
 
-static boolean		snl_pointeron = false;
+boolean		snl_pointeron;
 
 
 void WI_initShowNextLoc(void)
 {
-    state = ShowNextLoc;
-    acceleratestage = 0;
-    cnt = SHOWNEXTLOCDELAY * TICRATE;
+    wi_.state = ShowNextLoc;
+    wi_.acceleratestage = 0;
+    wi_.cnt = SHOWNEXTLOCDELAY * TICRATE;
 
     WI_initAnimatedBack();
 }
@@ -782,10 +796,10 @@ void WI_updateShowNextLoc(void)
 {
     WI_updateAnimatedBack();
 
-    if (!--cnt || acceleratestage)
+    if (!--wi_.cnt || wi_.acceleratestage)
 	WI_initNoState();
     else
-	snl_pointeron = (cnt & 31) < 20;
+	snl_pointeron = (wi_.cnt & 31) < 20;
 }
 
 void WI_drawShowNextLoc(void)
@@ -801,30 +815,30 @@ void WI_drawShowNextLoc(void)
 
     if ( gamemode != commercial)
     {
-  	if (wbs->epsd > 2)
+  	if (wi_.wbs->epsd > 2)
 	{
 	    WI_drawEL();
 	    return;
 	}
 	
-	last = (wbs->last == 8) ? wbs->next - 1 : wbs->last;
+	last = (wi_.wbs->last == 8) ? wi_.wbs->next - 1 : wi_.wbs->last;
 
 	// draw a splat on taken cities.
 	for (i=0 ; i<=last ; i++)
-	    WI_drawOnLnode(i, splat);
+	    WI_drawOnLnode(i, wi_.splat);
 
 	// splat the secret level?
-	if (wbs->didsecret)
-	    WI_drawOnLnode(8, splat);
+	if (wi_.wbs->didsecret)
+	    WI_drawOnLnode(8, wi_.splat);
 
 	// draw flashing ptr
 	if (snl_pointeron)
-	    WI_drawOnLnode(wbs->next, yah); 
+	    WI_drawOnLnode(wi_.wbs->next, wi_.yah); 
     }
 
     // draws which level you are entering..
     if ( (gamemode != commercial)
-	 || wbs->next != 30)
+	 || wi_.wbs->next != 30)
 	WI_drawEL();  
 
 }
@@ -845,13 +859,13 @@ int WI_fragSum(int playernum)
 	if (playeringame[i]
 	    && i!=playernum)
 	{
-	    frags += plrs[playernum].frags[i];
+	    frags += wi_.plrs[playernum].frags[i];
 	}
     }
 
 	
     // JDC hack - negative frags.
-    frags -= plrs[playernum].frags[playernum];
+    frags -= wi_.plrs[playernum].frags[playernum];
     // UNUSED if (frags < 0)
     // 	frags = 0;
 
@@ -860,9 +874,9 @@ int WI_fragSum(int playernum)
 
 
 
-static int		dm_state;
-static int		dm_frags[MAXPLAYERS][MAXPLAYERS];
-static int		dm_totals[MAXPLAYERS];
+int		widm_state;
+int		widm_frags[MAXPLAYERS][MAXPLAYERS];
+int		widm_totals[MAXPLAYERS];
 
 
 
@@ -872,11 +886,11 @@ void WI_initDeathmatchStats(void)
     int		i;
     int		j;
 
-    state = StatCount;
-    acceleratestage = 0;
-    dm_state = 1;
+    wi_.state = StatCount;
+    wi_.acceleratestage = 0;
+    widm_state = 1;
 
-    cnt_pause = TICRATE;
+    wi_.cnt_pause = TICRATE;
 
     for (i=0 ; i<MAXPLAYERS ; i++)
     {
@@ -884,9 +898,9 @@ void WI_initDeathmatchStats(void)
 	{
 	    for (j=0 ; j<MAXPLAYERS ; j++)
 		if (playeringame[j])
-		    dm_frags[i][j] = 0;
+		    widm_frags[i][j] = 0;
 
-	    dm_totals[i] = 0;
+	    widm_totals[i] = 0;
 	}
     }
     
@@ -905,9 +919,9 @@ void WI_updateDeathmatchStats(void)
 
     WI_updateAnimatedBack();
 
-    if (acceleratestage && dm_state != 4)
+    if (wi_.acceleratestage && widm_state != 4)
     {
-	acceleratestage = 0;
+	wi_.acceleratestage = 0;
 
 	for (i=0 ; i<MAXPLAYERS ; i++)
 	{
@@ -915,21 +929,21 @@ void WI_updateDeathmatchStats(void)
 	    {
 		for (j=0 ; j<MAXPLAYERS ; j++)
 		    if (playeringame[j])
-			dm_frags[i][j] = plrs[i].frags[j];
+			widm_frags[i][j] = wi_.plrs[i].frags[j];
 
-		dm_totals[i] = WI_fragSum(i);
+		widm_totals[i] = WI_fragSum(i);
 	    }
 	}
 	
 
 	S_StartSound(0, sfx_barexp);
-	dm_state = 4;
+	widm_state = 4;
     }
 
     
-    if (dm_state == 2)
+    if (widm_state == 2)
     {
-	if (!(bcnt&3))
+	if (!(wi_.bcnt&3))
 	    S_StartSound(0, sfx_pistol);
 	
 	stillticking = false;
@@ -941,42 +955,42 @@ void WI_updateDeathmatchStats(void)
 		for (j=0 ; j<MAXPLAYERS ; j++)
 		{
 		    if (playeringame[j]
-			&& dm_frags[i][j] != plrs[i].frags[j])
+			&& widm_frags[i][j] != wi_.plrs[i].frags[j])
 		    {
-			if (plrs[i].frags[j] < 0)
-			    dm_frags[i][j]--;
+			if (wi_.plrs[i].frags[j] < 0)
+			    widm_frags[i][j]--;
 			else
-			    dm_frags[i][j]++;
+			    widm_frags[i][j]++;
 
-			if (dm_frags[i][j] > 99)
-			    dm_frags[i][j] = 99;
+			if (widm_frags[i][j] > 99)
+			    widm_frags[i][j] = 99;
 
-			if (dm_frags[i][j] < -99)
-			    dm_frags[i][j] = -99;
+			if (widm_frags[i][j] < -99)
+			    widm_frags[i][j] = -99;
 			
 			stillticking = true;
 		    }
 		}
-		dm_totals[i] = WI_fragSum(i);
+		widm_totals[i] = WI_fragSum(i);
 
-		if (dm_totals[i] > 99)
-		    dm_totals[i] = 99;
+		if (widm_totals[i] > 99)
+		    widm_totals[i] = 99;
 		
-		if (dm_totals[i] < -99)
-		    dm_totals[i] = -99;
+		if (widm_totals[i] < -99)
+		    widm_totals[i] = -99;
 	    }
 	    
 	}
 	if (!stillticking)
 	{
 	    S_StartSound(0, sfx_barexp);
-	    dm_state++;
+	    widm_state++;
 	}
 
     }
-    else if (dm_state == 4)
+    else if (widm_state == 4)
     {
-	if (acceleratestage)
+	if (wi_.acceleratestage)
 	{
 	    S_StartSound(0, sfx_slop);
 
@@ -986,12 +1000,12 @@ void WI_updateDeathmatchStats(void)
 		WI_initShowNextLoc();
 	}
     }
-    else if (dm_state & 1)
+    else if (widm_state & 1)
     {
-	if (!--cnt_pause)
+	if (!--wi_.cnt_pause)
 	{
-	    dm_state++;
-	    cnt_pause = TICRATE;
+	    widm_state++;
+	    wi_.cnt_pause = TICRATE;
 	}
     }
 }
@@ -1014,12 +1028,12 @@ void WI_drawDeathmatchStats(void)
     WI_drawLF();
 
     // draw stat titles (top line)
-    V_DrawPatch(DM_TOTALSX-SHORT(total->width)/2,
+    V_DrawPatch(widm_totalsX-SHORT(wi_.total->width)/2,
 		DM_MATRIXY-WI_SPACINGY+10,
-		total);
+		wi_.total);
     
-    V_DrawPatch(DM_KILLERSX, DM_KILLERSY, killers);
-    V_DrawPatch(DM_VICTIMSX, DM_VICTIMSY, victims);
+    V_DrawPatch(DM_KILLERSX, DM_KILLERSY, wi_.killers);
+    V_DrawPatch(DM_VICTIMSX, DM_VICTIMSY, wi_.victims);
 
     // draw P?
     x = DM_MATRIXX + DM_SPACINGX;
@@ -1029,23 +1043,23 @@ void WI_drawDeathmatchStats(void)
     {
 	if (playeringame[i])
 	{
-	    V_DrawPatch(x-SHORT(p[i]->width)/2,
+	    V_DrawPatch(x-SHORT(wi_.p[i]->width)/2,
 			DM_MATRIXY - WI_SPACINGY,
-			p[i]);
+			wi_.p[i]);
 	    
-	    V_DrawPatch(DM_MATRIXX-SHORT(p[i]->width)/2,
+	    V_DrawPatch(DM_MATRIXX-SHORT(wi_.p[i]->width)/2,
 			y,
-			p[i]);
+			wi_.p[i]);
 
-	    if (i == me)
+	    if (i == wi_.me)
 	    {
-		V_DrawPatch(x-SHORT(p[i]->width)/2,
+		V_DrawPatch(x-SHORT(wi_.p[i]->width)/2,
 			    DM_MATRIXY - WI_SPACINGY,
-			    bstar);
+			    wi_.bstar);
 
-		V_DrawPatch(DM_MATRIXX-SHORT(p[i]->width)/2,
+		V_DrawPatch(DM_MATRIXX-SHORT(wi_.p[i]->width)/2,
 			    y,
-			    star);
+			    wi_.star);
 	    }
 	}
 	else
@@ -1061,7 +1075,7 @@ void WI_drawDeathmatchStats(void)
 
     // draw stats
     y = DM_MATRIXY+10;
-    w = SHORT(num[0]->width);
+    w = SHORT(wi_.num[0]->width);
 
     for (i=0 ; i<MAXPLAYERS ; i++)
     {
@@ -1072,42 +1086,42 @@ void WI_drawDeathmatchStats(void)
 	    for (j=0 ; j<MAXPLAYERS ; j++)
 	    {
 		if (playeringame[j])
-		    WI_drawNum(x+w, y, dm_frags[i][j], 2);
+		    WI_drawNum(x+w, y, widm_frags[i][j], 2);
 
 		x += DM_SPACINGX;
 	    }
-	    WI_drawNum(DM_TOTALSX+w, y, dm_totals[i], 2);
+	    WI_drawNum(widm_totalsX+w, y, widm_totals[i], 2);
 	}
 	y += WI_SPACINGY;
     }
 }
 
-static int	cnt_frags[MAXPLAYERS];
-static int	dofrags;
-static int	ng_state;
+int	wi_cnt_frags[MAXPLAYERS];
+int	wi_dofrags;
+int	wi_ng_state;
 
 void WI_initNetgameStats(void)
 {
 
     int i;
 
-    state = StatCount;
-    acceleratestage = 0;
-    ng_state = 1;
+    wi_.state = StatCount;
+    wi_.acceleratestage = 0;
+    wi_ng_state = 1;
 
-    cnt_pause = TICRATE;
+    wi_.cnt_pause = TICRATE;
 
     for (i=0 ; i<MAXPLAYERS ; i++)
     {
 	if (!playeringame[i])
 	    continue;
 
-	cnt_kills[i] = cnt_items[i] = cnt_secret[i] = cnt_frags[i] = 0;
+	wi_.cnt_kills[i] = wi_.cnt_items[i] = wi_.cnt_secret[i] = wi_cnt_frags[i] = 0;
 
-	dofrags += WI_fragSum(i);
+	wi_dofrags += WI_fragSum(i);
     }
 
-    dofrags = !!dofrags;
+    wi_dofrags = !!wi_dofrags;
 
     WI_initAnimatedBack();
 }
@@ -1124,29 +1138,29 @@ void WI_updateNetgameStats(void)
 
     WI_updateAnimatedBack();
 
-    if (acceleratestage && ng_state != 10)
+    if (wi_.acceleratestage && wi_ng_state != 10)
     {
-	acceleratestage = 0;
+	wi_.acceleratestage = 0;
 
 	for (i=0 ; i<MAXPLAYERS ; i++)
 	{
 	    if (!playeringame[i])
 		continue;
 
-	    cnt_kills[i] = (plrs[i].skills * 100) / wbs->maxkills;
-	    cnt_items[i] = (plrs[i].sitems * 100) / wbs->maxitems;
-	    cnt_secret[i] = (plrs[i].ssecret * 100) / wbs->maxsecret;
+	    wi_.cnt_kills[i] = (wi_.plrs[i].skills * 100) / wi_.wbs->maxkills;
+	    wi_.cnt_items[i] = (wi_.plrs[i].sitems * 100) / wi_.wbs->maxitems;
+	    wi_.cnt_secret[i] = (wi_.plrs[i].ssecret * 100) / wi_.wbs->maxsecret;
 
-	    if (dofrags)
-		cnt_frags[i] = WI_fragSum(i);
+	    if (wi_dofrags)
+		wi_cnt_frags[i] = WI_fragSum(i);
 	}
 	S_StartSound(0, sfx_barexp);
-	ng_state = 10;
+	wi_ng_state = 10;
     }
 
-    if (ng_state == 2)
+    if (wi_ng_state == 2)
     {
-	if (!(bcnt&3))
+	if (!(wi_.bcnt&3))
 	    S_StartSound(0, sfx_pistol);
 
 	stillticking = false;
@@ -1156,10 +1170,10 @@ void WI_updateNetgameStats(void)
 	    if (!playeringame[i])
 		continue;
 
-	    cnt_kills[i] += 2;
+	    wi_.cnt_kills[i] += 2;
 
-	    if (cnt_kills[i] >= (plrs[i].skills * 100) / wbs->maxkills)
-		cnt_kills[i] = (plrs[i].skills * 100) / wbs->maxkills;
+	    if (wi_.cnt_kills[i] >= (wi_.plrs[i].skills * 100) / wi_.wbs->maxkills)
+		wi_.cnt_kills[i] = (wi_.plrs[i].skills * 100) / wi_.wbs->maxkills;
 	    else
 		stillticking = true;
 	}
@@ -1167,12 +1181,12 @@ void WI_updateNetgameStats(void)
 	if (!stillticking)
 	{
 	    S_StartSound(0, sfx_barexp);
-	    ng_state++;
+	    wi_ng_state++;
 	}
     }
-    else if (ng_state == 4)
+    else if (wi_ng_state == 4)
     {
-	if (!(bcnt&3))
+	if (!(wi_.bcnt&3))
 	    S_StartSound(0, sfx_pistol);
 
 	stillticking = false;
@@ -1182,21 +1196,21 @@ void WI_updateNetgameStats(void)
 	    if (!playeringame[i])
 		continue;
 
-	    cnt_items[i] += 2;
-	    if (cnt_items[i] >= (plrs[i].sitems * 100) / wbs->maxitems)
-		cnt_items[i] = (plrs[i].sitems * 100) / wbs->maxitems;
+	    wi_.cnt_items[i] += 2;
+	    if (wi_.cnt_items[i] >= (wi_.plrs[i].sitems * 100) / wi_.wbs->maxitems)
+		wi_.cnt_items[i] = (wi_.plrs[i].sitems * 100) / wi_.wbs->maxitems;
 	    else
 		stillticking = true;
 	}
 	if (!stillticking)
 	{
 	    S_StartSound(0, sfx_barexp);
-	    ng_state++;
+	    wi_ng_state++;
 	}
     }
-    else if (ng_state == 6)
+    else if (wi_ng_state == 6)
     {
-	if (!(bcnt&3))
+	if (!(wi_.bcnt&3))
 	    S_StartSound(0, sfx_pistol);
 
 	stillticking = false;
@@ -1206,10 +1220,10 @@ void WI_updateNetgameStats(void)
 	    if (!playeringame[i])
 		continue;
 
-	    cnt_secret[i] += 2;
+	    wi_.cnt_secret[i] += 2;
 
-	    if (cnt_secret[i] >= (plrs[i].ssecret * 100) / wbs->maxsecret)
-		cnt_secret[i] = (plrs[i].ssecret * 100) / wbs->maxsecret;
+	    if (wi_.cnt_secret[i] >= (wi_.plrs[i].ssecret * 100) / wi_.wbs->maxsecret)
+		wi_.cnt_secret[i] = (wi_.plrs[i].ssecret * 100) / wi_.wbs->maxsecret;
 	    else
 		stillticking = true;
 	}
@@ -1217,12 +1231,12 @@ void WI_updateNetgameStats(void)
 	if (!stillticking)
 	{
 	    S_StartSound(0, sfx_barexp);
-	    ng_state += 1 + 2*!dofrags;
+	    wi_ng_state += 1 + 2*!wi_dofrags;
 	}
     }
-    else if (ng_state == 8)
+    else if (wi_ng_state == 8)
     {
-	if (!(bcnt&3))
+	if (!(wi_.bcnt&3))
 	    S_StartSound(0, sfx_pistol);
 
 	stillticking = false;
@@ -1232,10 +1246,10 @@ void WI_updateNetgameStats(void)
 	    if (!playeringame[i])
 		continue;
 
-	    cnt_frags[i] += 1;
+	    wi_cnt_frags[i] += 1;
 
-	    if (cnt_frags[i] >= (fsum = WI_fragSum(i)))
-		cnt_frags[i] = fsum;
+	    if (wi_cnt_frags[i] >= (fsum = WI_fragSum(i)))
+		wi_cnt_frags[i] = fsum;
 	    else
 		stillticking = true;
 	}
@@ -1243,12 +1257,12 @@ void WI_updateNetgameStats(void)
 	if (!stillticking)
 	{
 	    S_StartSound(0, sfx_pldeth);
-	    ng_state++;
+	    wi_ng_state++;
 	}
     }
-    else if (ng_state == 10)
+    else if (wi_ng_state == 10)
     {
-	if (acceleratestage)
+	if (wi_.acceleratestage)
 	{
 	    S_StartSound(0, sfx_sgcock);
 	    if ( gamemode == commercial )
@@ -1257,12 +1271,12 @@ void WI_updateNetgameStats(void)
 		WI_initShowNextLoc();
 	}
     }
-    else if (ng_state & 1)
+    else if (wi_ng_state & 1)
     {
-	if (!--cnt_pause)
+	if (!--wi_.cnt_pause)
 	{
-	    ng_state++;
-	    cnt_pause = TICRATE;
+	    wi_ng_state++;
+	    wi_.cnt_pause = TICRATE;
 	}
     }
 }
@@ -1274,7 +1288,7 @@ void WI_drawNetgameStats(void)
     int		i;
     int		x;
     int		y;
-    int		pwidth = SHORT(percent->width);
+    int		pwidth = SHORT(wi_.percent->width);
 
     WI_slamBackground();
     
@@ -1284,21 +1298,21 @@ void WI_drawNetgameStats(void)
     WI_drawLF();
 
     // draw stat titles (top line)
-    V_DrawPatch(NG_STATSX+NG_SPACINGX-SHORT(kills->width),
-		NG_STATSY, kills);
+    V_DrawPatch(NG_STATSX+NG_SPACINGX-SHORT(wi_.kills->width),
+		NG_STATSY, wi_.kills);
 
-    V_DrawPatch(NG_STATSX+2*NG_SPACINGX-SHORT(items->width),
-		NG_STATSY, items);
+    V_DrawPatch(NG_STATSX+2*NG_SPACINGX-SHORT(wi_.items->width),
+		NG_STATSY, wi_.items);
 
-    V_DrawPatch(NG_STATSX+3*NG_SPACINGX-SHORT(secret->width),
-		NG_STATSY, secret);
+    V_DrawPatch(NG_STATSX+3*NG_SPACINGX-SHORT(wi_.secret->width),
+		NG_STATSY, wi_.secret);
     
-    if (dofrags)
-	V_DrawPatch(NG_STATSX+4*NG_SPACINGX-SHORT(frags->width),
-		    NG_STATSY, frags);
+    if (wi_dofrags)
+	V_DrawPatch(NG_STATSX+4*NG_SPACINGX-SHORT(wi_.frags->width),
+		    NG_STATSY, wi_.frags);
 
     // draw stats
-    y = NG_STATSY + SHORT(kills->height);
+    y = NG_STATSY + SHORT(wi_.kills->height);
 
     for (i=0 ; i<MAXPLAYERS ; i++)
     {
@@ -1306,34 +1320,34 @@ void WI_drawNetgameStats(void)
 	    continue;
 
 	x = NG_STATSX;
-	V_DrawPatch(x-SHORT(p[i]->width), y, p[i]);
+	V_DrawPatch(x-SHORT(wi_.p[i]->width), y, wi_.p[i]);
 
-	if (i == me)
-	    V_DrawPatch(x-SHORT(p[i]->width), y, star);
+	if (i == wi_.me)
+	    V_DrawPatch(x-SHORT(wi_.p[i]->width), y, wi_.star);
 
 	x += NG_SPACINGX;
-	WI_drawPercent(x-pwidth, y+10, cnt_kills[i]);	x += NG_SPACINGX;
-	WI_drawPercent(x-pwidth, y+10, cnt_items[i]);	x += NG_SPACINGX;
-	WI_drawPercent(x-pwidth, y+10, cnt_secret[i]);	x += NG_SPACINGX;
+	WI_drawPercent(x-pwidth, y+10, wi_.cnt_kills[i]);	x += NG_SPACINGX;
+	WI_drawPercent(x-pwidth, y+10, wi_.cnt_items[i]);	x += NG_SPACINGX;
+	WI_drawPercent(x-pwidth, y+10, wi_.cnt_secret[i]);	x += NG_SPACINGX;
 
-	if (dofrags)
-	    WI_drawNum(x, y+10, cnt_frags[i], -1);
+	if (wi_dofrags)
+	    WI_drawNum(x, y+10, wi_cnt_frags[i], -1);
 
 	y += WI_SPACINGY;
     }
 
 }
 
-static int	sp_state;
+int	wi_sp_state;
 
 void WI_initStats(void)
 {
-    state = StatCount;
-    acceleratestage = 0;
-    sp_state = 1;
-    cnt_kills[0] = cnt_items[0] = cnt_secret[0] = -1;
-    cnt_time = cnt_par = -1;
-    cnt_pause = TICRATE;
+    wi_.state = StatCount;
+    wi_.acceleratestage = 0;
+    wi_sp_state = 1;
+    wi_.cnt_kills[0] = wi_.cnt_items[0] = wi_.cnt_secret[0] = -1;
+    wi_.cnt_time = wi_.cnt_par = -1;
+    wi_.cnt_pause = TICRATE;
 
     WI_initAnimatedBack();
 }
@@ -1343,87 +1357,87 @@ void WI_updateStats(void)
 
     WI_updateAnimatedBack();
 
-    if (acceleratestage && sp_state != 10)
+    if (wi_.acceleratestage && wi_sp_state != 10)
     {
-	acceleratestage = 0;
-	cnt_kills[0] = (plrs[me].skills * 100) / wbs->maxkills;
-	cnt_items[0] = (plrs[me].sitems * 100) / wbs->maxitems;
-	cnt_secret[0] = (plrs[me].ssecret * 100) / wbs->maxsecret;
-	cnt_time = plrs[me].stime / TICRATE;
-	cnt_par = wbs->partime / TICRATE;
+	wi_.acceleratestage = 0;
+	wi_.cnt_kills[0] = (wi_.plrs[wi_.me].skills * 100) / wi_.wbs->maxkills;
+	wi_.cnt_items[0] = (wi_.plrs[wi_.me].sitems * 100) / wi_.wbs->maxitems;
+	wi_.cnt_secret[0] = (wi_.plrs[wi_.me].ssecret * 100) / wi_.wbs->maxsecret;
+	wi_.cnt_time = wi_.plrs[wi_.me].stime / TICRATE;
+	wi_.cnt_par = wi_.wbs->partime / TICRATE;
 	S_StartSound(0, sfx_barexp);
-	sp_state = 10;
+	wi_sp_state = 10;
     }
 
-    if (sp_state == 2)
+    if (wi_sp_state == 2)
     {
-	cnt_kills[0] += 2;
+	wi_.cnt_kills[0] += 2;
 
-	if (!(bcnt&3))
+	if (!(wi_.bcnt&3))
 	    S_StartSound(0, sfx_pistol);
 
-	if (cnt_kills[0] >= (plrs[me].skills * 100) / wbs->maxkills)
+	if (wi_.cnt_kills[0] >= (wi_.plrs[wi_.me].skills * 100) / wi_.wbs->maxkills)
 	{
-	    cnt_kills[0] = (plrs[me].skills * 100) / wbs->maxkills;
+	    wi_.cnt_kills[0] = (wi_.plrs[wi_.me].skills * 100) / wi_.wbs->maxkills;
 	    S_StartSound(0, sfx_barexp);
-	    sp_state++;
+	    wi_sp_state++;
 	}
     }
-    else if (sp_state == 4)
+    else if (wi_sp_state == 4)
     {
-	cnt_items[0] += 2;
+	wi_.cnt_items[0] += 2;
 
-	if (!(bcnt&3))
+	if (!(wi_.bcnt&3))
 	    S_StartSound(0, sfx_pistol);
 
-	if (cnt_items[0] >= (plrs[me].sitems * 100) / wbs->maxitems)
+	if (wi_.cnt_items[0] >= (wi_.plrs[wi_.me].sitems * 100) / wi_.wbs->maxitems)
 	{
-	    cnt_items[0] = (plrs[me].sitems * 100) / wbs->maxitems;
+	    wi_.cnt_items[0] = (wi_.plrs[wi_.me].sitems * 100) / wi_.wbs->maxitems;
 	    S_StartSound(0, sfx_barexp);
-	    sp_state++;
+	    wi_sp_state++;
 	}
     }
-    else if (sp_state == 6)
+    else if (wi_sp_state == 6)
     {
-	cnt_secret[0] += 2;
+	wi_.cnt_secret[0] += 2;
 
-	if (!(bcnt&3))
+	if (!(wi_.bcnt&3))
 	    S_StartSound(0, sfx_pistol);
 
-	if (cnt_secret[0] >= (plrs[me].ssecret * 100) / wbs->maxsecret)
+	if (wi_.cnt_secret[0] >= (wi_.plrs[wi_.me].ssecret * 100) / wi_.wbs->maxsecret)
 	{
-	    cnt_secret[0] = (plrs[me].ssecret * 100) / wbs->maxsecret;
+	    wi_.cnt_secret[0] = (wi_.plrs[wi_.me].ssecret * 100) / wi_.wbs->maxsecret;
 	    S_StartSound(0, sfx_barexp);
-	    sp_state++;
+	    wi_sp_state++;
 	}
     }
 
-    else if (sp_state == 8)
+    else if (wi_sp_state == 8)
     {
-	if (!(bcnt&3))
+	if (!(wi_.bcnt&3))
 	    S_StartSound(0, sfx_pistol);
 
-	cnt_time += 3;
+	wi_.cnt_time += 3;
 
-	if (cnt_time >= plrs[me].stime / TICRATE)
-	    cnt_time = plrs[me].stime / TICRATE;
+	if (wi_.cnt_time >= wi_.plrs[wi_.me].stime / TICRATE)
+	    wi_.cnt_time = wi_.plrs[wi_.me].stime / TICRATE;
 
-	cnt_par += 3;
+	wi_.cnt_par += 3;
 
-	if (cnt_par >= wbs->partime / TICRATE)
+	if (wi_.cnt_par >= wi_.wbs->partime / TICRATE)
 	{
-	    cnt_par = wbs->partime / TICRATE;
+	    wi_.cnt_par = wi_.wbs->partime / TICRATE;
 
-	    if (cnt_time >= plrs[me].stime / TICRATE)
+	    if (wi_.cnt_time >= wi_.plrs[wi_.me].stime / TICRATE)
 	    {
 		S_StartSound(0, sfx_barexp);
-		sp_state++;
+		wi_sp_state++;
 	    }
 	}
     }
-    else if (sp_state == 10)
+    else if (wi_sp_state == 10)
     {
-	if (acceleratestage)
+	if (wi_.acceleratestage)
 	{
 	    S_StartSound(0, sfx_sgcock);
 
@@ -1433,12 +1447,12 @@ void WI_updateStats(void)
 		WI_initShowNextLoc();
 	}
     }
-    else if (sp_state & 1)
+    else if (wi_sp_state & 1)
     {
-	if (!--cnt_pause)
+	if (!--wi_.cnt_pause)
 	{
-	    sp_state++;
-	    cnt_pause = TICRATE;
+	    wi_sp_state++;
+	    wi_.cnt_pause = TICRATE;
 	}
     }
 
@@ -1449,7 +1463,7 @@ void WI_drawStats(void)
     // line height
     int lh;	
 
-    lh = (3*SHORT(num[0]->height))/2;
+    lh = (3*SHORT(wi_.num[0]->height))/2;
 
     WI_slamBackground();
 
@@ -1458,22 +1472,22 @@ void WI_drawStats(void)
     
     WI_drawLF();
 
-    V_DrawPatch(SP_STATSX, SP_STATSY, kills);
-    WI_drawPercent(SCREENWIDTH - SP_STATSX, SP_STATSY, cnt_kills[0]);
+    V_DrawPatch(SP_STATSX, SP_STATSY, wi_.kills);
+    WI_drawPercent(SCREENWIDTH - SP_STATSX, SP_STATSY, wi_.cnt_kills[0]);
 
-    V_DrawPatch(SP_STATSX, SP_STATSY+lh, items);
-    WI_drawPercent(SCREENWIDTH - SP_STATSX, SP_STATSY+lh, cnt_items[0]);
+    V_DrawPatch(SP_STATSX, SP_STATSY+lh, wi_.items);
+    WI_drawPercent(SCREENWIDTH - SP_STATSX, SP_STATSY+lh, wi_.cnt_items[0]);
 
-    V_DrawPatch(SP_STATSX, SP_STATSY+2*lh, sp_secret);
-    WI_drawPercent(SCREENWIDTH - SP_STATSX, SP_STATSY+2*lh, cnt_secret[0]);
+    V_DrawPatch(SP_STATSX, SP_STATSY+2*lh, wi_.sp_secret);
+    WI_drawPercent(SCREENWIDTH - SP_STATSX, SP_STATSY+2*lh, wi_.cnt_secret[0]);
 
-    V_DrawPatch(SP_TIMEX, SP_TIMEY, timepatch);
-    WI_drawTime(SCREENWIDTH/2 - SP_TIMEX, SP_TIMEY, cnt_time);
+    V_DrawPatch(SP_TIMEX, SP_TIMEY, wi_.timepatch);
+    WI_drawTime(SCREENWIDTH/2 - SP_TIMEX, SP_TIMEY, wi_.cnt_time);
 
-    if (wbs->epsd < 3)
+    if (wi_.wbs->epsd < 3)
     {
-	V_DrawPatch(SCREENWIDTH/2 + SP_TIMEX, SP_TIMEY, par);
-	WI_drawTime(SCREENWIDTH - SP_TIMEX, SP_TIMEY, cnt_par);
+	V_DrawPatch(SCREENWIDTH/2 + SP_TIMEX, SP_TIMEY, wi_.par);
+	WI_drawTime(SCREENWIDTH - SP_TIMEX, SP_TIMEY, wi_.cnt_par);
     }
 
 }
@@ -1491,7 +1505,7 @@ void WI_checkForAccelerate(void)
 	    if (player->cmd.buttons & BT_ATTACK)
 	    {
 		if (!player->attackdown)
-		    acceleratestage = 1;
+		    wi_.acceleratestage = 1;
 		player->attackdown = true;
 	    }
 	    else
@@ -1499,7 +1513,7 @@ void WI_checkForAccelerate(void)
 	    if (player->cmd.buttons & BT_USE)
 	    {
 		if (!player->usedown)
-		    acceleratestage = 1;
+		    wi_.acceleratestage = 1;
 		player->usedown = true;
 	    }
 	    else
@@ -1514,9 +1528,9 @@ void WI_checkForAccelerate(void)
 void WI_Ticker(void)
 {
     // counter for general background animation
-    bcnt++;  
+    wi_.bcnt++;  
 
-    if (bcnt == 1)
+    if (wi_.bcnt == 1)
     {
 	// intermission music
   	if ( gamemode == commercial )
@@ -1527,7 +1541,7 @@ void WI_Ticker(void)
 
     WI_checkForAccelerate();
 
-    switch (state)
+    switch (wi_.state)
     {
       case StatCount:
 	if (deathmatch) WI_updateDeathmatchStats();
@@ -1554,52 +1568,54 @@ typedef void (*load_callback_t)(char *lumpname, patch_t **variable);
 static void WI_loadUnloadData(load_callback_t callback)
 {
     int i, j;
-    char name[9];
-    anim_t *a;
+    char name[40];
+    const anim_t *a;
+    anim_state_t *s;
 
     if (gamemode == commercial)
     {
-	for (i=0 ; i<NUMCMAPS ; i++)
+	for (i=0 ; i<wi_.NUMCMAPS ; i++)
 	{
-	    DEH_snprintf(name, 9, "CWILV%2.2d", i);
-            callback(name, &lnames[i]);
+	    DEH_snprintf(name, 16, "CWILV%2.2d", i);
+            callback(name, &wi_.lnames[i]);
 	}
     }
     else
     {
 	for (i=0 ; i<NUMMAPS ; i++)
 	{
-	    DEH_snprintf(name, 9, "WILV%d%d", wbs->epsd, i);
-            callback(name, &lnames[i]);
+	    DEH_snprintf(name, 16, "WILV%d%d", wi_.wbs->epsd, i);
+            callback(name, &wi_.lnames[i]);
 	}
 
 	// you are here
-        callback(DEH_String("WIURH0"), &yah[0]);
+        callback(DEH_String("WIURH0"), &wi_.yah[0]);
 
 	// you are here (alt.)
-        callback(DEH_String("WIURH1"), &yah[1]);
+        callback(DEH_String("WIURH1"), &wi_.yah[1]);
 
 	// splat
-        callback(DEH_String("WISPLAT"), &splat[0]);
+        callback(DEH_String("WISPLAT"), &wi_.splat[0]);
 
-	if (wbs->epsd < 3)
+	if (wi_.wbs->epsd < 3)
 	{
-	    for (j=0;j<NUMANIMS[wbs->epsd];j++)
+	    for (j=0;j<NUMANIMS[wi_.wbs->epsd];j++)
 	    {
-		a = &anims[wbs->epsd][j];
+		a = &anims[wi_.wbs->epsd][j];
+                s = &wi_.an_state[wi_.wbs->epsd][j];
 		for (i=0;i<a->nanims;i++)
 		{
 		    // MONDO HACK!
-		    if (wbs->epsd != 1 || j != 8)
+		    if (wi_.wbs->epsd != 1 || j != 8)
 		    {
 			// animations
-			DEH_snprintf(name, 9, "WIA%d%.2d%.2d", wbs->epsd, j, i);
-                        callback(name, &a->p[i]);
+			DEH_snprintf(name, 35, "WIA%d%.2d%.2d", wi_.wbs->epsd, j, i);
+                        callback(name, &s->p[i]);
 		    }
 		    else
 		    {
 			// HACK ALERT!
-			a->p[i] = anims[1][4].p[i];
+			s->p[i] = wi_.an_state[1][4].p[i];
 		    }
 		}
 	    }
@@ -1607,78 +1623,78 @@ static void WI_loadUnloadData(load_callback_t callback)
     }
 
     // More hacks on minus sign.
-    callback(DEH_String("WIMINUS"), &wiminus);
+    callback(DEH_String("WIMINUS"), &wi_.wiminus);
 
     for (i=0;i<10;i++)
     {
 	 // numbers 0-9
-	DEH_snprintf(name, 9, "WINUM%d", i);
-        callback(name, &num[i]);
+	DEH_snprintf(name, 16, "WINUM%d", i);
+        callback(name, &wi_.num[i]);
     }
 
     // percent sign
-    callback(DEH_String("WIPCNT"), &percent);
+    callback(DEH_String("WIPCNT"), &wi_.percent);
 
     // "finished"
-    callback(DEH_String("WIF"), &finished);
+    callback(DEH_String("WIF"), &wi_.finished);
 
     // "entering"
-    callback(DEH_String("WIENTER"), &entering);
+    callback(DEH_String("WIENTER"), &wi_.entering);
 
     // "kills"
-    callback(DEH_String("WIOSTK"), &kills);
+    callback(DEH_String("WIOSTK"), &wi_.kills);
 
     // "scrt"
-    callback(DEH_String("WIOSTS"), &secret);
+    callback(DEH_String("WIOSTS"), &wi_.secret);
 
      // "secret"
-    callback(DEH_String("WISCRT2"), &sp_secret);
+    callback(DEH_String("WISCRT2"), &wi_.sp_secret);
 
     // french wad uses WIOBJ (?)
     if (W_CheckNumForName(DEH_String("WIOBJ")) >= 0)
     {
     	// "items"
     	if (netgame && !deathmatch)
-            callback(DEH_String("WIOBJ"), &items);
+            callback(DEH_String("WIOBJ"), &wi_.items);
     	else
-            callback(DEH_String("WIOSTI"), &items);
+            callback(DEH_String("WIOSTI"), &wi_.items);
     } else {
-        callback(DEH_String("WIOSTI"), &items);
+        callback(DEH_String("WIOSTI"), &wi_.items);
     }
 
     // "frgs"
-    callback(DEH_String("WIFRGS"), &frags);
+    callback(DEH_String("WIFRGS"), &wi_.frags);
 
     // ":"
-    callback(DEH_String("WICOLON"), &colon);
+    callback(DEH_String("WICOLON"), &wi_.colon);
 
     // "time"
-    callback(DEH_String("WITIME"), &timepatch);
+    callback(DEH_String("WITIME"), &wi_.timepatch);
 
     // "sucks"
-    callback(DEH_String("WISUCKS"), &sucks);
+    callback(DEH_String("WISUCKS"), &wi_.sucks);
 
     // "par"
-    callback(DEH_String("WIPAR"), &par);
+    callback(DEH_String("WIPAR"), &wi_.par);
 
     // "killers" (vertical)
-    callback(DEH_String("WIKILRS"), &killers);
+    callback(DEH_String("WIKILRS"), &wi_.killers);
 
     // "victims" (horiz)
-    callback(DEH_String("WIVCTMS"), &victims);
+    callback(DEH_String("WIVCTMS"), &wi_.victims);
 
     // "total"
-    callback(DEH_String("WIMSTT"), &total);
+    callback(DEH_String("WIMSTT"), &wi_.total);
 
     for (i=0 ; i<MAXPLAYERS ; i++)
     {
 	// "1,2,3,4"
-	DEH_snprintf(name, 9, "STPB%d", i);
-        callback(name, &p[i]);
+	DEH_snprintf(name, 16, "STPB%d", i);
+        callback(name, &wi_.p[i]);
 
 	// "1,2,3,4"
-	DEH_snprintf(name, 9, "WIBP%d", i+1);
-        callback(name, &bp[i]);
+	DEH_snprintf(name, 16, "WIBP%d", i+1);
+        callback(name, &wi_.bp[i]);
     }
 
     // Background image
@@ -1687,18 +1703,18 @@ static void WI_loadUnloadData(load_callback_t callback)
     {
         M_StringCopy(name, DEH_String("INTERPIC"), sizeof(name));
     }
-    else if (gamemode == retail && wbs->epsd == 3)
+    else if (gamemode == retail && wi_.wbs->epsd == 3)
     {
         M_StringCopy(name, DEH_String("INTERPIC"), sizeof(name));
     }
     else
     {
-	DEH_snprintf(name, sizeof(name), "WIMAP%d", wbs->epsd);
+	DEH_snprintf(name, sizeof(name), "WIMAP%d", wi_.wbs->epsd);
     }
 
     // Draw backdrop and save to a temporary buffer
 
-    callback(name, &background);
+    callback(name, &wi_.background);
 }
 
 static void WI_loadCallback(char *name, patch_t **variable)
@@ -1710,13 +1726,13 @@ void WI_loadData(void)
 {
     if (gamemode == commercial)
     {
-	NUMCMAPS = 32;
-	lnames = (patch_t **) Z_Malloc(sizeof(patch_t*) * NUMCMAPS,
+	wi_.NUMCMAPS = 32;
+	wi_.lnames = (patch_t **) Z_Malloc(sizeof(patch_t*) * wi_.NUMCMAPS,
 				       PU_STATIC, NULL);
     }
     else
     {
-	lnames = (patch_t **) Z_Malloc(sizeof(patch_t*) * NUMMAPS,
+	wi_.lnames = (patch_t **) Z_Malloc(sizeof(patch_t*) * NUMMAPS,
 				       PU_STATIC, NULL);
     }
 
@@ -1726,10 +1742,10 @@ void WI_loadData(void)
     // them with the status bar code
 
     // your face
-    star = W_CacheLumpName(DEH_String("STFST01"), PU_STATIC);
+    wi_.star = W_CacheLumpName(DEH_String("STFST01"), PU_STATIC);
 
     // dead face
-    bstar = W_CacheLumpName(DEH_String("STFDEAD0"), PU_STATIC);
+    wi_.bstar = W_CacheLumpName(DEH_String("STFDEAD0"), PU_STATIC);
 }
 
 static void WI_unloadCallback(char *name, patch_t **variable)
@@ -1751,7 +1767,7 @@ void WI_unloadData(void)
 
 void WI_Drawer (void)
 {
-    switch (state)
+    switch (wi_.state)
     {
       case StatCount:
 	if (deathmatch)
@@ -1776,43 +1792,43 @@ void WI_Drawer (void)
 void WI_initVariables(wbstartstruct_t* wbstartstruct)
 {
 
-    wbs = wbstartstruct;
+    wi_.wbs = wbstartstruct;
 
 #ifdef RANGECHECKING
     if (gamemode != commercial)
     {
       if ( gamemode == retail )
-	RNGCHECK(wbs->epsd, 0, 3);
+	RNGCHECK(wi_.wbs->epsd, 0, 3);
       else
-	RNGCHECK(wbs->epsd, 0, 2);
+	RNGCHECK(wi_.wbs->epsd, 0, 2);
     }
     else
     {
-	RNGCHECK(wbs->last, 0, 8);
-	RNGCHECK(wbs->next, 0, 8);
+	RNGCHECK(wi_.wbs->last, 0, 8);
+	RNGCHECK(wi_.wbs->next, 0, 8);
     }
-    RNGCHECK(wbs->pnum, 0, MAXPLAYERS);
-    RNGCHECK(wbs->pnum, 0, MAXPLAYERS);
+    RNGCHECK(wi_.wbs->pnum, 0, MAXPLAYERS);
+    RNGCHECK(wi_.wbs->pnum, 0, MAXPLAYERS);
 #endif
 
-    acceleratestage = 0;
-    cnt = bcnt = 0;
-    firstrefresh = 1;
-    me = wbs->pnum;
-    plrs = wbs->plyr;
+    wi_.acceleratestage = 0;
+    wi_.cnt = wi_.bcnt = 0;
+    wi_.firstrefresh = 1;
+    wi_.me = wi_.wbs->pnum;
+    wi_.plrs = wi_.wbs->plyr;
 
-    if (!wbs->maxkills)
-	wbs->maxkills = 1;
+    if (!wi_.wbs->maxkills)
+	wi_.wbs->maxkills = 1;
 
-    if (!wbs->maxitems)
-	wbs->maxitems = 1;
+    if (!wi_.wbs->maxitems)
+	wi_.wbs->maxitems = 1;
 
-    if (!wbs->maxsecret)
-	wbs->maxsecret = 1;
+    if (!wi_.wbs->maxsecret)
+	wi_.wbs->maxsecret = 1;
 
     if ( gamemode != retail )
-      if (wbs->epsd > 2)
-	wbs->epsd -= 3;
+      if (wi_.wbs->epsd > 2)
+	wi_.wbs->epsd -= 3;
 }
 
 void WI_Start(wbstartstruct_t* wbstartstruct)
